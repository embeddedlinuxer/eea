!<arch>
assert.h/       925421706   0     0     0       891       `
/*****************************************************************************/
/* assert.h V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _ASSERT
#define _ASSERT

void _nassert(int), _assert(int, char *);
void _abort_msg(char*);
void abort(void);

#define _STR(x)  __STR(x)
#define __STR(x) #x

#if defined(NDEBUG)
#define assert(_ignore) ((void)0)

#elif defined(NASSERT)
#define assert(_expr)	_nassert(_expr)

#else
#include <stdio.h>
#include <stdlib.h>

#define assert(_expr)	((_expr) ? (void)0 :                             \
(fprintf(stderr, \
	"Assertion failed, (%s), file %s, line %d\n", _STR(_expr), \
	__FILE__, __LINE__), \
(void)abort())\
)

#endif
#endif

ctype.h/        925421706   0     0     0       4407      `
/*****************************************************************************/
/* ctype.h V5.11 for TMS3203x/4x                                            */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
/************************************************************************/
/*                                                                      */
/*  CHARACTER TYPING FUNCTIONS AND MACROS                               */
/*                                                                      */
/*  Note that in this implementation, either macros or functions may    */
/*  be used.  Macros are prefixed with an underscore.                   */
/*                                                                      */
/************************************************************************/
#ifndef _CTYPE
#define _CTYPE

extern unsigned char _ctypes_[];

#if defined(_INLINE)
# define __INLINE static inline
#else
# define __INLINE
#endif

/************************************************************************/
/*   FUNCTION DEFINITIONS                                               */
/************************************************************************/
__INLINE int isalnum(int _c);
__INLINE int isalpha(int _c);
__INLINE int iscntrl(int _c);
__INLINE int isdigit(int _c);
__INLINE int isgraph(int _c);
__INLINE int islower(int _c);
__INLINE int isprint(int _c);
__INLINE int ispunct(int _c);
__INLINE int isspace(int _c);
__INLINE int isupper(int _c);
__INLINE int isxdigit(int _c);
__INLINE int isascii(int _c);

__INLINE int toupper(int _c);
__INLINE int tolower(int _c);
__INLINE int toascii(int _c);

/************************************************************************/
/*  MACRO DEFINITIONS                                                   */
/************************************************************************/
#define _UC_   0x01           /* UPPER CASE  */
#define _LC_   0x02           /* LOWER CASE  */
#define _NM_   0x04           /* NUMERICAL   */
#define _SP_   0x08           /* SPACE       */
#define _PU_   0x10           /* PUNCTUATION */
#define _CL_   0x20           /* CONTROL     */
#define _HX_   0x40           /* HEX DIGIT   */
#define _BL_   0x80           /* BLANK       */

#define _isalnum(a)  (_ctypes_[(a)+1] & (_UC_ | _LC_ | _NM_))
#define _isalpha(a)  (_ctypes_[(a)+1] & (_UC_ | _LC_))
#define _iscntrl(a)  (_ctypes_[(a)+1] & _CL_)
#define _isdigit(a)  (_ctypes_[(a)+1] & _NM_)
#define _isgraph(a)  (_ctypes_[(a)+1] & (_UC_ | _LC_ | _NM_ | _PU_))
#define _islower(a)  (_ctypes_[(a)+1] & _LC_)
#define _isprint(a)  (_ctypes_[(a)+1] & (_BL_ | _UC_ | _LC_ | _NM_ | _PU_))
#define _ispunct(a)  (_ctypes_[(a)+1] & _PU_)
#define _isspace(a)  (_ctypes_[(a)+1] & _SP_)
#define _isupper(a)  (_ctypes_[(a)+1] & _UC_)
#define _isxdigit(a) (_ctypes_[(a)+1] & _HX_)
#define _isascii(a)  (((a) & ~0x7F) == 0)

#define _toupper(b)  ((_islower(b)) ? (b) - ('a' - 'A') : (b))
#define _tolower(b)  ((_isupper(b)) ? (b) + ('a' - 'A') : (b))
#define _toascii(a)  ((a) & 0x7F)

#if defined(_INLINE)
static inline int isalnum(int c)  { return(_isalnum(c));  }
static inline int isalpha(int c)  { return(_isalpha(c));  }
static inline int isascii(int c)  { return(_isascii(c));  }
static inline int iscntrl(int c)  { return(_iscntrl(c));  }
static inline int isdigit(int c)  { return(_isdigit(c));  }
static inline int isgraph(int c)  { return(_isgraph(c));  }
static inline int islower(int c)  { return(_islower(c));  }
static inline int isprint(int c)  { return(_isprint(c));  }
static inline int ispunct(int c)  { return(_ispunct(c));  }
static inline int isspace(int c)  { return(_isspace(c));  }
static inline int isupper(int c)  { return(_isupper(c));  }
static inline int isxdigit(int c) { return(_isxdigit(c)); }
static inline int toascii(int c)  { return(_toascii(c));  }

static inline int tolower(int ch)
{
   int ch2 = ch + ('a' - 'A');
   return ( (unsigned int)(ch - 'A') <= (unsigned int)('Z' - 'A')) ? ch2 : ch;
}

static inline int toupper(int ch)
{
   int ch2 = ch + ('A' - 'a');
   return ( (unsigned int)(ch - 'a') <= (unsigned int)('z' - 'a')) ? ch2 : ch;
}

#endif /* _INLINE_ */
#undef __INLINE

#endif /* _CTYPE */

errno.h/        925421706   0     0     0       462       `
/*****************************************************************************/
/*  ERRNO.H  V5.11                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

#ifndef _ERRNO
#define _ERRNO

extern int errno;

#define EDOM   1
#define ERANGE 2
#define ENOENT 3
#define EFPOS  5

#endif
file.h/         925421706   0     0     0       1854      `
/*****************************************************************************/
/*  FILE.H V5.11                                                            */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Macros and declarations used in lowlevel I/O functions.                   */
/*****************************************************************************/

/*---------------------------------------------------------------------------*/
/* constants for file manipulations                                          */
/*---------------------------------------------------------------------------*/
#define  O_RDONLY    (0x0000) /* open for reading      */
#define  O_WRONLY    (0x0001) /* open for writing      */
#define  O_RDWR      (0x0002) /* open for read & write */
#define  O_APPEND    (0x0008) /* append on each write  */
#define  O_CREAT     (0x0200) /* open with file create */
#define  O_TRUNC     (0x0400) /* open with truncation  */
#define  O_BINARY    (0x8000) /* open in binary mode   */

/*---------------------------------------------------------------------------*/
/* lowlevel I/O declarations                                                 */
/*---------------------------------------------------------------------------*/
extern int  open(const char *path, unsigned flags, int mode);
extern int  read(int fildes, char *bufptr, unsigned cnt);
extern int  write(int fildes, const char *bufptr, unsigned cnt);
extern long lseek(int fildes, long offset, int origin);
extern int  close(int fildes);
extern int  unlink(const char *path);
extern int  rename(const char *old_name, const char *new_name);

float.h/        925421708   0     0     0       2918      `
/*****************************************************************************/
/* float.h V5.11 for TMS3203x/4x                                            */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _FLOAT
#define _FLOAT

#define FLT_RADIX                   2   /* RADIX OF EXPONENT                 */
#define FLT_ROUNDS                 -1   /* INDETERMINATE, SINCE # BITS VARIES*/

#define FLT_DIG                     6   /* DECIMAL PRECISION                 */
#define FLT_MANT_DIG               24   /* BITS IN MANTISSA                  */
#define FLT_MIN_EXP              -126   /* MIN E SO 2 ** E-1 FITS            */
#define FLT_MAX_EXP               128   /* MAX E SO 2 ** E   FITS            */
#define FLT_EPSILON     1.1920929E-07   /* SMALLEST X WHERE 1+X != 1         */
		    	                /*    0xE9000000 (2 ^ -23)           */
#define FLT_MIN         5.8774718E-39   /* SMALLEST POSITIVE VALUE           */
                                        /*    0x81000000                     */
#define FLT_MAX         3.4028235E+38   /* LARGEST POSITIVE VALUE            */
			        	/*    0x7f7fffff                     */
#define FLT_MIN_10_EXP            -39   /* MIN POWER OF 10                   */
#define FLT_MAX_10_EXP             38   /* MAX POWER OF 10                   */

#define DBL_DIG                     6   /* DECIMAL PRECISION                 */
#define DBL_MANT_DIG               24   /* BITS IN MANTISSA                  */
#define DBL_MIN_EXP              -126   /* MIN E SO 2 ** E-1 FITS            */
#define DBL_MAX_EXP               128   /* MAX E SO 2 ** E   FITS            */
#define DBL_EPSILON     1.1920929E-07   /* SMALLEST X WHERE 1+X != 1         */
#define DBL_MIN         5.8774718E-39   /* SMALLEST POSITIVE VALUE           */
#define DBL_MAX         3.4028235E+38   /* LARGEST POSITIVE VALUE            */
#define DBL_MIN_10_EXP            -39   /* MIN POWER OF 10                   */
#define DBL_MAX_10_EXP             38   /* MAX POWER OF 10                   */

#define LDBL_DIG                    8   /* DECIMAL PRECISION                 */
#define LDBL_MANT_DIG              32   /* BITS IN MANTISSA                  */
#define LDBL_MIN_EXP             -126   /* MIN E SO 2 ** E-1 FITS            */
#define LDBL_MAX_EXP              128   /* MAX E SO 2 ** E   FITS            */
#define LDBL_EPSILON   1.19209287E-07L  /* SMALLEST X WHERE 1+X != 1         */
#define LDBL_MIN     5.8774717535E-39L  /* SMALLEST POSITIVE VALUE           */
#define LDBL_MAX     3.4028236688E+38L  /* LARGEST POSITIVE VALUE            */
#define LDBL_MIN_10_EXP           -39   /* MIN POWER OF 10                   */
#define LDBL_MAX_10_EXP            38   /* MAX POWER OF 10                   */
#endif
format.h/       925421708   0     0     0       2129      `
/*****************************************************************************/
/*  FORMAT.H V5.11                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Structures and macros used in printf and scanf                            */
/*****************************************************************************/
#ifndef __FORMAT_H
#define __FORMAT_H
#include <stdarg.h>

#define _ARSIZE 128

extern int _scanfi(void *inp, const char *_format, va_list _ap,
            int (*_chkmbc)(void **inp, char **_format, int *num_read),
            char (*_inpchar)(void **inp),
            void (*_uninpchar)(void **inp, char outchar));
 
/****************************************************************************/
/* _FIELD STRUCTURE AND MACROS USED FOR PRINTF AND SCANF                    */
/****************************************************************************/
typedef struct {
      unsigned int   flags;   /* Format flags */
      int      fwidth;        /* Field width */
      int      precision;     /* Field precision */
      char     conv;          /* Conversion specifier */
} _PFIELD;
 
typedef struct {
      unsigned int   flags;   /* Format flags */
      int      fwidth;        /* Field width */
      int      precision;     /* Field precision */
      char     scanset[96];  /* Scanset used for '[' conversion */
      char     conv;          /* Conversion specifier */
} _SFIELD;
 
/****************/
/* PRINTF FLAGS */
/****************/

#define _PFMINUS  0x01
#define _PFPLUS   0x02
#define _PFSPACE  0x04
#define _PFPOUND  0x08
#define _PFZERO   0x10
 
/***************/
/* SCANF FLAGS */
/***************/

#define _SFSTAR   0x01
#define _SFCIRC   0x02

/****************/
/* MUTUAL FLAGS */
/****************/

#define _MFH      0x20
#define _MFL      0x40
#define _MFLD     0x80

#endif

intrin.h/       925421708   0     0     0       1408      `
/*****************************************************************************/
/* intrin.h V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1997-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _INTRIN_H
#define _INTRIN_H 1

/*---------------------------------------------------------------------------*/
/* This file defines the intrinsic functions available on the C3x/C4x tools  */
/*---------------------------------------------------------------------------*/
extern int    abs(int);           /* Integer Absolute                        */
extern long   labs(long);         /* Long Integer Absolute                   */
extern double fabs(double);       /* Floating Point Absolute                 */

extern int    fast_ftoi(float);   /* Fast Float-to-Int Conversion            */
extern int    ansi_ftoi(float);   /* ANSI Float-to-Int Conversion            */

#if defined(_C3x)
extern int    fast_imult(int,int); /* Fast 24-bit multiplication via MPYI     */
#endif

#if defined(_C4x)
extern double toieee(double);     /* Float to IEEE conversion                */
extern double frieee(double);     /* IEEE to float conversion                */
extern int    fast_invf(float);   /* Fast 16-bit reciprocal via RCPF         */
#endif

#endif
limits.h/       925421708   0     0     0       896       `
/*****************************************************************************/
/* limits.h V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _LIMITS
#define _LIMITS

#define CHAR_BIT    32
#define SCHAR_MAX   2147483647
#define SCHAR_MIN   (-SCHAR_MAX-1)
#define CHAR_MAX    2147483647
#define CHAR_MIN    (-CHAR_MAX-1)
#define UCHAR_MAX   4294967295u
 
#define SHRT_MAX    2147483647
#define SHRT_MIN    (-SHRT_MAX-1)
#define USHRT_MAX   4294967295u

#define INT_MAX     2147483647
#define INT_MIN     (-INT_MAX-1)
#define UINT_MAX    4294967295u

#define LONG_MAX    2147483647L
#define LONG_MIN    (-LONG_MAX-1)
#define ULONG_MAX   4294967295uL

#define  MB_LEN_MAX (1)

#endif
math.h/         925421708   0     0     0       2638      `
/*****************************************************************************/
/* math.h V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _MATH
#define _MATH

#if defined(_INLINE)
# define __INLINE static inline
#else
# define __INLINE
#endif

#define HUGE_VAL  3.4028235e38       /* maximum number         */

/***************************************************************/
/* FUNCTION DECLARATIONS.                                      */
/***************************************************************/
         double asin(double _x);
         double acos(double _x);
         double atan(double _x);
         double atan2(double _y, double _x);
__INLINE double ceil(double _x);
         double cos(double _x);
         double cosh(double _x);
         double exp(double _x);
         double fabs(double _x);
__INLINE double floor(double _x);
__INLINE double fmod(double _x, double _y);
         double frexp(double _x, int *_exp);
         double ldexp(double _x, int _exp);
         double log(double _x);
         double log10(double _x);
         double modf(double _x, double *_iptr);
         double pow(double _x, double _y);
         double sin(double _x);
         double sinh(double _x);
         double sqrt(double _x);
         double tan(double _x);
         double tanh(double _x);

#if defined(_INLINE)
/****************************************************************************/
/*  ceil()       				                            */
/****************************************************************************/
static inline double ceil(double x)
{
     double y; 
     return (modf(x, &y) > 0 ? y + 1.0 : y);
}

/****************************************************************************/
/*  floor()      				                            */
/****************************************************************************/
static inline double floor(double x)
{
     double y; 
     return (modf(x, &y) < 0 ? y - 1.0 : y);
}

/****************************************************************************/
/*  fmod()       				                            */
/****************************************************************************/
static inline double fmod(double x, double y)
{
   double d = fabs(x); 

   if (d - fabs(y) == d) return (0.0);
   modf(x/y, &d);
   return (x - d * y);
}
#endif /* _INLINE */
#undef __INLINE

#endif /* _MATH   */
setjmp.h/       925421710   0     0     0       476       `
/*****************************************************************************/
/* setjmp.h V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Inc.                            */
/*****************************************************************************/
#ifndef _SETJMP
#define _SETJMP

typedef long jmp_buf[12];

#define setjmp(_x) _setjmp(_x)
void longjmp(jmp_buf _env, int _returnval); 

#endif
stdarg.h/       925421710   0     0     0       621       `
/*****************************************************************************/
/* stdarg.h V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _STDARG
#define _STDARG

typedef char *va_list;

#define va_start(_ap, _parmN) (_ap = (char *)&_parmN)
#define va_end(_ap)
#define va_arg(_ap, _type)    ((_ap -= (sizeof(_type) > sizeof(int)) ? \
				        sizeof(_type) : sizeof(int)),  \
				        (*(_type *)(_ap)))
#endif

stddef.h/       925421710   0     0     0       643       `
/*****************************************************************************/
/* stddef.h V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _STDDEF 
#define _STDDEF 

typedef int ptrdiff_t;

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

#ifndef _WCHAR_T
#define _WCHAR_T
typedef char wchar_t;
#endif

#define offsetof(_type, _ident) ((size_t)(&((_type *)0)->_ident))

#ifndef NULL
#define NULL 0
#endif

#endif

stdio.h/        925421710   0     0     0       10264     `
/*****************************************************************************/
/* STDIO.H V5.11                                                            */
/* Copyright (c) 1993-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _STDIO 
#define _STDIO

/****************************************************************************/
/* TYPES THAT ANSI REQUIRES TO BE DEFINED                                   */
/****************************************************************************/
#ifndef _SIZE_T                                                    
#define _SIZE_T                                                    
typedef unsigned size_t;                                           
#endif

typedef struct {
         int fd;                    /* File descriptor */
         unsigned char* buf;        /* Pointer to start of buffer */
         unsigned char* pos;        /* Position in buffer */
         unsigned char* bufend;     /* Pointer to end of buffer */
         unsigned char* buff_stop;  /* Pointer to last read char in buffer */
         unsigned int   flags;      /* File status flags (see below) */
         int index;                 /* Location in ftable */
} FILE;

#ifndef _FPOS_T
#define _FPOS_T
typedef long fpos_t;
#endif

/****************************************************************************/
/* MACROS THAT DEFINE AND USE FILE STATUS FLAGS                             */
/****************************************************************************/
#define _IOFBF       0x0001
#define _IOLBF       0x0002
#define _IONBF       0x0004
#define _BUFFALOC    0x0008
#define _MODER       0x0010
#define _MODEW       0x0020
#define _MODERW      0x0040
#define _MODEA       0x0080
#define _MODEBIN     0x0100
#define _STATEOF     0x0200
#define _STATERR     0x0400
#define _UNGETC      0x0800
#define _TMPFILE     0x1000

#define _SET(_fp, _b)      (((_fp)->flags) |= (_b))
#define _UNSET(_fp, _b)    (((_fp)->flags) &= ~(_b))
#define _STCHK(_fp, _b)    (((_fp)->flags) & (_b))
#define _BUFFMODE(_fp)     (((_fp)->flags) & (_IOFBF | _IOLBF | _IONBF))
#define _ACCMODE(_fp)      (((_fp)->flags) & (_MODER | _MODEW))

/****************************************************************************/
/* MACROS THAT ANSI REQUIRES TO BE DEFINED                                  */
/****************************************************************************/
#define BUFSIZ          256 
#define FOPEN_MAX       12
#define FILENAME_MAX    256  
#define TMP_MAX         65535

#define SEEK_SET  (0x0000)
#define SEEK_CUR  (0x0001)
#define SEEK_END  (0x0002)

#ifndef NULL
#define NULL (void *) 0
#endif

#ifndef EOF
#define EOF    (-1)
#endif

#define stdin     (&_ftable[0])      
#define stdout    (&_ftable[1])
#define stderr    (&_ftable[2])

#define L_tmpnam  (sizeof(P_tmpdir) + 15)

/******** END OF ANSI MACROS ************************************************/

#define P_tmpdir        ""                   /* Path for temp files         */

/****************************************************************************/
/* DEVICE AND STREAM RELATED DATA STRUCTURES AND MACROS                     */
/****************************************************************************/
/*- If you modify these values, be sure to also modify the ftable[] to     -*/
/*- correctly initialize the entries.  This is necessary since we do no    -*/
/*- clear bss by default!                                                  -*/
/****************************************************************************/
#define _NFILE          20                   /* Max number of files open    */
#define _NSTREAM        20                   /* Size of stream table        */
#define _NDEVICE        3                    /* Size of device table        */

#define _SSA      (0x0000)             /* Single Stream allowed       */
#define _BUSY     (0x0001)             /* Device busy                 */
#define _MSA      (0x0002)             /* Multiple Streams Allowed    */

#define stdevice        (&_device[0])        /* Default device (host)       */

typedef struct {                             
   char  name[9];
   unsigned short flags;
   int (*OPEN) ();
   int (*CLOSE) ();
   int (*READ) ();
   int (*WRITE) ();
   long (*LSEEK) ();
   int (*UNLINK) ();
   int (*RENAME) ();
} _DEVICE;

extern FILE _ftable[_NFILE];
extern char _tmpnams[_NFILE][L_tmpnam];

/****************************************************************************/
/*   FUNCTION DEFINITIONS  - ANSI                                           */
/****************************************************************************/
/****************************************************************************/
/* OPERATIONS ON FILES                                                      */
/****************************************************************************/
       int     remove(const char *_file);
extern int     rename(const char *_old, const char *_new);
extern FILE   *tmpfile(void);
extern char   *tmpnam(char *_s);

/****************************************************************************/
/* FILE ACCESS FUNCTIONS                                                    */
/****************************************************************************/
extern int    fclose(FILE *_fp); 
extern FILE   *fopen(const char *_fname, const char *_mode);
extern FILE   *freopen(const char *_fname, const char *_mode,
               register FILE *_fp);
extern void    setbuf(register FILE *_fp, char *_buf);
extern int     setvbuf(register FILE *_fp, register char *_buf, 
                       register int _type,  register size_t _size); 
extern int     fflush(register FILE *_fp); 

/****************************************************************************/
/* FORMATTED INPUT/OUTPUT FUNCTIONS                                         */
/****************************************************************************/
extern int     fprintf(FILE *_fp, const char *_format, ...);
extern int     fscanf(FILE *_fp, const char *_fmt, ...);
extern int     printf(const char *_format, ...);
extern int     scanf(const char *_fmt, ...);
extern int     sprintf(char *_string, const char *_format, ...);
extern int     sscanf(const char *_str, const char *_fmt, ...);
extern int     vfprintf(FILE *_fp, const char *_format, char *_ap);
extern int     vprintf(const char *_format, char *_ap);
extern int     vsprintf(char *_string, const char *_format, char *_ap);

/****************************************************************************/
/* CHARACTER INPUT/OUTPUT FUNCTIONS                                         */
/****************************************************************************/
extern int     fgetc(register FILE *_fp);
extern char   *fgets(char *_ptr, register int _size, register FILE *_fp);
extern int     fputc(int _c, register FILE *_fp);
extern int     fputs(const char *_ptr, register FILE *_fp);
extern int     getc(FILE *_p);
       int     getchar(void);
extern char   *gets(char *_ptr); 
extern int     putc(int _x, FILE *_fp);
       int     putchar(int _x);
extern int     puts(const char *_ptr); 
extern int     ungetc(int _c, register FILE *_fp);

/****************************************************************************/
/* DIRECT INPUT/OUTPUT FUNCTIONS                                            */
/****************************************************************************/
extern size_t    fread(void *_ptr, size_t _size, size_t _count, FILE *_fp);
extern size_t    fwrite(const void *_ptr, size_t _size, size_t _count,
                        register FILE *_fp); 

/****************************************************************************/
/* FILE POSITIONING FUNCTIONS                                               */
/****************************************************************************/
extern int       fgetpos(FILE *_fp, fpos_t *_pos);
extern int       fseek(register FILE *_fp, long _offset, int _ptrname);
extern int       fsetpos(FILE *_fp, const fpos_t *_pos);
extern long  ftell(FILE *_fp);
extern void  rewind(register FILE *_fp); 

/****************************************************************************/
/* ERROR-HANDLING FUNCTIONS                                                 */
/****************************************************************************/
       void      clearerr(FILE *_fp);
extern int       feof(FILE *_fp);
       int       ferror(FILE *_fp);
extern void      perror(const char *_s);
                

#define _getchar()      getc(stdin)
#define _putchar(_x)    putc((_x), stdout)
#define _clearerr(_fp)   ((void) ((_fp)->flags &= ~(_STATERR | _STATEOF)))

#define _ferror(_x)     ((_x)->flags & _STATERR)

#define _remove(_fl)    (unlink((_fl)))

/******* END OF ANSI FUNCTIONS  *********************************************/


/****************************************************************************/
/* GETENV IS SUPPOSED TO BE IN STDLIB.H IN THE RTS.LIB, BUT BECAUSE STDIO.H */
/* IS THE ONLY HEADER FILE THAT USES ROUTINES TO INTERFACE WITH THE HOST    */
/* OPERATING SYSTEM, GETENV WAS PLACED HERE.                                */
/****************************************************************************/
char            *getenv(const char *_string);

/****************************************************************************/
/* LOW LEVEL FUNCTION PROTOTYPES                                            */
/****************************************************************************/
extern int       add_device(char           *name,
                            unsigned        flags,
                  int            (*dopen)(),
                  int            (*dclose)(),
                  int            (*dread)(),
                  int            (*dwrite)(),
                  long           (*dlseek)(),
                  int            (*dunlink)(),
                  int            (*drename)());
#endif
stdlib.h/       925421710   0     0     0       2416      `
/*****************************************************************************/
/* stdlib.h V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _STDLIB
#define _STDLIB

#ifndef NULL
#define NULL         0
#endif

#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0
#define RAND_MAX     2147483646   /* (2^31) - 2 */
#define MB_CUR_MAX   1

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

#ifndef _WCHAR_T
#define _WCHAR_T
typedef char wchar_t;
#endif

typedef struct _div_t { int quot, rem; } div_t, ldiv_t;

double        atof(const char *_st);
int           atoi(const char *_st);
long          atol(const char *_st);

double        strtod(const char *_st,  char **_endptr);
long          strtol(const char *_st,  char **_endptr, int _base);
unsigned long strtoul(const char *_st, char **_endptr, int _base);

int           rand(void);
void          srand(unsigned _seed);

void         *calloc(size_t _num, size_t _size);
void          free(void *_ptr);
void         *malloc(size_t _size);
void         *bmalloc(size_t _size);
void          minit(void);
void         *realloc(void *_ptr, size_t _size);

void         *calloc8(size_t _num, size_t _size);
void          free8(void *_ptr);
void         *malloc8(size_t _size);
void         *bmalloc8(size_t _size);
void          minit8(void);
void         *realloc8(void *_ptr, size_t _size);

void         *calloc16(size_t _num, size_t _size);
void          free16(void *_ptr);
void         *malloc16(size_t _size);
void         *bmalloc16(size_t _size);
void          minit16(void);
void         *realloc16(void *_ptr, size_t _size);

void          abort(void);
void          exit(int _status);
int           atexit(void (*_func)(void));

void         *bsearch(const void *_key, const void *_base, size_t _nmemb, 
		      size_t _size, int (*_compar)(const void *, const void *));
void          qsort(void *_base, size_t _nmemb, 
		      size_t _size, int (*_compar)(const void *, const void *));

int           abs(int _i);
long          labs(long _i);
div_t         div(int _numer, int _denom);
div_t         ldiv(long _numer, long _denom);

char         *getenv(const char *_string);
#endif
string.h/       925421710   0     0     0       7028      `
/*****************************************************************************/
/* string.h V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _STRING
#define _STRING

#ifndef NULL
#define NULL 0
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

#if defined(_INLINE)
# define __INLINE static inline
#else
# define __INLINE
#endif

/****************************************************************************/
/* FUNCTION DEFINITIONS                                                     */
/****************************************************************************/
__INLINE void   *memchr(const void *_mem, int _ch, size_t _length);
__INLINE int     memcmp(const void *_mem1, const void *_mem2, size_t _length);
__INLINE void   *memcpy(void *_s1, const void *_s2, size_t _n);
         void   *memmove(void *_s1, const void *_s2, size_t _n);
__INLINE void   *memset(void *_s, int _c, size_t _n);

__INLINE char   *strcat(char *_string1, const char *_string2);
__INLINE char   *strchr(const char *_string, int _ch);
__INLINE int     strcmp(const char *_string1, const char *_string2);
__INLINE char   *strcpy(char *_to, const char *_from);
         int     strcoll(const char *_string1, const char *_string2);
         size_t  strcspn(const char *_string, const char *_chs);
         char   *strerror(int _errno);
__INLINE size_t  strlen(const char *_string);
         char   *strncat(char *_to, const char *_from, size_t _n);
         int     strncmp(const char *_string1, const char *_string2, size_t _n);
         char   *strncpy(char *_to, const char *_from, size_t _n);
         char   *strpbrk(const char *_string, const char *_chs);
__INLINE char   *strrchr(const char *_string, int _ch);
         size_t  strspn(const char *_string, const char *_chs);
         char   *strstr(const char *_string1, const char *_string2);
         char   *strtok(char *_str1, const char *_str2);
         size_t  strxfrm(char *_to, const char *_from, size_t _n);

#if  defined(_INLINE)
/****************************************************************************/
/*  memchr()                                                                */
/****************************************************************************/
static inline void *memchr(const void *cs, int c, size_t n)
{
   size_t length;

   if ( (length=n) > 0 )
   {
      const unsigned char *mem = cs;   
      unsigned char       ch   = c;

      do if ( *mem++ == ch ) return (void *)(mem - 1);
      while (--length != 0);
   }
   
   return (void *)NULL;
}

/****************************************************************************/
/*  memcmp()       				                            */
/****************************************************************************/
static inline int memcmp(const void *mem1, const void *mem2, size_t length)
{
   const char *r1 = (char *)mem1 - 1;
   const char *r2 = (char *)mem2 - 1;

   for(;;)
     if      ( --length == -1 ) break;
     else if ( *++r1 != *++r2 ) return *r1 - *r2;

   return 0;
}

/****************************************************************************/
/*  memcpy()         						            */
/****************************************************************************/
static inline void *memcpy(void *s, const void *ct, size_t n)
{
   char   *from, *to;
   size_t length;

   if ( (length=n) > 0 )
   {
      from = (char *)ct;  
      to   = (char *)s;
      do *to++ = *from++; while (--length != 0);
   }

   return (void *)s;
}

/****************************************************************************/
/*  memset()                                                                */
/****************************************************************************/
static inline void *memset(void *s, int c, size_t n)
{
   size_t length;

   if ( (length=n) > 0 )
   {
      char          *mem = s;
      unsigned char ch   = c;

      do *mem++ = ch; while (--length != 0);
   }

   return (void *)s;
}

/****************************************************************************/
/*  strcat()                                                                */
/****************************************************************************/
static inline char *strcat(char *dest, const char *src)
{
   char *r1 = dest - 1;

   while (*++r1);		     /* FIND END OF STRING   */
   while ((*r1++ = *src++) != 0);    /* APPEND SECOND STRING */
   return dest;
}

/****************************************************************************/
/*  strchr()                                                                */
/****************************************************************************/
static inline char *strchr(const char *string, int ch)
{
   char *str = (char *)string - 1;
   int   tch;

   for (;;)
     if      ( (tch = *++str) == ch ) return str;
     else if ( tch == 0 ) return NULL;
}

/****************************************************************************/
/*  strcmp()                                                                */
/****************************************************************************/
static inline int strcmp(const char *string1, const char *string2)
{
   char *r1 = (char *)string1 - 1;
   char *r2 = (char *)string2 - 1;
   char cp;

   while ( (*++r2 == (cp = *++r1)) && cp );

   return *r1 - *r2;
}

/****************************************************************************/
/*  strcpy()                                                                */
/****************************************************************************/
static inline char *strcpy(char *dest, const char *src)
{
   char *result = dest;

   while ((*dest++ = *src++) != 0);
   return result;
}

/****************************************************************************/
/*  strlen()                                                                */
/****************************************************************************/
static inline size_t strlen(const char *string)
{
   const char *r1 = string - 1;
   while (*++r1);
   return r1 - string;
}

/****************************************************************************/
/*  strrchr()                                                               */
/****************************************************************************/
static inline char *strrchr(const char *string, int c)
{
   char tch, ch;
   char *result;

   --string;
   ch     = c;
   result = (char *)0;

   for (;;)
   {
      if ((tch = *++string) == ch) result = (char*)string;
      if (tch == 0) break;
   }

   return result;
}
#endif /* _INLINE */
#undef __INLINE

#endif /* _STRING */
time.h/         925421712   0     0     0       2521      `
/*****************************************************************************/
/* time.h V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _TIME
#define _TIME

#define CLOCKS_PER_SEC 1000

#ifndef NULL
#define NULL           0
#endif

typedef unsigned long clock_t;
typedef unsigned long time_t;

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

/*************************************************************************/
/* STRUCTURE DEFINITION FOR BROKEN-SOWN_TIME                             */
/*************************************************************************/
struct tm {
	    int          tm_sec;    /* seconds after the minute   - [0,59]  */
	    int          tm_min;    /* minutes after the hour     - [0,59]  */
	    int          tm_hour;   /* hours after the midnight   - [0,23]  */
	    int          tm_mday;   /* day of the month           - [1,31]  */
	    int          tm_mon;    /* months since January       - [0,11]  */
	    int          tm_year;   /* years since 1900                     */
	    int          tm_wday;   /* days since Sunday          - [0,6]   */
	    int          tm_yday;   /* days since Jan 1st         - [0,365] */
	    int          tm_isdst;  /* Daylight Savings Time flag           */
	  };

/*************************************************************************/
/* TIME ZONE STRUCTURE DEFINITION                                        */
/*************************************************************************/
struct tmzone
	  {
            short        daylight;  /* True if daylight savings time        */
	    long         timezone;  /* Number of seconds behind GMT         */
	    char         tzname[4]; /* Name of timezone, e.g. CST           */
	    char         dstname[4];/* Name when daylight true, e.g. EDT    */
          };

extern struct tmzone _tz;

clock_t    clock(void);
double     difftime(time_t _time1, time_t _time0);
time_t     mktime(struct tm *_tptr);
time_t     time(time_t *_timer);
char      *asctime(const struct tm *_timeptr);
char      *ctime(const time_t *_timer);
struct tm *gmtime(const time_t *_timer);
struct tm *localtime(const time_t *_timer);
size_t     strftime(char *_out, size_t _maxsize, const char *_format, 
		    const struct tm *_timeptr);

#endif


trgcio.h/       925421712   0     0     0       2961      `
/*****************************************************************************/
/*  TRGCIO.H V5.11                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*  This file contains OTIS-driven CIO constant definitions                  */
/*****************************************************************************/

/*---------------------------------------------------------------------------*/
/* constants for the data transfer functions for the predefined driver       */
/*---------------------------------------------------------------------------*/
#define _DTOPEN    (0xF0)
#define _DTCLOSE   (0xF1)
#define _DTREAD    (0xF2)
#define _DTWRITE   (0xF3)
#define _DTLSEEK   (0xF4)
#define _DTUNLINK  (0xF5)
#define _DTGETENV  (0xF6)
#define _DTRENAME  (0xF7)
#define _DTGETTIME (0xF8)
#define _DTGETCLK  (0xF9)
#define _DTSYNC    (0xFF)

#define CIOBUFSIZ BUFSIZ+32


#if defined(_TMS320C30) || defined(_TMS320C40)
/*---------------------------------------------------------------------------*/
/* THESE MACROS PACK AND UNPACK SHORTS AND LONGS INTO CHARACTER ARRAYS       */
/*                                                                           */
/* THIS IS DONE BYTE REVERSED TO MAKE THE PC'S JOB EASIER AND SINCE THE      */
/*     DEVICE COULD BE BIG OR LITTLE ENDIAN                                  */
/*---------------------------------------------------------------------------*/
#define LOADSHORT(x,y,z)  { x[(z)]   = (unsigned short) (y); \
                            x[(z)+1] = (unsigned short) (y) >> 8;  }

#define UNLOADSHORT(x,z) (((long)((x[(z)] << 16) + (x[(z)+1] << 24))) >> 16)

#define LOAD32(x,y,z) { x[(z)]   = (unsigned long) (y); \
                          x[(z)+1] = (unsigned long) (y) >> 8; \
                          x[(z)+2] = (unsigned long) (y) >> 16;  \
                          x[(z)+3] = (unsigned long) (y) >> 24;   }

#define UNLOAD32(x,z) ((long) (x[(z)]          + (x[(z)+1] << 8) + \
                                (x[(z)+2] << 16) + (x[(z)+3] << 24)))

/*---------------------------------------------------------------------------*/
/* THESE MACROS CAN BE USED TO PACK AND UNPACK CHARACTER STREAMS INTO TARGET */
/* WORDS FOR MORE EFFICIENT TRANSFER.                                        */
/*---------------------------------------------------------------------------*/
#define PACKCHAR(val, base, byte) ( ((byte)%4 == 0) ?  \
	 (*((base) + ((byte)/4))  = ((val) & 0xFF)) : \
	 (*((base) + ((byte)/4)) |= ((val) & 0xFF) << (((byte)%4) * 8)) )

#define UNPACKCHAR(base, byte) \
         ( (*((base) + ((byte)/4)) >> (((byte)%4) * 8)) & 0xFF )

#define BSSCIOBUF 0
#endif  /* TMS32030 */






values.h/       925421712   0     0     0       2959      `
/*****************************************************************************/
/* VALUES.H V5.11							     */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/

#define BITS	  23               /* There are 23 bits in the mantissa     */
#define MAXX	  88.72283906      /* ln(HUGE_VAL)                          */
#define MAXH	  89.41598624	   /* ln(HUGE_VAL) + ln(2)                  */
#define TWO23	  8388608	   /* 2 ^ BITS                              */
#define XBIG	  8.664339757	   /* (BITS/2 + 1) * ln(2)                  */

/****************************************************************************/
/*  The following macros define constants used throughout the functions.    */
/****************************************************************************/

/* macros used in asin and acos */

#define SQRTWO	  1.4142135623730950
#define ASP1	  0.933935835
#define ASP2	 -0.504400557
#define ASQ0	  0.560363004e1
#define ASQ1	 -0.554846723e1

/* macros used in atan and atan2 */

#define TWO_SQRT3 0.26794919243112270647
#define SQRTTHREE 1.73205080756887729353
#define PI	  3.14159265358979323846
#define ATP0	 -0.4708325141
#define ATP1	 -0.5090958253e-1
#define ATQ0	  0.1412500740e1

/* macros used in sin and cos */

#define INVSPI	  0.31830988618379067154
#define HALFPI	  1.57079632679489661923
#define C1	  3.140625
#define C2	  9.67653589793e-4
#define R1	 -0.1666665668e+0
#define R2	  0.8333025139e-2
#define R3	 -0.1980741872e-3
#define R4	  0.2601903036e-5

/* macros used in exp, cosh, and sinh */

#define LOGe2	  0.6931471805599453094172321
#define LOG102    0.301029995663981198017
#define INVLOGe2  1.4426950408889634074
#define EXP0	  0.24999999950
#define EXP1	  0.41602886268e-2
#define EXQ0	  0.5
#define EXQ1	  0.49987178778e-1
#define SHP0	 -0.713793159e1
#define SHP1	 -0.190333399
#define SHQ0	 -0.428277109e2

/* macros used in log10 and log */

#define SQRTHALF  0.70710678118654752440
#define LOG10e	  0.4342944819032518
#define C3	  0.693359375
#define C4	 -2.121944400546905827679e-4
#define A0	 -0.5527074855
#define B0	 -0.6632718214e1

/* macros used in pow */

#define L1	  2.885390072738
#define L3	  0.961800762286
#define L5	  0.576584342056
#define L7	  0.434259751292
#define T6	  0.0002082045327
#define T5	  0.001266912225
#define T4	  0.009656843287
#define T3	  0.05549288453
#define T2	  0.2402279975
#define T1	  0.6931471019

/* macros used in tan */

#define TWOINVPI  0.63661977236758134308
#define C5	  1.5703125
#define C6	  4.83826794897e-4
#define TAP1	 -0.958017723e-1
#define TAQ1	 -0.429135777e+0
#define TAQ2	  0.971685835e-2

/* macros used in tanh */

#define LOGe3by2  0.54930614433405484570
#define THP0	 -0.8237728127
#define THP1	 -0.3831010665e-2
#define THQ0	  0.2471319654e1

arith410.asm/   925421712   0     0     0       19656     `
	.length  78
	.width   132
*********************************************************************
* ARITH410 V5.11 - Compatible Arithmetic Functions for TMS3203x/4x
* Copyright (c) 1992-1999 Texas Instruments Incorporated
*
*   These functions are provided for compatibility with version 4.10
*   and earlier of the TMS320C30 C Compiler.  Newer versions of the 
*   compiler use different register saving conventions than older 
*   versions.  These functions adhere to the old conventions, so 
*   that if code compiled with an earlier compiler is linked in, 
*   the correct registers will be preserved.
*
*   OLD functions (this file) can use registers R0-R3, RC, RS, RE
*   without preserving them.
*
*   Note that functions using the new conventions have different
*   names.  This allows transparent compatibility with whichever 
*   compiler is being used.
*
*   The following functions are defined in this module:
*      DIV_F - Floating point divide
*      DIV_I - Signed integer divide
*      DIV_U - Unsigned integer divide
*      MOD_I - Signed integer modulo
*      MOD_U - Unsigned integer modulo
*      MPY_I - Integer multiply
*      MPY_X - Integer multiply for TMX C30
*
*********************************************************************
        .global DIV_F, DIV_I, DIV_U, MOD_I, MOD_U, MPY_I, MPY_X

        .page
**********************************************************************
*  DIV_F - Floating point division
*
*    Inputs:           u in R0, v in R1
*    Outputs:          u/v in R0
*    Status:           Set from result in R0
*    Registers used:   R0-R3
*    Cycles: 40
**********************************************************************
DIV_F:  
	PUSHF   R1          ; Save off signed value of v
        ABSF    R1          ; The algorithm uses v = |v|.
;
;   Extract the exponent of v.
;
        PUSHF   R1
        POP     R2
        ASH     -24,R2      ; The 8 LSBs of R2 contain the exponent of v.
;
; A few comments on boundary conditions.  If e = -128, then v = 0.  The
; following x[0] calculation yields R2 = --128 - 1 = 127 and the algorithm will
; overflow and saturate since x[0] is large.  This seems reasonable.  If e =
; 127, the R2 = -127 - 1 = -128.  Thus x[0] = 0 and this will cause the
; algorithm to yield zero.  Since the mantissa of v is always between 1 and 2,
; this is also reasonable.  As a result, boundary conditions are handled
; automatically in a reasonable fashion.
;
;   x[0] formation given the exponent of v.
;
        NEGI    R2
        SUBI    1,R2            ; Now we have -e-1, the exponent of x[0].
        ASH     24,R2
        PUSH    R2
        POPF    R2              ; Now R2 = x[0] = 1.0 * 2**(-e-1).
;
; Now the iterations begin.
;
        MPYF    R2,R1,R3        ; R3 = v * x[0]
        SUBRF   2.0,R3          ; R3 = 2.0 - v * x[0]
        MPYF    R3,R2           ; R2 = x[1] = x[0] * (2.0 - v * x[0])
 
        MPYF    R2,R1,R3        ; R3 = v * x[1]
        SUBRF   2.0,R3          ; R3 = 2.0 - v * x[1]
        MPYF    R3,R2           ; R2 = x[2] = x[1] * (2.0 - v * x[1])
 
        MPYF    R2,R1,R3        ; R3 = v * x[2]
        SUBRF   2.0,R3          ; R3 = 2.0 - v * x[2]
        MPYF    R3,R2           ; R2 = x[3] = x[2] * (2.0 - v * x[2])
 
        MPYF    R2,R1,R3        ; R3 = v * x[3]
        SUBRF   2.0,R3          ; R3 = 2.0 - v * x[3]
        MPYF    R3,R2           ; R2 = x[4] = x[3] * (2.0 - v * x[3])
 
        RND     R2              ; This minimizes error in the LSBs.
;
; For the last iteration we use the formulation:
; x[5] = (x[4] * (1.0 - (v * x[4]))) + x[4]
;
        MPYF    R2,R1,R3        ; R3 = v * x[4] = 1.0..01.. => 1
        SUBRF   1.0,R3          ; R3 = 1.0 - v * x[4] = 0.0..01... => 0
        MPYF    R2,R3           ; R3 = x[4] * (1.0 - v * x[4])
        ADDF    R3,R2           ; R3 = x[5] = (x[4]*(1.0-(v*x[4])))+x[4]
 
        RND     R2,R1           ; Round since this is follow by a MPYF.
;
; Now the case of v < 0 is handled.
;
        NEGF    R1,R3           ; R3 = -(1/v)
        POPF    R2              ; See if v was negative
        LDFN    R3,R1           ; If v < 0, then R1 = -R1
;
; R1 contains 1/v.  Multiply by u to get result.
;
	MPYF    R1,R0
        RETS

        .page
********************************************************
* DIVI  - Integer divide routine (signed)
********************************************************
*    Inputs:          Signed integer dividend in R0, 
*                     Signed integer divisor in R1.
*    Output:          R0 / R1 into R0.
*    Status:          Set from result in R0.
*    Registers used:  R0-R3, RC, RS, RE
*    Cycles:          31-62 (depends on amount of normalization)
*********************************************************
	.asg    R2, V          ;divisor
	.asg    R1, TEMP       ;float value of operands
	.asg    R1, COUNT      ;repeat/shift count 
	.asg    R3, SIGN       ;sign of quotient
	.asg    RC, EXP        ;divisor exponent 

DIV_I:
; 
; Determine sign of result.  Get absolute value of operands.
; 
	XOR     R0,R1,SIGN     ;get the sign
	ABSI    R0             ;make dividend positive
	BVD     divi_32        ;if still negative, escape
	ABSI    R1             ;make divisor positive
	LDI     R1,V           ;save in V
        CMPI    R0,V           ;divisor > dividend ? 
	BHID    divi_zero      ;  if so, return 0
; 
; Normalize operands.  Use difference in exponents as shift count
; for divisor, and as repeat count for SUBC.
;
        FLOAT   R1,TEMP        ;normalize divisor
        PUSHF   TEMP           ;push as float 
	POP     EXP            ;pop as int

        FLOAT   R0,TEMP        ;normalize dividend
        PUSHF   TEMP           ;push as float
        POP     COUNT          ;pop as int 

	LSH     -24,EXP        ;divisor exponent
	LSH     -24,COUNT      ;dividend exponent
	SUBI    EXP,COUNT      ;get difference in exponents
	LSH     COUNT,V        ;align divisor with dividend
; 
; Do COUNT+1 subtract & shifts.
;
	RPTS    COUNT 
	SUBC    V,R0
;
;  Mask off the lower COUNT+1 bits of R0
;
	SUBRI   31,COUNT       ;shift count is (32 - (COUNT+1))
	LSH     COUNT,R0       ;shift left
	NEGI    COUNT
	LSH     COUNT,R0       ;shift right to get result
;
;  Check sign and negate result if necessary.
;
divi_return:
	POP     RC             ;return address
	NEGI    R0,TEMP        ;negate result
	BD      RC             ;delayed branch to return
        CMPI    0,SIGN         ;check sign 
	LDIN    TEMP,R0        ;if set, use negative result
        CMPI    0,R0           ;set status from result
***     B       RC             ;BRANCH OCCURS (RETURN)
;
; The following code handles cases of a full 32-bit dividend.  This occurs
; when R0 = abs(R0) = 080000000h.  Handle this by calling the unsigned divide
; function, then negating the result if necessary.
;
divi_32:
        PUSH    SIGN           ;remember sign
	CALL    DIV_U          ;do divide
	POP     SIGN           ;restore sign
	B       divi_return    ;return
;
;  Return zero.
;
divi_zero:
	LDI     0,R0
	RETS

        .page
********************************************************
* DIVU  - Integer divide routine (unsigned)
********************************************************
*    Inputs:          Unsigned dividend in R0, 
*                     unsigned divisor in R1.
*    Output:          R0 / R1 into R0.
*    Status:          Set from result in R0.
*    Registers used:  R0-R3, RC, RS, RE
*********************************************************
	.asg    R2,V           ;divisor
	.asg    R1,TEMP        ;float value of operands
	.asg    R1,MSBQ        ;MSQ of quotient
	.asg    R3,QMASK       ;mask for quotient
	.asg    R3,COUNT       ;repeat/shift count
	.asg    RC,EXP         ;divisor exponent

DIV_U:
        CMPI    R0,R1          ;divisor > dividend ? 
	BHI     divu_zero      ;   if so, return 0
	LDI     R1,V           ;move divisor to V  
;
; If top bit of dividend is set, handle specially.
;
        CMPI    0,R0 	       ;check top bit
	BLTD    divu_32        ;get divisor exponent, then jump.
;
; Get divisor exponent by converting to float.
;
	FLOAT   V,TEMP         ;normalize divisor
	PUSHF   TEMP           ;push as float
	POP     EXP            ;pop as int to get exponent
;
; 31 or less bits in dividend.  Get dividend exponent.
;
        FLOAT   R0,TEMP        ;normalize dividend
	PUSHF   TEMP           ;push as float
	POP     COUNT          ;pop as int to get exponent
;
; Use difference in exponents as shift count to line up MSBs.
;
	LSH     -24,COUNT      ;divisor exponent
	LSH     -24,EXP        ;dividend exponent
	SUBI    EXP,COUNT      ;difference
        LSH     COUNT,V        ;shift divisor up
; 
; Do COUNT+1 subtract & shifts.
;
	RPTS    COUNT
	SUBC    V,R0  
;
;  Mask off the lower COUNT+1 bits of U and return.
;
	POP     RC             ;return address
	SUBRI   31,COUNT       ;shift count is (32 - (COUNT+1))
	BD      RC             ;delayed branch to return
	LSH     COUNT,R0       ;shift left
	NEGI    COUNT
	LSH     COUNT,R0       ;shift right to get result
***     B       RC             ;BRANCH OCCURS (RETURN)
        .page
;
; The following code handles cases of a full 32-bit dividend.  Before
; SUBC can be used, the top bit must be cleared (otherwise SUBC can
; possibly shift a significant 1 out the top of the dividend).  This
; is accomplished by first doing a normal subtraction, then proceeding
; with SUBCs. 
;
divu_32:
;
; If the top bit of the divisor is set too, the quotient is 1.  
; Otherwise, shift the divisor up to line up the MSBs. 
;
	CMPI    0,V            ;check divisor
	BLTD    divu_one       ;if top bit set, quotient is 1
	LSH     -24,EXP        ;divisor exponent
	SUBRI   31,EXP         ;shift count 
	LSH     EXP,V          ;shift up to line up MSBs
;
; Now MSBs are aligned.  Do first SUBC by hand, and save off the first
; quotient digit.  Then, shift divisor right rather than shifting dividend
; left.  This leaves a 0 in the top bit of the dividend.
;
	LDI     1,QMASK        ;initialize MSB of quotient
	LSH     EXP,QMASK      ;create a mask for the MSBs
	SUBI    1,QMASK        ;mask is (2 << COUNT) - 1

	SUBI    V,R0,TEMP      ;subtract 
	LDIHS   TEMP,R0        ;if positive, replace dividend
	LDIHS   1,MSBQ         ;         and set quotient to 1
	LDILO   0,MSBQ         ;if negative, set quotient to 0
	LSH     EXP,MSBQ       ;shift MSB into position

	LSH     -1,V           ;shift divisor down
	SUBI    1,EXP          ;first iteration is done
; 
; Do EXP subtract & shifts.
;
	RPTS    EXP   
	SUBC    V,R0
;
; MSB of the quotient is in MSBQ.  LSBs are in the lower COUNT bits of
; R0.
;
	POP     RC             ;return address
	BD      RC             ;delayed branch to return
        AND     QMASK,R0       ;mask off LSBs
	OR      MSBQ,R0        ;MSB of quotient
        NOP
***     B       RC             ;BRANCH OCCURS (RETURN)
;
;  Return one.
;
divu_one:
	LDI     1,R0
	RETS
;
;  Return zero.
;
divu_zero:
	LDI     0,R0
	RETS

        .page
********************************************************
* MODI  - Integer modulo (signed)
********************************************************
*    Inputs:          Signed integer dividend in R0, 
*                     Signed integer divisor in R1.
*    Output:          R0 % R1 into R0.
*    Status:          Set from result in R0.
*    Registers used:  R0-R3, IR0, IR1
*********************************************************
	.asg    R2,V           ;divisor
	.asg    R1,TEMP        ;float value of operands
	.asg    R1,COUNT       ;repeat/shift count 
	.asg    R3,SIGN        ;sign of result
	.asg    RC,EXP         ;divisor exponent 
MOD_I:
; 
; Determine sign of result.  Get absolute value of operands.
; 
	LDI     R0,SIGN        ;sign of result same as dividend
	ABSI    R0             ;make dividend positive
	BVD     modi_32        ;if still negative, escape
	ABSI    R1             ;make divisor positive
	LDI     R1,V           ;save in V       
        CMPI    R0,V           ;divisor > dividend ? 
	BHID    modi_return    ;  if so, return dividend
; 
; Normalize operands.  Use difference in exponents as shift count
; for divisor, and as repeat count for SUBC.
;
        FLOAT   R1,TEMP        ;normalize divisor
        PUSHF   TEMP           ;push as float 
	POP     EXP            ;pop as int

        FLOAT   R0,TEMP        ;normalize dividend
        PUSHF   TEMP           ;push as float
        POP     COUNT          ;pop as int 

	LSH     -24,EXP        ;get divisor exponent
	LSH     -24,COUNT      ;get dividend exponent
	SUBI    EXP,COUNT      ;get difference in exponents
	LSH     COUNT,V        ;align divisor with dividend
; 
; Do COUNT+1 subtract & shifts.
;
	RPTS    COUNT
	SUBC    V,R0
;
;  Remainder is in upper bits of R0
;
	ADDI    1,COUNT        ;shift count is -(COUNT+1)
	NEGI    COUNT 
	LSH     COUNT,R0       ;shift right
;
;  Check sign and negate result if necessary.
;
modi_return:
        POP     RC             ;return address
        NEGI    R0,TEMP        ;negate result
	BD      RC             ;delayed branch to return
	CMPI    0,SIGN         ;check sign
	LDIN    TEMP,R0        ;if set, use negative result
        CMPI    0,R0           ;set status on result
***     B       RC             ;BRANCH OCCURS (RETURN)
;
; The following code handles cases of a full 32-bit dividend.  This occurs
; when R0 = abs(R0) = 080000000h.  Handle this by calling the unsigned mod
; function, then negating the result if necessary.
;
modi_32:
        PUSH    SIGN           ;remember sign
	CALL    MOD_U          ;do divide
	POP     SIGN           ;restore sign
	B       modi_return    ;return

	.page
********************************************************
* MODU  - Integer modulo (unsigned)
********************************************************
*    Inputs:          Unsigned dividend in R0, 
*                     unsigned divisor in R1.
*    Output:          R0 % R1 into R0.
*    Status:          Set from result in R0.
*    Registers used:  R0-R3, RC, RS, RE
*********************************************************
	.asg    R2,V           ;divisor
	.asg    R1,TEMP        ;float value of operands
	.asg    R3,COUNT       ;repeat/shift count
	.asg    RC,EXP         ;divisor exponent
MOD_U:
        CMPI    R0,R1          ;divisor > dividend ? 
	BHI     modu_zero      ;   if so, return dividend
	LDI     R1,V           ;load divisor
;
; If top bit of dividend is set, handle specially.
;
        CMPI    0,R0 	       ;check top bit
	BLTD    modu_32        ;get divisor exponent, then jump.
;
; Get divisor exponent by converting to float.
;
	FLOAT   V,TEMP         ;normalize divisor
	PUSHF   TEMP           ;push as float
	POP     EXP            ;pop as int to get exponent
;
; 31 or less bits in dividend.  Get dividend exponent.
;
        FLOAT   R0,TEMP        ;normalize dividend
	PUSHF   TEMP           ;push as float
	POP     COUNT          ;pop as int to get exponent
;
; Use difference in exponents as shift count to line up MSBs.
;
	LSH     -24,EXP        ;divisor exponent
	LSH     -24,COUNT      ;dividend exponent
	SUBI    EXP,COUNT      ;difference
        LSH     COUNT,V        ;shift divisor up
; 
; Do COUNT+1 subtract & shifts.
;
	RPTS    COUNT
	SUBC    V,R0  
;
;  Remainder is in upper 31-COUNT bits.
;
	POP     RC             ;return address
	BD      RC             ;delayed branch to return
	ADDI    1,COUNT        ;shift count is COUNT+1
	NEGI    COUNT          ;negate for right shift
	LSH     COUNT,R0       ;shift to get result
***     B       RC             ;BRANCH OCCURS (RETURN)
        .page
;
; The following code handles cases of a full 32-bit dividend.  Before
; SUBC can be used, the top bit must be cleared (otherwise SUBC can
; possibly shift a significant 1 out the top of the dividend).  This
; is accomplished by first doing a normal subtraction, then proceeding
; with SUBCs. 
;
modu_32:
;
; If the top bit of the divisor is set too, the remainder is simply
; the difference between the dividend and divisor.  Otherwise, shift 
; the divisor up to line up the MSBs.
;
	CMPI    0,V            ;check divisor
	BLTD    modu_one       ;if negative, remainder is diff

	LSH     -24,EXP        ;divisor exponent
	SUBRI   31,EXP         ;shift count = 31 - exp
	NEGI    EXP,COUNT      ;used later as shift count
	LSH     EXP,V          ;shift up to line up MSBs
;
; Now MSBs are aligned.  Do first SUBC by hand using a plain subtraction.
; Then, shift divisor right rather than shifting dividend left.  This leaves
; a 0 in the top bit of the dividend.
;
	SUBI    V,R0,TEMP      ;subtract 
	LDIHS   TEMP,R0        ;if positive, replace dividend
	SUBI    1,EXP          ;first iteration is done
	LSH     -1,V           ;shift divisor down
; 
; Do EXP subtract & shifts.
;
	RPTS    EXP  
	SUBC    V,R0   
;
;  Quotient is in EXP+1 LSBs; shift remainder (in MSBs) down.
;
	LSH     COUNT,R0       ;COUNT contains -(EXP+1)
        RETS
;
;  Return (dividend - divisor).
;
modu_one:
	SUBI    R1,R0  
	RETS
;
;  Return dividend.
;
modu_zero:
	CMPI    0,R0           ;set status from result
	RETS

	.page
********************************************************
* MPYI  - 32x32 Integer Multiply
********************************************************
*    Inputs:         x in R0, y in R1.
*    Outputs:        x*y in R0.
*    Status:         Set from result in R0.
*    Registers used: R0-R3
*********************************************************
MPY_I:
        LDI     R0,R2         ;x
        LDI     R1,R3         ;y
        LSH     -16,R0        ;x0
        LSH     -16,R1        ;y0
        AND     0FFFFh,R2     ;x1
        AND     0FFFFh,R3     ;y1
        MPYI    R3,R0         ;y1 * x0
        MPYI    R2,R1         ;x1 * y0
        MPYI    R2,R3         ;x1 * y1
	POP     R2            ;return address
	BD      R2            ;delayed branch to return
        ADDI    R1,R0         ;MSW of product
        LSH     16,R0         ;shift up
        ADDI    R3,R0         ;add in LSW
***     B       R2            ;BRANCH OCCURS (RETURN)

********************************************************
* MPYX  - 32x32 Integer Multiply for TMX C30
********************************************************
*
* MPYX IS A FULLY COMPATIBLE VERSION OF MPYI PROVIDED FOR USE
* WITH EARLY TMX320C30 DEVICES.  THIS VERSION AVOIDS USING
* THE "AND" INSTRUCTION WITH A 16-BIT IMMEDIATE OPERAND.
* TO USE THIS VERSION, COMPILE WITH THE -mx CODEGEN OPTION.
*
*********************************************************
MPY_X:
        LDI     R0,R2         ;x
        LDI     R1,R3         ;y
        LSH     -16,R0        ;x0
        LSH     -16,R1        ;y0

	; here's the difference
        LSH     16,R2
        LSH     -16,R2
        LSH     16,R3
        LSH     -16,R3

        MPYI    R3,R0         ;y1 * x0
        MPYI    R2,R1         ;x1 * y0
        MPYI    R2,R3         ;x1 * y1
	POP     R2            ;return address
	BD      R2            ;delayed branch to return
        ADDI    R1,R0         ;MSW of product
        LSH     16,R0         ;shift up
        ADDI    R3,R0         ;add in LSW
***     B       R2            ;BRANCH OCCURS (RETURN)

        .end

boot.asm/       925421712   0     0     0       2883      `
        .length 85
        .width  132
***************************************************************
* BOOT V5.11 - C startup routine for TMS3203x/4x
* Copyright (c) 1992-1999 Texas Instruments Incorporated
***************************************************************
*
* This is the initial boot routine for TMS320C30/C40 C Programs.
* It must be linked and loaded with all C programs.  The
* entry point for C programs is called "_c_int00", defined
* in this module.
*
* This module performs the following actions:
*    1) Allocate and initialize the system stack
*    2) Perform auto-initialization
*    3) Call the function _main to start the user's program
***************************************************************
FP          .set  AR3             ;frame pointer

            .global cinit, .bss, _cmdargs, _exit, _init_io, _main
            .global _c_int00
	    .global __stack
;
; Allocate space for the system stack.
; Initialize the first words in .text to point to the stack
; and initialization tables.
;
__stack      .usect  ".stack",0
            .text
stack_addr  .word  __stack        ;address of stack
init_addr   .word  cinit          ;address of init tables

***************************************************************
* _C_INT00 - C entry point function
***************************************************************
_c_int00:
;
; Set up the initial stack pointer
;
        LDP     stack_addr        ;get page of stored address
        LDI     @stack_addr,SP    ;load the address into SP
        LDI     SP,FP             ;and into FP too
;
; Do autoinitialization
;
        LDP     init_addr         ;get page of stored address
        LDI     @init_addr,AR0    ;get address of init tables
        CMPI    -1,AR0            ;if RAM model, skip init
        BEQ     done
        LDI     *AR0++,R1         ;get first count
        BZD     done              ;if 0, nothing to do
        LDI     *AR0++,AR1        ;get dest address
        LDI     *AR0++,R0         ;get first word
        SUBI    1,R1              ;count - 1
do_init:
        RPTS    R1                ;block copy
        STI     R0,*AR1++
    ||  LDI     *AR0++,R0
        LDI     R0,R1             ;move next count into R1
        BNZD    do_init           ;if there is more, repeat
        LDI     *AR0++,AR1        ;get next dest address
        LDI     *AR0++,R0         ;get next first word
        SUBI    1,R1              ;count - 1
done:
;
; For the small model, set up the DP to point to the .bss section
;
        LDP     .bss
;
; Call main()
;
***     CALL    _init_io
***     CALL    _cmdargs
        LDI     0,AR2           ;make sure argc=0 with register
        PUSH    AR2             ;and stack parameter passing
        CALL    _main
        CALL    _exit
        RETI
        .end

divf.asm/       925421714   0     0     0       6126      `
	.length  78
	.width   132
*********************************************************************
* DIVF V5.11 - Floating point divide function for TMS3203x/4x
* Copyright (c) 1992-1999 Texas Instruments Incorporated
*********************************************************************
*    Inputs:           u in R0, v in R1
*    Outputs:          u/v in R0
*    Status:           Set from result in R0
*    Registers used:   R0, R1, AR0, AR1, R10 (C40)
*    Operation:        Result = (1/v) * u.            
*********************************************************************

        .if .tms320C30
**********************************************************************
*  DIV_F - Floating point division - C30 version
*
*  Algorithm:
*       Given v = a * 2**e
*       x[0] = 1.0 * 2**(-e-1)
*       for (i = 1; i <= 5; i++)
*         x[i] = x[i-1] * (2.0 - v * x[i-1])
*
*       The single-precision floating-point format is accurate to 6.9 
*       decimal places.  The single-precision format is accurate to 
*       2**-23 = 1.192E-7, so we would like to have that much accuracy 
*       in the final result.
*
*       The algorithm's error at an iteration i (e[i]) is defined as
*          e[i] = 1 - v * x[i]
*       It can also be shown that e[i+1] = e[i] * e[i].
*  Cycles: 40
**********************************************************************
        .global DIV_F30
DIV_F30:  
        POP     AR1         ; Pop return address
	PUSH    R2          ; Save R2: integer part
	PUSHF   R2          ; Save R2: floating point part
	PUSHF   R0          ; Save u (dividend) 
	LDI     R1,AR0      ; Save mantissa of v to remember sign
        ABSF    R1          ; The algorithm uses v = |v|.
;
;   Extract the exponent of v.
;
        PUSHF   R1
        POP     R2
        ASH     -24,R2      ; The 8 LSBs of R2 contain the exponent of v.
;
; A few comments on boundary conditions.  If e = -128, then v = 0.  The
; following x[0] calculation yields R2 = --128 - 1 = 127 and the algorithm will
; overflow and saturate since x[0] is large.  This seems reasonable.  If e =
; 127, the R2 = -127 - 1 = -128.  Thus x[0] = 0 and this will cause the
; algorithm to yield zero.  Since the mantissa of v is always between 1 and 2,
; this is also reasonable.  As a result, boundary conditions are handled
; automatically in a reasonable fashion.
;
;   x[0] formation given the exponent of v.
;
        NEGI    R2
        SUBI    1,R2            ; Now we have -e-1, the exponent of x[0].
        ASH     24,R2
        PUSH    R2
        POPF    R2              ; Now R2 = x[0] = 1.0 * 2**(-e-1).
;
; Now the iterations begin.
;
        MPYF    R2,R1,R0        ; R0 = v * x[0]
        SUBRF   2.0,R0          ; R0 = 2.0 - v * x[0]
        MPYF    R0,R2           ; R2 = x[1] = x[0] * (2.0 - v * x[0])
 
        MPYF    R2,R1,R0        ; R0 = v * x[1]
        SUBRF   2.0,R0          ; R0 = 2.0 - v * x[1]
        MPYF    R0,R2           ; R2 = x[2] = x[1] * (2.0 - v * x[1])
 
        MPYF    R2,R1,R0        ; R0 = v * x[2]
        SUBRF   2.0,R0          ; R0 = 2.0 - v * x[2]
        MPYF    R0,R2           ; R2 = x[3] = x[2] * (2.0 - v * x[2])
 
        MPYF    R2,R1,R0        ; R0 = v * x[3]
        SUBRF   2.0,R0          ; R0 = 2.0 - v * x[3]
        MPYF    R0,R2           ; R2 = x[4] = x[3] * (2.0 - v * x[3])
 
        RND     R2              ; This minimizes error in the LSBs.
;
; For the last iteration we use the formulation:
; x[5] = (x[4] * (1.0 - (v * x[4]))) + x[4]
;
        MPYF    R2,R1,R0        ; R0 = v * x[4] = 1.0..01.. => 1
        SUBRF   1.0,R0          ; R0 = 1.0 - v * x[4] = 0.0..01... => 0
        MPYF    R2,R0           ; R0 = x[4] * (1.0 - v * x[4])
        ADDF    R0,R2,R1        ; R0 = x[5] = (x[4]*(1.0-(v*x[4])))+x[4]
;
; R1 contains 1/v.  Multiply by u to get result.
;
        RND     R1              ; Round since this is follow by a MPYF.
	POPF    R0              ; Pop u
	MPYF    R1,R0           ; Result = u * (1/v)
;
; Branch (delayed) return.  Use delay slots to negate the result if v < 0.
;
	POPF    R2              ; Restore R2: floating point part
	POP     R2              ; Restore R2: integer part

	BD      AR1             ; Delayed branch to return
        NEGF    R0,R1           ; R1 = -(1/|v|)
        CMPI    0,AR0           ; See if v was negative
        LDFN    R1,R0           ; If v < 0, then R1 = -R1
***     B       AR1             ; BRANCH OCCURS (RETURN)

	.endif                  ; .tms320C30
	.page

        .if .tms320C40
**********************************************************************
*  DIV_F - Floating point division - C40 version
*
*  Algorithm:
*       The algorithm used is basically the same as the C30 version,
*       except the the RCPF instruction is used to generate the 
*       initial seed x[0].  The initial seed is accurate to 8 bits,
*       so only two iterations are needed to generate a result 
*       accurate to 32 bits.
*  Cycles: 18
**********************************************************************
        .global DIV_F40
DIV_F40:
	POP     AR1             ; Pop return address
	PUSHF   R0              ; Save u (dividend) 

        RCPF    R1,R10          ; Get x[0] = the estimate of 1/v

        MPYF    R10,R1,R0       ; R0 = v * x[0]
        SUBRF   2.0,R0          ; R0 = 2.0 - v * x[0]
        MPYF    R0,R10          ; R10 = x[1] = x[0] * (2.0 - v * x[0])
 
        MPYF    R10,R1,R0       ; R0 = v * x[1]
        SUBRF   2.0,R0          ; R0 = 2.0 - v * x[1]
        MPYF    R0,R10,R1       ; R1 = x[2] = x[1] * (2.0 - v * x[1])
;
; Branch (delayed) to return address.  Use delay slots to multiply 1/v in
; R1 by u to get result, and to restore R10.
;
	BD      AR1             ; Delayed branch to return
	POPF    R0              ; Pop u
	MPYF    R1,R0           ; Result = u * (1/v)
        RND     R0              ; Round result to 32 bits
***     B       AR1             ; BRANCH OCCURS (RETURN)

	.endif                  ; .tms320C40
        .end


divi.asm/       925421714   0     0     0       3802      `
	.length  78
	.width   132
********************************************************
* DIVI V5.11 - Integer divide routine (signed)
*                                        for TMS3203x/4x
* Copyright (c) 1992-1999 Texas Instruments Incorporated
********************************************************
*    Inputs:          Signed integer dividend in R0, 
*                     Signed integer divisor in R1.
*    Output:          R0 / R1 into R0.
*    Status:          Set from result in R0.
*    Registers used:  R0, R1, AR0, AR1, RC, RS, RE
*
*    Operation:       1. Normalize divisor with dividend
*                     2. Repeat SUBC
*                     3. Quotient is in LSBs of result
*
*    Cycles:          31-62 (depends on amount of normalization)
*********************************************************
	.asg    AR1,V          ;divisor
	.asg    R1, TEMP       ;float value of operands
	.asg    R1, COUNT      ;repeat/shift count 
	.asg    AR0,SIGN       ;sign of quotient
	.asg    RC, EXP        ;divisor exponent 

*********************************************************
* DIV_I - Signed division
*********************************************************
	.if 	.tms320C30
	.globl  DIV_I30, DIV_U30
DIV_I30:
	.else
	.globl  DIV_I40, DIV_U40
DIV_I40:
        .endif
; 
; Determine sign of result.  Get absolute value of operands.
; 
	XOR     R0,R1,SIGN     ;get the sign
	ABSI    R0             ;make dividend positive
	BVD     div_32         ;if still negative, escape
	ABSI    R1             ;make divisor positive
	LDI     R1,V           ;save in V
        CMPI    R0,V           ;divisor > dividend ? 
	BHID    zero           ;  if so, return 0
; 
; Normalize operands.  Use difference in exponents as shift count
; for divisor, and as repeat count for SUBC.
;
        FLOAT   R1,TEMP        ;normalize divisor
        PUSHF   TEMP           ;push as float 
	POP     EXP            ;pop as int
        BZD     zero           ;if (float)divisor was zero, return

        FLOAT   R0,TEMP        ;normalize dividend
        PUSHF   TEMP           ;push as float
        POP     COUNT          ;pop as int 

	LSH     -24,EXP        ;divisor exponent
	LSH     -24,COUNT      ;dividend exponent
	SUBI    EXP,COUNT      ;get difference in exponents
	LSH     COUNT,V        ;align divisor with dividend
; 
; Do COUNT+1 subtract & shifts.
;
	.if	.C30INTERRUPT  ;if -mi flag is set
	LDI     COUNT,RC       ;set counter for rptb instruction
	RPTB    i_sub	       ;repeat subtract
i_sub:	SUBC    V,R0
	.else                  ;else use RPTS instruction
	RPTS    COUNT 
	SUBC    V,R0
	.endif
;
;  Mask off the lower COUNT+1 bits of R0
;
	SUBRI   31,COUNT       ;shift count is (32 - (COUNT+1))
	LSH     COUNT,R0       ;shift left
	NEGI    COUNT
	LSH     COUNT,R0       ;shift right to get result
;
;  Check sign and negate result if necessary.
;
return:
	POP     RC             ;return address
	NEGI    R0,TEMP        ;negate result
	BD      RC             ;delayed branch to return
        CMPI    0,SIGN         ;check sign 
	LDIN    TEMP,R0        ;if set, use negative result
        CMPI    0,R0           ;set status from result
***     B       RC             ;BRANCH OCCURS (RETURN)
;
; The following code handles cases of a full 32-bit dividend.  This occurs
; when R0 = abs(R0) = 080000000h.  Handle this by calling the unsigned divide
; function, then negating the result if necessary.
;
div_32:
        PUSH    SIGN           ;remember sign
	.if 	.tms320C30
	CALL    DIV_U30        ;do divide
	.else
	CALL    DIV_U40        ;do divide
	.endif
	POP     SIGN           ;restore sign
	B       return         ;return
;
;  Return zero.
;
zero:
	LDI     0,R0
	RETS
        .end
divld.asm/      925421714   0     0     0       5562      `
        .length 78
        .width 132
******************************************************************
* DIV_LD V5.11 - 40 bit floating point divide for TMS3203x/4x
* Copyright (c) 1992-1999 Texas Instruments Incorporated
******************************************************************
*
*    Inputs:          Dividend in R0
*                     Divisor in R1
*    Outputs:         R0 / R1 in R0
*    Status:          Not Guaranteed
*    Registers Used:  R0,R1,R2,R3,R5,RC,BK
*
*    Operation: The quotient of R0 and R1 is formed with a precision
*       of 32 bits in the mantissa.  The result is returned in R0
*    
*    Notes: Form the quotient by computing the inverse of the divisor
*       and then multiplying.  The inverse is obtained by using 
*       an initial linear approximation which is refined by Newton 
*       iteration.  This routine has a problem when quotients are 
*       close the extremes of the floating range:  When the quotient 
*       has a machine exponent exactly equal to 127, the quotient will 
*       often not be properly computed by the function. Instead, the 
*       condition is treated as an overflow.
******************************************************************
	.sect ".text:flt40"
	.global DIV_LD
DIV_LD:
        POP     BK              ; retrieve return address
	LDF	R1,R3		; copy divisor and check for zero
	BNZD	DIV_LD_cont	; continue to common code if not zero
	LDM	1.0,R3		; blast the mantissa with all zeros
	PUSHF	R3		; push the exponent
	ANDN	1, ST		; clear carry to indicate unchecked divide
	SUBI	1, SP
	BR      DIVSATURATE     ; saturate result for divide by 0

; **********************************************************************
; CONTINUATION for non-zero divisor
; **********************************************************************

DIV_LD_cont:
; We use a linear approximation on the mantissa (1.0..2.0) to derive
; an estimate of 1/x.  Worst case relative error is .06 (4 bits)
	LDE	1.0,R1		; force divisor into 1..2 range
	LDFGT	-3.000516517,R2	;
	LDFLT	3.00051651,R2	;
	ADDF	R1, R2		;
	MPYF	-0.470459, R2	;

; We use several Newton iteration steps to refine our estimate.
; Bits quoted below are WORST case number of correct digits
	MPYF	R2, R1, R3
	SUBRF	2.0, R3
	MPYF	R3, R2		; 8 bits

	MPYF	R2, R1, R3
	SUBRF	2.0, R3
	MPYF	R3, R2		; 16 bits

	MPYF	R2, R1, R3
	SUBRF	2.0, R3
	MPYF	R3, R2		; 24 bits because of truncation

; negate the exponent of the divisor.  Use RC so don't change the carry bit.
	POP	RC		; get the divisor exponent as an integer
	NEGI	RC		; negative of the exponent
	PUSH	RC		; and convert it back into a float ...

; The last iteration yields a theoretical accuracy of 40 bits, providing
; we carefully evaluate it.  2*x - v*x**2 = (1 - v*x)*x + x
; Actual accuracy depends upon truncation errors in the arithmetic.
	LDIU	R5, RC		; save integer part of R5
	LDFU	-1.0078125, R5	; get 0FF000000h and clear exponent
	LDFU	R1, R3		; copy divisor
	AND	R5, R3		; chop to 8 bits
	SUBF	R3, R1		; keep LSBs of divisor
	MPYF	R2, R3		; form MSBs of v*x precisely
	MPYF	R2, R1		; LSBs of v*x
; The first subtract below causes R3's mantissa to left shift about 8 bits,
; the second shifts left 16 more, leaving about 16 nonzero bits.
	SUBRF	1.0, R3		; mantissa shifts left 8
	SUBF	R1, R3		; add in LSBs of product
	MPYF	R2, R3		; now complete (1 - v*x)*x
; 40-bit inverse mantissa lives with 24 MSBs in R2 and LSBs in R3.
; Re-install the negated exponent in our dividend
	POPF	R1		; convert negative exponent into a float
	ANDN	60H,ST		; clear latched status bits
	MPYF	R0, R1		; exponent of inverse * dividend into r1
				; This multiply may overflow if the
				; ultimate quotient has an exponent equal
				; to 127!  We have CHOSEN to ignore this
				; issue, given the large number of
				; instructions required to fix the problem.
	PUSHF	R1		; save new exponent on the stack
	LDE	1.0, R0		; clear exponent of dividend so the SUBF
				; below does not underflow
; Multiply inverse times the dividend.
	AND	R0, R5		; chop dividend down to 8 bits
	SUBF	R5, R0		; keep 24 LSBs
	MPYF3	R0, R3, R1	; I.LSB * D.LSB
	MPYF	R5, R3		; I.LSB * D.MSB
	ADDF	R3, R1		;
	MPYF	R2, R0		; I.MSB * D.LSB
	ADDF	R0, R1		;
	MPYF	R2, R5		; I.MSB * D.MSB
; now we want to round the sum of R1 + R5 to 32 bits. This is unpleasant.
	ADDF	R5, R1, R0	; unrounded result to return place
	SUBF	R0, R5		; get the bits not included..
	ADDF	R1, R5		; ..in result into R1
	MPYF	2.0,R5		; move up the first bit tossed
	ADDF	R5, R0		; and use TRUNCATED add to round

	POPF	R1		; get final exponent
	LDM	1.0, R1		; clear mantissa bits - now have 2**exponent

	BNLVD	BK		; return if no overflow
				;   -1 <= exponent_of_R0 < 1
				; -127 <= exponent_of_R1 <= 127
	MPYF	R0, R1		; form final exponent in R1.
				; since it is NOT possible for this to 
				; overflow, it need not appear before the BNLVD
	LDIU	RC, R5		; restore integer R5
	LDE	R1, R0		; form final 40-bit result

				; come here if there is an overflow

DIVSATURATE:
        CMPF    0.0, R0         ;
        LDFEQ   -2.0, R0        ; 80000000h into 32 LSBs
        LDFLT   1.99609375, R0  ; 7f800000h into 32 LSBs
        LDFGT   1.99560546875,R0; 7f700000h into 32 LSBs
        PUSH    R0              ; 32-LSBs to memory
        BUD     BK
        POPF    R0              ;
        ABSF    R0, R1          ;
        MPYF    R1, R0          ; R0 now holds one of {0.0, most-neg, most-pos}



divu.asm/       925421714   0     0     0       4867      `
	.length  78
	.width   132
********************************************************
* DIVU V5.11 - Integer divide routine (unsigned)
*                                        for TMS3203x/4x
* Copyright (c) 1992-1999 Texas Instruments Incorporated
********************************************************
*    Inputs:          Unsigned dividend in R0, 
*                     unsigned divisor in R1.
*
*    Output:          R0 / R1 into R0.
*    Status:          Set from result in R0.
*    Registers used:  R0, R1, AR0, AR1, RC, RS, RE
*    Operation:       1. Normalize divisor with dividend
*                     2. Repeat SUBC
*                     3. Quotient is in LSBs of result 
*
*    Cycles:          31-65
*********************************************************
	.asg    AR1,V          ;divisor
	.asg    R1, TEMP       ;float value of operands
	.asg    R1, MSBQ       ;MSQ of quotient
	.asg    AR0,QMASK      ;mask for quotient
	.asg    AR0,COUNT      ;repeat/shift count
	.asg    RC, EXP        ;divisor exponent

*********************************************************
* DIV_U - Unsigned division
*********************************************************
	.if 	.tms320C30
	.globl  DIV_U30
DIV_U30:
	.else
	.globl  DIV_U40
DIV_U40:
        .endif

        CMPI    R0,R1          ;divisor > dividend ? 
	BHI     zero           ;   if so, return 0
	LDI     R1,V           ;move divisor to AR1
;
; If top bit of dividend is set, handle specially.
;
        CMPI    0,R0 	       ;check top bit
	BLTD    div_32         ;get divisor exponent, then jump.
;
; Get divisor exponent by converting to float.
;
	FLOAT   V,TEMP         ;normalize divisor
	PUSHF   TEMP           ;push as float
	POP     EXP            ;pop as int to get exponent
        BZD     zero           ;if (float)divisor was zero, return
;
; 31 or less bits in dividend.  Get dividend exponent.
;
        FLOAT   R0,TEMP        ;normalize dividend
	PUSHF   TEMP           ;push as float
	POP     COUNT          ;pop as int to get exponent
;
; Use difference in exponents as shift count to line up MSBs.
;
	LSH     -24,COUNT      ;divisor exponent
	LSH     -24,EXP        ;dividend exponent
	SUBI    EXP,COUNT      ;difference
        LSH     COUNT,V        ;shift divisor up
; 
; Do COUNT+1 subtract & shifts.
;
	.if	.C30INTERRUPT  ;if -mi flag is set
	LDI     COUNT,RC       ;set counter for rptb instruction
	RPTB    i_sub	       ;repeat subtract
i_sub:	SUBC    V,R0
	.else
	RPTS    COUNT
	SUBC    V,R0
	.endif  
;
;  Mask off the lower COUNT+1 bits of U and return.
;
	POP     RC             ;return address
	SUBRI   31,COUNT       ;shift count is (32 - (COUNT+1))
	BD      RC             ;delayed branch to return
	LSH     COUNT,R0       ;shift left
	NEGI    COUNT
	LSH     COUNT,R0       ;shift right to get result
***     B       RC             ;BRANCH OCCURS (RETURN)
        .page
;
; The following code handles cases of a full 32-bit dividend.  Before
; SUBC can be used, the top bit must be cleared (otherwise SUBC can
; possibly shift a significant 1 out the top of the dividend).  This
; is accomplished by first doing a normal subtraction, then proceeding
; with SUBCs. 
;
div_32:
;
; If the top bit of the divisor is set too, the quotient is 1.  
; Otherwise, shift the divisor up to line up the MSBs. 
;
	CMPI    0,V            ;check divisor
	BLTD    one            ;if top bit set, quotient is 1
	LSH     -24,EXP        ;divisor exponent
	SUBRI   31,EXP         ;shift count 
	LSH     EXP,V          ;shift up to line up MSBs
;
; Now MSBs are aligned.  Do first SUBC by hand, and save off the first
; quotient digit.  Then, shift divisor right rather than shifting dividend
; left.  This leaves a 0 in the top bit of the dividend.
;
	LDI     1,QMASK        ;initialize MSB of quotient
	LSH     EXP,QMASK      ;create a mask for the MSBs
	SUBI    1,QMASK        ;mask is (2 << COUNT) - 1

	SUBI    V,R0,TEMP      ;subtract 
	LDIHS   TEMP,R0        ;if positive, replace dividend
	LDIHS   1,MSBQ         ;         and set quotient to 1
	LDILO   0,MSBQ         ;if negative, set quotient to 0
	LSH     EXP,MSBQ       ;shift MSB into position

	LSH     -1,V           ;shift divisor down
	SUBI    1,EXP          ;first iteration is done
; 
; Do EXP subtract & shifts.
;
	RPTS    EXP   
	SUBC    V,R0
;
; MSB of the quotient is in MSBQ.  LSBs are in the lower COUNT bits of
; R0.
;
	POP     RC             ;return address
	BD      RC             ;delayed branch to return
        AND     QMASK,R0       ;mask off LSBs
	OR      MSBQ,R0        ;MSB of quotient
        NOP
***     B       RC             ;BRANCH OCCURS (RETURN)
;
;  Return one.
;
one:    LDI     1,R0
	RETS
;
;  Return zero.
;
zero:   LDI     0,R0
	RETS
        .end

frexp30.asm/    925421714   0     0     0       1697      `
        .length  78
        .width   132
********************************************************
* FREXP V5.11 - Isolate mantissa for TMS3203x/4x
* Copyright (c) 1995-1999 Texas Instruments Incorporated
********************************************************
*    Syntax:         double frexp(double val, int *exp)
*
*    Outputs:        Returns a fraction "f" in the range [1/2, 1), 
*                    such that val == f x 2 ** (*exp).
*    Status:         Set from result in R0.
*    Registers used: R0 - R1, AR0, AR2
*********************************************************
	.globl  _frexp

_frexp:
        .if .REGPARM == 0
        LDI 	SP,AR0        ; transfer stack pointer for indexing
        LDF     *-AR0(1),R0   ; floating point value
        LDIU    *-AR0(2),AR2  ; return address for *exp
        .else
        LDF     R2,R0         ; floating point value
        .endif
;
; Check for 0.
;
	BZD     EPI0          
	LDIZ    0,R1
	NOP
	LDFZ    0.0,R0
***     BZ      EPI0          ; BRANCH OCCURS
;
; Extract the exponent and set the exp of f to -1.
; 
	PUSHF   R0            ; push val as float
	POP     R1            ; pop as int
	ASH     -24,R1        ; isolate exponent
	ADDI    1,R1          ; add 1 because exp of f will be -1

	LDE     0.5,R0        ; set exponent of f to -1
;
; The fraction f is now in range of [-1, -.5) or [.5, 1).
; If f == -1, change to -1/2 and add 1 to exp.
;
        CMPF    -1.0,R0
	BNZ     EPI0
	ADDI    1,R1          ; add 1 more 
	LDF     -0.5,R0       ; set f to -.5
;
; Store the exponent; set the status from the return value.
;
EPI0:   STI     R1,*AR2
	CMPF	0.0,R0
	RETS
        .end

invf.asm/       925421716   0     0     0       5910      `
	.length  78
	.width   132
*********************************************************************
* INVF V5.11 - Floating point inverse function for TMS3203x/4x
* Copyright (c) 1992-1999 Texas Instruments Incorporated
*********************************************************************
*    Inputs:           v in R0
*    Outputs:          1/v in R0
*    Status:           Not set from result (!!!)
*    Registers used:   R0, R1, AR0, AR1, R10 (C40)
*********************************************************************

        .if     .tms320C30
**********************************************************************
*  INV_F - Floating point inverse - C30 version
*
*  Algorithm:
*       Given v = a * 2**e
*       x[0] = 1.0 * 2**(-e-1)
*       for (i = 1; i <= 5; i++)
*         x[i] = x[i-1] * (2.0 - v * x[i-1])
*
*       The single-precision floating-point format is accurate to 6.9 
*       Given v = a * 2**e
*       x[0] = 1.0 * 2**(-e-1)
*       for (i = 1; i <= 5; i++)
*         x[i] = x[i-1] * (2.0 - v * x[i-1])
*
*       The single-precision floating-point format is accurate to 6.9 
*       decimal places.  The single-precision format is accurate to 
*       2**-23 = 1.192E-7, so we would like to have that much accuracy 
*       in the final result.
*
*       The algorithm's error at an iteration i (e[i]) is defined as
*          e[i] = 1 - v * x[i]
*       It can also be shown that e[i+1] = e[i] * e[i].
*  Cycles: 36
**********************************************************************
        .global INV_F30
INV_F30:  
	POP     AR1         ; Pop return address
	PUSH    R2          ; Save R2: integer part
	PUSHF   R2          ; Save R2: floating point part
	LDI     R0,AR0      ; Save mantissa of v to remember sign
        ABSF    R0          ; The algorithm uses v = |v|.
;
;   Extract the exponent of v.
;
        PUSHF   R0
        POP     R1
        ASH     -24,R1      ; The 8 LSBs of R1 contain the exponent of v.
;
; A few comments on boundary conditions.  If e = -128, then v = 0.  The
; following x[0] calculation yields R1 = --128 - 1 = 127 and the algorithm will
; overflow and saturate since x[0] is large.  This seems reasonable.  If e =
; 127, the R1 = -127 - 1 = -128.  Thus x[0] = 0 and this will cause the
; algorithm to yield zero.  Since the mantissa of v is always between 1 and 2,
; this is also reasonable.  As a result, boundary conditions are handled
; automatically in a reasonable fashion.
;
;   x[0] formation given the exponent of v.
;
        NEGI    R1
        SUBI    1,R1            ; Now we have -e-1, the exponent of x[0].
        ASH     24,R1
        PUSH    R1
        POPF    R1              ; Now R1 = x[0] = 1.0 * 2**(-e-1).
;
; Now the iterations begin.
;
        MPYF    R1,R0,R2        ; R2 = v * x[0]
        SUBRF   2.0,R2          ; R2 = 2.0 - v * x[0]
        MPYF    R2,R1           ; R1 = x[1] = x[0] * (2.0 - v * x[0])
 
        MPYF    R1,R0,R2        ; R2 = v * x[1]
        SUBRF   2.0,R2          ; R2 = 2.0 - v * x[1]
        MPYF    R2,R1           ; R1 = x[2] = x[1] * (2.0 - v * x[1])
 
        MPYF    R1,R0,R2        ; R2 = v * x[2]
        SUBRF   2.0,R2          ; R2 = 2.0 - v * x[2]
        MPYF    R2,R1           ; R1 = x[3] = x[2] * (2.0 - v * x[2])
 
        MPYF    R1,R0,R2        ; R2 = v * x[3]
        SUBRF   2.0,R2          ; R2 = 2.0 - v * x[3]
        MPYF    R2,R1           ; R1 = x[4] = x[3] * (2.0 - v * x[3])
 
        RND     R1              ; This minimizes error in the LSBs.
;
; For the last iteration we use the formulation:
; x[5] = (x[4] * (1.0 - (v * x[4]))) + x[4]
;
        MPYF    R1,R0,R2        ; R2 = v * x[4] = 1.0..01.. => 1
        SUBRF   1.0,R2          ; R2 = 1.0 - v * x[4] = 0.0..01... => 0
        MPYF    R1,R2           ; R2 = x[4] * (1.0 - v * x[4])
        ADDF    R2,R1,R0        ; R0 = x[5] = (x[4]*(1.0-(v*x[4])))+x[4]
;
; Return (delayed). Use delay slots to negate the result if v < 0.
;
	POPF    R2              ; Restore R2: floating point part
	POP     R2              ; Restore R2: integer part

	BD      AR1             ; delayed branch to return
        NEGF    R0,R1           ; R1 = -(1/v)
        CMPI    0,AR0           ; See if v was negative
        LDFN    R1,R0           ; If v < 0, then R1 = -R1
***     B       AR1             ; BRANCH OCCURS (RETURN)

	.endif                  ; .tms320C30
        .page

        .if     .tms320C40
**********************************************************************
*  INV_F - Floating point inverse - C40 version
*
*  Algorithm:
*       The algorithm used is basically the same as the C30 version,
*       except the the RCPF instruction is used to generate the 
*       initial seed x[0].  The initial seed is accurate to 8 bits,
*       so only two iterations are needed to generate a result 
*       accurate to 32 bits.
*
*       Modified to round all values for cosistancy and to preserve
*       the accuracy of division for small integer values.
*
*  Cycles: 10  
**********************************************************************
        .global INV_F40
INV_F40:  
	POP     AR1             ; return address

	RCPF    R0,R1           ; R1 = x[0] = estimate of 1/v

        MPYF    R1,R0,R10       ; R10 = v * x[0]
        SUBRF   2.0,R10         ; R10 = 2.0 - v * x[0]

				; if power of two, branch here
        MPYF    R10,R1          ; R1 = x[1] = x[0] * (2.0 - v * x[0])
        MPYF    R1,R0,R10       ; R10 = v * x[1]

	BD      AR1             ; delayed branch to return

        SUBRF   2.0,R10         ; R10 = 2.0 - v * x[1]
        MPYF    R10,R1,R11      ; R0 = x[2] = x[1] * (2.0 - v * x[1])

	RND     R11,R0          ; round result to correct integer values
***     B       AR1             ; BRANCH OCCURS (RETURN)
        .endif
	.end
invld.asm/      925421716   0     0     0       3601      `
        .length 78
        .width 132
*************************************************************************
* INV_LD V5.11 - 40 bit floating point inverse
* Copyright (c) 1992-1999 Texas Instruments Incorporated
*************************************************************************
*
*    Inputs:          Divisor in R1
*    Outputs:         Inverse of R1 in R0
*    Status:          Not Guaranteed
*    Registers Used:  R0,R1,R2,R3,BK
*
*    Operation:	      The inverse of R0 is formed with a precision of 32 
*                     bits in the mantissa.  The result is returned in R0.
*                     The inverse is obtained by using an initial linear 
*                     approximation which is refined by Newton iteration.
*************************************************************************
	.sect	".text:flt40"
	.global INV_LD
INV_LD:
	POP	BK
	LDF	R0,R3		; copy divisor and check for zero
	BNZD	INV_LD_cont	; continue to common code if not zero
	LDM	1.0,R3		; blast the mantissa with all zeros
	PUSHF	R3		; push the exponent
	LDE	1.0,R0		; force divisor into 1..2 range

	LDF	1.0, R0		; force most-pos saturated result
	SUBI	1, SP
				; division by 0.0 yields most-pos...
        LDF     1.99560546875,R0; 7f700000h into 32 LSBs
        PUSH    R0              ; 32-LSBs to memory
        BUD     BK
        POPF    R0              ;
        ABSF    R0, R1          ;
        MPYF    R1, R0          ; R0 now holds one of {0.0, most-neg, most-pos}


; **********************************************************************
; INV40 common code starts here
; **********************************************************************

INV_LD_cont:
	LDFGT	-3.000516517,R1	;
	LDFLT	3.000516517,R1	;
	ADDF	R0, R1		;
	MPYF	-0.470459, R1	;

	; We will only produce 32 bits of significance so we cannot round.
	; Make sure we do the expected thing re powers of 2
	ADDI3	R0,R0,R3	; is this a power of 2?
	BZD	INVLD_pow2	; yes, just jam in the exponent

	; We use several Newton iteration steps to refine our estimate.
	; Bits quoted below are WORST case number of correct digits
	MPYF	R1, R0, R3
	SUBRF	2.0, R3
	MPYF	R3, R1		; 8 bits
	;
	MPYF	R1, R0, R3
	SUBRF	2.0, R3
	MPYF	R3, R1		; 16 bits

	; The last iteration yields a theoretical accuracy of 32+ bits, 
	; providing we carefully evaluate it.  2*x - v*x**2 = (1 - v*x)*x + x
	; Actual accuracy depends upon truncation errors in the arithmetic.
	ANDN	0FFh,R1		; make sure lsbs of estimate are zero
	MPYF	R1, R0, R3
	AND	0FFh,R0		; keep LSBs of divisor
	NORM	R0		; remake a legitimate fp number
	MPYF	R1,R0		; LSBs of product

	; the subtract below causes R3's mantissa to left shift about 16 bits,
	; thereby insuring that the LSBs for the next multiply are zero.
	SUBRF	1.0, R3
	SUBRF	R3, R0		; add in LSBs of product
	MPYF	R1, R0

	; Now we re-install the negated exponent to form the inverse
	POP	R3		; get the divisor exponent as an integer
	NEGI	R3		; negative of the exponent
	PUSH	R3		; and convert it back...
	ADDF	R1, R0		; (from above - avoid PUSH pipeline stall)
	BUD	BK		; delayed return
	POPF	R3		; ...into a float
	MPYF	R0,R3		; compute exponent of inverse
	LDE	R3,R0		; and jam it into the final result

INVLD_pow2:
	POP	R3		; get the divisor exponent as an integer
	NEGI	R3		; negative of the exponent
	PUSH	R3		; and convert it back...
	BUD	BK		; delayed return
				; 1 cycle PUSH/POP pipeline stall
	POPF	R3		; ...into a float
	MPYF	R0,R3		; compute exponent of inverse
	LDE	R3,R0		; and jam it into the final result

ldexp30.asm/    925421716   0     0     0       1956      `
        .length  78
        .width   132
********************************************************************
* LDEXP V5.11 - Multiply by power of two for TMS3203x/4x
* Copyright (c) 1992-1999 Texas Instruments Incorporated
********************************************************************
*    Syntax:         double ldexp(double x, int exp);
*
*    Outputs:        Returns x times 2 ** exp.
*    Status:         Set from result in R0.
*    Registers used: R0,R1,R2,AR2
********************************************************************
ERANGE  .set    2
	.global _ldexp
        .global _errno

_ldexp:
        .if .REGPARM == 0
        LDI	SP,AR0
        LDF     *-AR0(1),R0    ; x
        .asg    *-AR0(2),EXP   ; exp
        .else
        LDF     R2,R0          ; x
        .asg    AR2,EXP        ; exp
        .endif
;
; Extract the exponent and add exp (power of two)
; 
	PUSHF   R0             ; push val as float
	POP     R1             ; pop as int
	ASH     -24,R1         ; isolate exponent of x
        ADDI    EXP,R1         ; add power
;
; Check the result and set result to 0 if too small, 
; infinity if too big
; 
	ABSI    R1,R2
	CMPI    127,R2        ; in range?
	BLE     ok 

	CMPI    0,R1          ; too big or too small?
	BGTD    infinity

	.if .BIGMODEL
	LDP     @_errno       ; in case big model
	.endif

	LDI     ERANGE,R2     ; indicate error
	STI     R2,@_errno
;	BGT     infinity      ; branch occurs

	LDF     0.0,R0        ; set result to 0
	RETS           

infinity:
	LDI     127,R1        ; exp = "infinity" 
	LDI     -1,R0         ; mantissa = "infinity"
        LSH     -1,R0         ; mantissa = 0x7FFFFFFF
; 
; Rebuild the number with the new exponent
; 
ok:     ASH     24,R1         ; reposition exponent
        PUSH    R1            ; push as int
	POPF    R1            ; pop as float
	LDE     R1,R0         ; set exponent 
        RETS
	.end

modf30.asm/     925421716   0     0     0       1321      `
	.length  78
        .width   132
********************************************************
* MODF V5.11 - Split value into integer and fraction
*                                        for TMS3203x/4x
* Copyright (c) 1992-1999 Texas Instruments Incorporated
********************************************************
*    Syntax:         double modf(double x, double *iptr);
*
*    Outputs:        Returns f, the fractional part of x.
*                    Saves i, integer part of x, in *iptr.
*    Status:         Set from result in R0.
*    Registers used: R0,R2,AR2
*********************************************************
	.globl  _modf


_modf:  
        .if .REGPARM == 0
        LDI	SP,AR0
        LDF     *-AR0(1),R2    ; x
        LDI     *-AR0(2),AR2   ; iptr
        .endif
;
; Convert to int, then back to float to get i.  Subtract i
; from x to get the fraction.
;
        FIX     R2,R0         ; (int)i
        LDFV    R2,R0         ; if (overflow) i = x
        BV      result
        FLOAT   R0            ; (float)i
; 
; If x is a negative non-integer, add 1 to i.
;
        BGE     result
        CMPF    R2,R0
        BEQ     result
        ADDF    1.0,R0

result: STF     R0,*AR2       ; *iptr = i
        SUBRF   R2,R0         ; f = x - i
        RETS
	.end

modi.asm/       925421716   0     0     0       3635      `
	.length  78
	.width   132
********************************************************
* MODI V5.11 - Integer modulo (signed) for TMS3203x/4x
* Copyright (c) 1992-1999 Texas Instruments Incorporated
********************************************************
*    Inputs:          Signed integer dividend in R0, 
*                     Signed integer divisor in R1.
*    Output:          R0 % R1 into R0.
*    Status:          Set from result in R0.
*    Registers used:  R0, R1, AR0, AR1, IR0, IR1
*
*    Operation:       1. Normalize divisor with dividend
*                     2. Repeat SUBC
*                     3. Remainder is in MSBs of result
*
*    Cycles:          31-62 (depends on normalization)
*********************************************************
	.asg    AR1,V          ;divisor
	.asg    R1,TEMP        ;float value of operands
	.asg    R1,COUNT       ;repeat/shift count 
	.asg    AR0,SIGN       ;sign of result
	.asg    RC,EXP         ;divisor exponent 

*********************************************************
* MOD_I - Signed integer modulo
*********************************************************
	.if 	.tms320C30
	.globl  MOD_I30, MOD_U30
MOD_I30:
	.else
	.globl  MOD_I40, MOD_U40
MOD_I40:
        .endif
; 
; Determine sign of result.  Get absolute value of operands.
; 
	LDI     R0,SIGN        ;sign of result same as dividend
	ABSI    R0             ;make dividend positive
	BVD     mod_32         ;if still negative, escape
	ABSI    R1             ;make divisor positive
	LDI     R1,V           ;save in V       
        CMPI    R0,V           ;divisor > dividend ? 
	BHID    return         ;  if so, return dividend
; 
; Normalize operands.  Use difference in exponents as shift count
; for divisor, and as repeat count for SUBC.
;
        FLOAT   R1,TEMP        ;normalize divisor
        PUSHF   TEMP           ;push as float 
	POP     EXP            ;pop as int
        BZD     return         ;if (float)divisor was zero, return

        FLOAT   R0,TEMP        ;normalize dividend
        PUSHF   TEMP           ;push as float
        POP     COUNT          ;pop as int 

	LSH     -24,EXP        ;get divisor exponent
	LSH     -24,COUNT      ;get dividend exponent
	SUBI    EXP,COUNT      ;get difference in exponents
	LSH     COUNT,V        ;align divisor with dividend
; 
; Do COUNT+1 subtract & shifts.
;
	.if	.C30INTERRUPT  ;if -mi flag is set
	LDI     COUNT,RC       ;set counter for rptb instruction
	RPTB    i_sub	       ;repeat subtract
i_sub:	SUBC    V,R0
	.else 
	RPTS    COUNT
	SUBC    V,R0
	.endif
;
;  Remainder is in upper bits of R0
;
	ADDI    1,COUNT        ;shift count is -(COUNT+1)
	NEGI    COUNT 
	LSH     COUNT,R0       ;shift right
;
;  Check sign and negate result if necessary.
;
return:
        POP     RC             ;return address
        NEGI    R0,TEMP        ;negate result
	BD      RC             ;delayed branch to return
	CMPI    0,SIGN         ;check sign
	LDIN    TEMP,R0        ;if set, use negative result
        CMPI    0,R0           ;set status on result
***     B       RC             ;BRANCH OCCURS (RETURN)
;
; The following code handles cases of a full 32-bit dividend.  This occurs
; when R0 = abs(R0) = 080000000h.  Handle this by calling the unsigned mod
; function, then negating the result if necessary.
;
mod_32:
        PUSH    SIGN           ;remember sign
	.if     .tms320C30
	CALL    MOD_U30        ;do divide
	.else
	CALL    MOD_U40        ;do divide
	.endif
	POP     SIGN           ;restore sign
	B       return         ;return

        .end

modu.asm/       925421718   0     0     0       4337      `
	.length  78
	.width   132
********************************************************
* MODU V5.11 - Integer modulo(unsigned) for TMS3203x/4x
* Copyright (c) 1992-1999 Texas Instruments Incorporated
********************************************************
*    Inputs:          Unsigned dividend in R0, 
*                     unsigned divisor in R1.
*
*    Output:          R0 % R1 into R0.
*    Status:          Set from result in R0.
*    Registers used:  R0, R1, AR0, AR1, RC, RS, RE
*    Operation:       1. Normalize divisor with dividend
*                     2. Repeat SUBC
*                     3. Remainder is in MSBs of result
*
*    Cycles:          31-60
*********************************************************
	.asg    AR1,V          ;divisor
	.asg    R1,TEMP        ;float value of operands
	.asg    AR0,COUNT      ;repeat/shift count
	.asg    RC,EXP         ;divisor exponent

*********************************************************
* MOD_U - Unsigned modulo
*********************************************************
	.if 	.tms320C30
	.globl  MOD_U30
MOD_U30:
	.else
	.globl  MOD_U40
MOD_U40:
        .endif

        CMPI    R0,R1          ;divisor > dividend ? 
	BHI     zero           ;   if so, return dividend
	LDI     R1,V           ;load divisor
;
; If top bit of dividend is set, handle specially.
;
        CMPI    0,R0 	       ;check top bit
	BLTD    mod_32         ;get divisor exponent, then jump.
;
; Get divisor exponent by converting to float.
;
	FLOAT   V,TEMP         ;normalize divisor
	PUSHF   TEMP           ;push as float
	POP     EXP            ;pop as int to get exponent
        BZD     zero           ;if (float)divisor was zero, return
;
; 31 or less bits in dividend.  Get dividend exponent.
;
        FLOAT   R0,TEMP        ;normalize dividend
	PUSHF   TEMP           ;push as float
	POP     COUNT          ;pop as int to get exponent
;
; Use difference in exponents as shift count to line up MSBs.
;
	LSH     -24,EXP        ;divisor exponent
	LSH     -24,COUNT      ;dividend exponent
	SUBI    EXP,COUNT      ;difference
        LSH     COUNT,V        ;shift divisor up
; 
; Do COUNT+1 subtract & shifts.
;
	.if	.C30INTERRUPT  ;if -mi flag is set
	LDI     COUNT,RC       ;set counter for rptb instruction
	RPTB    i_sub	       ;repeat subtract
i_sub:	SUBC    V,R0
	.else 
	RPTS    COUNT
	SUBC    V,R0  
	.endif
;
;  Remainder is in upper 31-COUNT bits.
;
	POP     RC             ;return address
	BD      RC             ;delayed branch to return
	ADDI    1,COUNT        ;shift count is COUNT+1
	NEGI    COUNT          ;negate for right shift
	LSH     COUNT,R0       ;shift to get result
***     B       RC             ;BRANCH OCCURS (RETURN)
        .page
;
; The following code handles cases of a full 32-bit dividend.  Before
; SUBC can be used, the top bit must be cleared (otherwise SUBC can
; possibly shift a significant 1 out the top of the dividend).  This
; is accomplished by first doing a normal subtraction, then proceeding
; with SUBCs. 
;
mod_32:
;
; If the top bit of the divisor is set too, the remainder is simply
; the difference between the dividend and divisor.  Otherwise, shift 
; the divisor up to line up the MSBs.
;
	CMPI    0,V            ;check divisor
	BLTD    one            ;if negative, remainder is diff

	LSH     -24,EXP        ;divisor exponent
	SUBRI   31,EXP         ;shift count = 31 - exp
	NEGI    EXP,COUNT      ;used later as shift count
	LSH     EXP,V          ;shift up to line up MSBs
;
; Now MSBs are aligned.  Do first SUBC by hand using a plain subtraction.
; Then, shift divisor right rather than shifting dividend left.  This leaves
; a 0 in the top bit of the dividend.
;
	SUBI    V,R0,TEMP      ;subtract 
	LDIHS   TEMP,R0        ;if positive, replace dividend
	SUBI    1,EXP          ;first iteration is done
	LSH     -1,V           ;shift divisor down
; 
; Do EXP subtract & shifts.
;
	RPTS    EXP  
	SUBC    V,R0   
;
;  Quotient is in EXP+1 LSBs; shift remainder (in MSBs) down.
;
	LSH     COUNT,R0       ;COUNT contains -(EXP+1)
        RETS
;
;  Return (dividend - divisor).
;
one:    SUBI    V,R0  
	RETS
;
;  Return dividend.
;
zero:   CMPI    0,R0           ;set status from result
	RETS
        .end

mpyi.asm/       925421718   0     0     0       1420      `
	.length  78
	.width   132
********************************************************
* MPYI V5.11 - 32x32 Integer Multiply for TMS3203x/4x
* Copyright (c) 1992-1999 Texas Instruments Incorporated
********************************************************
*    Inputs:         x in R0, y in R1.
*    Outputs:        x*y in R0.
*    Status:         Set from result in R0.
*    Registers used: R0, R1, AR0, AR1
*
*    Operation:
*       Let x0 = 16 MSBs of x, x1 = 16 LSBs of x
*           y0 = 16 MSBs of y, y1 = 16 LSBs of y
*      
*       result = (x0 * y1) + (y0 * x1) + (x1 * y1)
*
*    Cycles:  14
*    Note: This function used only for the TMS320C30
*********************************************************
	.if     .tms320C30

	.globl  MPY_I30
MPY_I30:
        LDI     R0,AR0        ;x
        LDI     R1,AR1        ;y
        LSH     -16,R0        ;x0
        LSH     -16,R1        ;y0
        AND     0FFFFh,AR0    ;x1
        AND     0FFFFh,AR1    ;y1
        MPYI    AR1,R0        ;y1 * x0
        MPYI    AR0,R1        ;x1 * y0
        MPYI    AR0,AR1       ;x1 * y1
	POP     AR0           ;return address
	BD      AR0           ;delayed branch to return
        ADDI    R1,R0         ;MSW of product
        LSH     16,R0         ;shift up
        ADDI    AR1,R0        ;add in LSW
***     B       AR0           ;BRANCH OCCURS (RETURN)
	.endif
        .end






mpyk.asm/       925421718   0     0     0       1233      `
	.length  78
	.width   132
********************************************************
* MPYK V5.11 - 32x16 Integer Multiply by Constant
*                                        for TMS3203x/4x
* Copyright (c) 1992-1999 Texas Instruments Incorporated
********************************************************
*    Inputs:         x in R0 (any integer)
*                    k in R1 (-32768 <= k <= 32767) 
*    Outputs:        x*k in R0.
*    Status:         Set from result in R0.
*    Registers used: R0, R1, AR0, AR1
*
*    Operation:
*       Let x0 = 16 MSBs of x, x1 = 16 LSBs of x
*      
*       result = (x0 * k) + (x1 * k)
*
*    Cycles:  9
*    Note: This function used only for the TMS320C30
*********************************************************
	.if     .tms320C30

	.globl  MPY_K30
MPY_K30:
	POP     AR1           ;return address
        LDI     R0,AR0        ;x
        LSH     -16,R0        ;x0
        AND     0FFFFh,AR0    ;x1
	MPYI    R1,R0         ;x0 * k
	BD      AR1           ;delayed branch to return
	MPYI    R1,AR0        ;x1 * k
	LSH     16,R0         ;shift MSW up
	ADDI    AR0,R0        ;add in LSW
***     B       AR1           ;BRANCH OCCURS (RETURN)
	.endif

	.end

mpyld.asm/      925421718   0     0     0       1265      `
        .length 78
        .width 132
******************************************************************
* MPY_LD V5.11 - 40 bit floating point multiply for TMS3203x/4x
* Copyright (c) 1992-1999 Texas Instruments Incorporated
******************************************************************
*
*    Inputs:          Operands in R0, R1
*    Outputs:         R0 * R1 in R0, with a precision of 32 bits
*                     in the mantissa.
*    Status:          Not Guaranteed
*    Registers Used:  R0,R1,R2,R3,BK
*
******************************************************************
	.sect	".text:flt40"
	.global MPY_LD
MPY_LD:
	.if .C3x
	POP	BK      	; retrieve return address
	ANDN	60H,ST		; clear latched overflow and underflow
	LDFU	R0, R3		; save original R0 in R3
	AND	255, R0		;
	NORM	R0, R0		; A LSBs to R0
	LDFU	R1, R2		;
	AND	255, R2		;
	NORM	R2, R2		; B LSBs to R2
	MPYF	R1, R0		;                             B.MSB*A.LSB
	MPYF	R3, R2		;               A.MSB*B.LSB
	ADDF	R0, R2		;               A.MSB*B.LSB + B.MSB*A.LSB

	BUD	BK		; == delayed return
	NOP			; NUTS! wasted cycle
	MPYF	R1, R3, R0	; A.MSB*B.MSB
	ADDF	R2, R0		; A.MSB*B.MSB + A.MSB*B.LSB + B.MSB*A.LSB
	.endif
	.if .C4x
	MPYF    R1, R0
	RETSU
	.endif


setjmp.asm/     925421718   0     0     0       4069      `
	.length  78
        .width   132
********************************************************
* setjmp/longjmp V5.11  for TMS3203x/4x
* Copyright (c) 1992-1999 Texas Instruments Incorporated
********************************************************
*    C syntax:       int setjmp(jmp_buf env)
*
*    Description:    Save caller's current environment for a subsequent
*                    call to longjmp.  Return 0.
*    Return:         Always returns 0.                    
*********************************************************
        .global  _setjmp, __setjmp, _longjmp

****************************************************************************
*  NOTE : ANSI specifies that "setjmp.h" declare "setjmp" as a macro. 
*         In our implementation, the setjmp macro calls a function "_setjmp".
*         However, since the user may not include "setjmp.h", we provide
*         two entry-points to this function.
****************************************************************************
__setjmp:
_setjmp:
	POP       R1                      ;get return address
        LDI	  SP,AR0
        .if .REGPARM == 0
        LDI       *AR0,AR2                ;get the location of jmp_buf arg.
        .endif

****************************************************************************
* Save all registers guaranteed to be preserved across calls in the jmp_buf.
****************************************************************************
        STI       R4,*AR2++               ;save register variables
        STI       R5,*AR2++               ;R4, R5, F6, F7
        STF       R6,*AR2++
        STF       R7,*AR2++
        .if .tms320C40
        STI       R8,*AR2++
        .endif
        STI       AR3,*AR2++              ;save caller's FP
        STI       AR4,*AR2++              ;save AR4, AR5, AR6, AR7
        STI       AR5,*AR2++
        STI       AR6,*AR2++
        STI       AR7,*AR2++

	BD        R1                      ;delayed branch to return
        STI       R1,*AR2++               ;save return address
        STI       AR0,*AR2                ;save caller's SP
        LDI       0,R0                    ;setjmp returns zero
****    B         R1                      ;BRANCH OCCURS

        .page
****************************************************************************
*    C syntax:    void longjmp(jmp_buf env, int returnvalue)
*
*    Description: Restore the context contained in the jump buffer.
*                 This causes an apparent "2nd return" from the
*                 setjmp invocation which built the "env" buffer.
*
*    Return:      This return appears to return "returnvalue", which must 
*                 be non-zero.
*
****************************************************************************
_longjmp:
        .if .REGPARM == 0
        LDI	  SP,AR0
        LDI       *-AR0(1),AR2        ;get location of jmp_buf
        LDI       *-AR0(2),R0         ;get return value
        LDIZ      1,R0                ;ensure non-zero return value
        .else
        LDI       R2,R0               ;return value
        LDIZ      1,R0                ;ensure non-zero return value
        .endif
 
****************************************************************************
* Restore environment from saved jmp_buf.
****************************************************************************
        LDI       *AR2++,R4           ;restore register variables
        LDI       *AR2++,R5           ;R4, R5, F6, F7
        LDF       *AR2++,R6 
        LDF       *AR2++,R7 
        .if .tms320C40
        LDI       *AR2++,R8
        .endif
        LDI       *AR2++,AR3          ;restore FP
        LDI       *AR2++,AR4          ;restore address registers
        LDI       *AR2++,AR5 
        LDI       *AR2++,AR6 
        LDI       *AR2++,AR7 
        LDI       *AR2++,R1           ;get return address
        LDI       *AR2,SP             ;restore SP

        B         R1                  ;branch to setjmp for return
        .end

sqrt30.asm/     925421720   0     0     0       4296      `
	.length  78
        .width   132
********************************************************
* SQRT V5.11 - Square Root for TMS3203x/4x
* Copyright (c) 1992-1999 Texas Instruments Incorporated
********************************************************
*    Syntax:         double sqrt(double x)
*
*    Outputs:        Returns square root of x in R0.
*    Status:         Set from result in R0.
*    Registers used: R0,R1,R2,R3,AR0
* 
*********************************************************
EDOM    .set    1
	.global _sqrt
        .global _errno

        .if     .tms320C30
*********************************************************
* SQRT - C30 Version
*    The algorithm is from the TMS320C30 User's Guide, 
*    p. 11-30.  
*********************************************************
_sqrt:
        .if .REGPARM == 0
        LDI     SP,AR0
        LDF     *-AR0(1),R2   ; x
        .else
        CMPF    0.0,R2        ; x > 0?
        .endif
 
	BGT     pos           
	LDFLE   0.0,R0        ; if x == 0, return 0
	RETSEQ

        .if .BIGMODEL
	LDP     @_errno       ; in case big model
	.endif

	LDI     EDOM,R1       ; indicate error
	STI     R1,@_errno
        RETS
pos:    
        LDF     R2,R3         ; save x
	MPYF	2.0,R2        ; add a rounding bit in exponent
	PUSHF	R2            ; push x as float
	POP	R1            ; pop as int
	ASH	-25,R1        ; e = exponent(x) / 2
;
; determine initial estimate .25 * 2**(-e/2)
;
	NEGI	R1            ; negate exponent 
	ASH	24,R1         ; shift into place
	PUSH	R1            ; push as int 
	POPF	R1            ; pop as float
	MPYF	0.25,R2       ; remove rounding bit
;
; iterate 5 times
;
	MPYF	R1,R2,R0      ; R0 = x[0] * (v/2)
	MPYF	R1,R0         ; R0 = (v/2) * x[0] * x[0]
	SUBRF	1.5,R0	      ; R0 = 1.5 - (v/2) * x[0] * x[0]
	MPYF	R0,R1	      ; x[1] = x[0] * (1.5 - v/2 * x[0] * x[0])
; 2
	RND     R1
	MPYF	R1,R2,R0      ; R0 = x[1] * (v/2)
	MPYF	R1,R0         ; R0 = (v/2) * x[1] * x[1]
	SUBRF	1.5,R0	      ; R0 = 1.5 - (v/2) * x[1] * x[1]
	MPYF	R0,R1	      ; x[2] = x[1] * (1.5 - v/2 * x[1] * x[1])
; 3
	RND     R1
	MPYF	R1,R2,R0      ; R0 = x[2] * (v/2)
	MPYF	R1,R0         ; R0 = (v/2) * x[2] * x[2]
	SUBRF	1.5,R0	      ; R0 = 1.5 - (v/2) * x[2] * x[2]
	MPYF	R0,R1	      ; x[3] = x[2] * (1.5 - v/2 * x[2] * x[2])
; 4
	RND     R1
	MPYF	R1,R2,R0      ; R0 = x[3] * (v/2)
	MPYF	R1,R0         ; R0 = (v/2) * x[3] * x[3]
	SUBRF	1.5,R0	      ; R0 = 1.5 - (v/2) * x[3] * x[3]
	MPYF	R0,R1	      ; x[4] = x[3] * (1.5 - v/2 * x[3] * x[3])
; 5
	RND     R1
	MPYF	R1,R2,R0      ; R0 = x[4] * (v/2)
	MPYF	R1,R0         ; R0 = (v/2) * x[4] * x[4]
	SUBRF	1.5,R0	      ; R0 = 1.5 - (v/2) * x[4] * x[4]
	MPYF	R0,R1	      ; x[5] = x[4] * (1.5 - v/2 * x[4] * x[4])
;
	RND     R1,R2
	MPYF    R3,R2,R0      ; sqrt(x) = x * sqrt(1/x)

	RETS

	.endif                ; .tms320C30

	.page
        .if     .tms320C40
*********************************************************
* SQRT - C40 Version
*    The algorithm uses the RSQRF instruction to calculate 
*    the initial seed.  See the TMS320C40 User's Guide, 
*    p. 12-38.  
*********************************************************
_sqrt:
        .if .REGPARM == 0
        LDA     SP,AR0 
        LDF     *-AR0(1),R2   ; x
        .else
        CMPF    0.0,R2        ; x > 0?
        .endif
 
	BGT     pos           
	LDFLE   0.0,R0        ; if x == 0, return 0
	RETSEQ

        .if .BIGMODEL
	LDP     _errno        ; in case big model
	.endif
	STIK    EDOM,@_errno  ; indicate error
        RETS

pos:    LDF     R2,R3         ; save x
        RSQRF   R2,R1         ; R1 = x[0] = estimate of 1/sqrt(x)
        MPYF    0.5,R2        ; R2 = x/2

	MPYF	R1,R2,R0      ; R0 = x[0] * (v/2)
	MPYF	R1,R0         ; R0 = (v/2) * x[0] * x[0]
	SUBRF	1.5,R0	      ; R0 = 1.5 - (v/2) * x[0] * x[0]
	MPYF	R0,R1	      ; x[1] = x[0] * (1.5 - v/2 * x[0] * x[0])

	RND     R1
	MPYF	R1,R2,R0      ; R0 = x[1] * (v/2)
	MPYF	R1,R0         ; R0 = (v/2) * x[1] * x[1]
	SUBRF	1.5,R0	      ; R0 = 1.5 - (v/2) * x[1] * x[1]
	MPYF	R0,R1	      ; x[2] = x[1] * (1.5 - v/2 * x[1] * x[1])

	RND     R1,R2
	MPYF    R3,R2,R0      ; sqrt(x) = x * sqrt(1/x)

	RETS
	.endif
	.end











_bufread.c/     925421662   0     0     0       3227      `
/*****************************************************************************/
/*  _BUFREAD.C V5.11                                                        */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/
 
/*****************************************************************************/
/* Functions:                                                                */
/*    _BUFF_READ  -  Fill a stream's buffer from its file                    */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int  _ft_end;
extern int  _doflush(FILE *_fp);
extern void _buff_read(FILE *_fp);


/*****************************************************************************/
/* _BUFF_READ  -   Fill a stream's buffer from its file                      */
/*                                                                           */
/*    This function fills stream _FP's buffer with the contents of the file  */
/*    it is associated with.  It returns nothing, but sets flags in the      */
/*    stream if any I/O errors occur.                                        */
/*                                                                           */
/*****************************************************************************/
void _buff_read(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   errchk,
         j,
         buffer_size    = _fp->bufend - _fp->buf;

   /*------------------------------------------------------------------------*/
   /* If this is a line buffered stream, flush all line buffered streams.    */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IOLBF)
      for(j=0; j < _ft_end; j++)
         if(_BUFFMODE(&_ftable[j]) == _IOLBF)
            _doflush(&_ftable[j]);

   /*------------------------------------------------------------------------*/
   /* Read in the next characters from the file.                             */
   /*------------------------------------------------------------------------*/
   errchk = read(_fp->fd, (char *)_fp->buf, buffer_size);

   /*------------------------------------------------------------------------*/
   /* Adjust the buffer pointers.                                            */
   /*------------------------------------------------------------------------*/
   _fp->buff_stop = _fp->buf + errchk;
   _fp->pos = _fp->buf;

   /*------------------------------------------------------------------------*/
   /* Set any error flags if necessary.                                      */
   /*------------------------------------------------------------------------*/
   switch(errchk)
   {
      case -1 : _SET(_fp, _STATERR);
                break;
 
      case 0  : _SET(_fp, _STATEOF);
                break;
   }

   return;
 
}
 

_io_perm.c/     925421662   0     0     0       5963      `
/*****************************************************************************/
/*  _IO_PERM.C V5.11                                                        */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    _RD_OK   -  Check to make sure that the stream is readable             */
/*    _WRT_OK  -  Check to make sure that the stream is writeable            */
/*****************************************************************************/
#include <stdio.h>

extern int _rd_ok(FILE *_fp);
extern int _wrt_ok(FILE *_fp);


/*****************************************************************************/
/* _RD_OK   -  Check to make sure that the stream is readable.               */
/*                                                                           */
/*    This function checks to make sure that the stream _FP has been opened  */
/*    for reading, and allocates a buffer for the stream if one hasn't been  */
/*    already.  The function returns a 1 if it is alright to write to this   */
/*    stream, otherwise it returns a 0.                                      */
/*                                                                           */
/*****************************************************************************/
int _rd_ok(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   result   =  0;

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (0);

   /*------------------------------------------------------------------------*/
   /* If this stream is currently being written to, return a 0.              */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODEW)) return (0);
 
   /*------------------------------------------------------------------------*/
   /* If this stream was opened in update mode, and is able to either read   */
   /* or write currently, put it in read mode.                               */
   /*------------------------------------------------------------------------*/
   if(!_STCHK(_fp, _MODER) && _STCHK(_fp, _MODERW)) _SET(_fp, _MODER);
 
   /*------------------------------------------------------------------------*/
   /* Allocate a buffer for the stream if needed, and none exist.            */
   /*------------------------------------------------------------------------*/
   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))
      result |= setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ);
 
   return (! result);
 
}






/*****************************************************************************/
/* _WRT_OK()   -  Check to make sure that a stream is writeable              */
/*                                                                           */
/*    This function takes the FILE pointer _FP, and makes sure that it is ok */
/*    to write to it.  It also allocates a buffer if one is needed.  The     */
/*    function returns a 1 if it is ok to write to this stream, otherwise it */
/*    returns a 0.                                                           */
/*                                                                           */
/*****************************************************************************/
int _wrt_ok(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   result   = 0;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (0);

   /*------------------------------------------------------------------------*/
   /* If this stream is currently being read return a 0.                     */
   /*------------------------------------------------------------------------*/
   if (_STCHK(_fp, _MODER)) return (0);
 
   /*------------------------------------------------------------------------*/
   /* If the stream is in append mode, move the file pointer to the end of   */
   /* the file.                                                              */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODEA)) fseek(_fp, 0L, SEEK_END);
 
   /*------------------------------------------------------------------------*/
   /* If this stream was opened in update mode, and is able to either read   */
   /* or write currently, put it in write mode.                              */
   /*------------------------------------------------------------------------*/
   if(!_STCHK(_fp, _MODEW) && _STCHK(_fp, _MODERW)) _SET(_fp, _MODEW);
 
   /*------------------------------------------------------------------------*/
   /* Allocate a buffer for the stream if needed, and none exist.            */
   /*------------------------------------------------------------------------*/
   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))
      result |= setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ);
 
   return (! result);
}


_log.c/         925421662   0     0     0       4289      `
/*****************************************************************************/
/* _log.c V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

extern double _log(double x);

/****************************************************************************/
/*  _LOG() - natural log (w/o error checking)				    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 5.              */
/*									    */
/*  N = exponent x							    */
/*  f = mantissa x, 0.5 <= f < 1					    */
/*  if f < sqrt(0.5), znum = f - 0.5, zden = znum * 0.5 + 0.5		    */
/*  if f > sqrt(0.5), znum = f - 1, zden = f * 0.5 + 0.5		    */
/*  z = znum / zden							    */
/*  w = z * z								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = R + N * ln(2)						    */
/****************************************************************************/
double _log(double x)
{
    int n;

#if defined(_TMS320C30) || defined(_TMS320C40)
    double x2;
    /************************************************************************/
    /* x = mantissa of x, n = exponent of x                                 */
    /************************************************************************/
    x = 2.0 * frexp(x, &n);
    --n;

    /************************************************************************/
    /* log2(x) is approximately (x - sqrt(2) / x + sqrt(2))                 */
    /************************************************************************/
    x  = (x - SQRTWO) / (x + SQRTWO);
    x2 = x * x;

    /************************************************************************/
    /* polynomial expansion for log2(x)                                     */
    /************************************************************************/
    x = ((((L7 * x2 + L5) * x2 + L3) * x2 + L1) * x + 0.5);

    /************************************************************************/
    /* log2(x) = log2(mantissa(x)) + exponent(x)                            */
    /************************************************************************/
    return ((x + n) * LOGe2);

#else
    double a, b, f, r, w, z, znum, x2;
    /************************************************************************/
    /* f = mantissa(x), n = exponent(x)            			    */
    /************************************************************************/
    f = frexp(x, &n);

    /************************************************************************/
    /* for numbers <= sqrt(0.5)                                             */
    /************************************************************************/
    if (f <= SQRTHALF)
    {
        --n;
	znum = f - 0.5;
	z    = znum / (znum * 0.5 + 0.5);
    }

    /************************************************************************/
    /* for numbers > sqrt(0.5)                                              */
    /************************************************************************/
    else
    {
	znum = (f - 0.5) - 0.5;
	z    = znum / (f * 0.5 + 0.5);
    }

    /************************************************************************/
    /* determine polynomial expression                                      */
    /************************************************************************/
    w = z * z;

    a = A0;
    b = w + B0;

    /************************************************************************/
    /* calculate the natural log of (mant x) / 2                            */
    /************************************************************************/
    r = z + z * w * (a / b);

    /************************************************************************/
    /* ln(x) = ln (mant x) + 2 * (exp x) (but more mathematically stable)   */
    /************************************************************************/
    return ((n * C4 + r) + n * C3);
#endif
}

_printfi.c/     925421664   0     0     0       50813     `
/*****************************************************************************/
/*  _PRINTFI.C V5.11                                                        */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the main routines that all six variations of the    */
/*    printf function use.  The main function in the file is _printfi,       */
/*    and the other functions here are called by it.                         */
/*                                                                           */
/* FUNCTIONS:                                                                */
/*    _printfi       -  Perform the main printf routine                      */
/*    _pproc_fflags  -  Process the format flags for a conversion            */
/*    _pproc_fwp     -  Convert field width and precision into numbers       */
/*    _pproc_str     -  Process the string (%s) conversion                   */
/*    _setfield      -  Performs conversions when the '%' is encountered     */
/*    _pproc_fge     -  Process the conversion for f, g, G, e, and E         */
/*    _pconv_f       -  Perform the %f conversion                            */
/*    _pconv_e       -  Perform the %e conversion                            */
/*    _pconv_g       -  Perform the %g conversion                            */
/*    _fcpy          -  Copy the fraction part of a float to a string        */
/*    _ecpy          -  Copy the "E+xx" part of a float to a string          */
/*    _mcpy          -  Copy the whole number part of a float to a string    */
/*    _pproc_diouxp  -  Process the conversion for d, i, o, u, x, and p      */
/*    _getarg_diouxp -  Get the argument for d, i, o, u, x, or p conversion  */
/*    _ltostr        -  Convert an integer to a string of up to base 16      */
/*    _div           -  Divide two integers                                  */
/*                                                                           */
/* Note:  If NOFLOAT is defined at compile time, this file will be compiled  */
/*        without floating point support.                                    */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#define SIGNED_CONV (pfield->conv != 'u' && pfield->conv != 'o' && \
                     pfield->conv != 'x' && pfield->conv != 'X')

extern char *fcvt(double value, register int ndigit, int *decpt, int *sign);
extern char *ecvt(double value, register int ndigit, int *decpt, int *sign);
extern char *memccpy(char *dest, const char *src, int ch, int count);
extern int _printfi(char **_format, va_list _ap, void *_op,
                   int (*_outc)(char, void *), int (*_outs)(char *, void *));

static void _pproc_fflags(_PFIELD *pfield, char **it);
static void _pproc_fwp(_PFIELD *pfield, char **it, va_list *_ap);
static void _pproc_str(_PFIELD *pfield, void *_op, va_list *_ap, int *count,
                       int (*_outs)(char *, void *));
static char *_setfield(_PFIELD *pfield, va_list *_ap);
static void _pproc_fge(_PFIELD *pfield, int *minus_flag, char **a_it,
                       va_list *_ap);
static void _pconv_f(long double cvt, _PFIELD *pfield, char **a_it);
static void _pconv_e(long double cvt, _PFIELD *pfield, char **a_it);
static void _pconv_g(long double cvt, _PFIELD *pfield, char **a_it);
static char *_fcpy(const char *tmpbuf, int dpt, int trail, int precision,
                   char **a_it);
static char *_ecpy(int exp, char letter, char **a_it);
static char *_mcpy(const char *tmpbuf, int dpt, int putdec, char **a_it);
static int _pproc_diouxp(_PFIELD *pfield, int *minus_flag, char **a_it,
                         va_list *_ap);
static unsigned long _getarg_diouxp(_PFIELD *pfield, va_list *_ap);
static int _ltostr(unsigned long cvt, int base, char conv, char **a_it);
static unsigned long _div(unsigned long cvt, int base);


/*****************************************************************************/
/* _PRINTFI -  Perform the main printf routine                               */
/*                                                                           */
/*    This function processes the format string.  It copies the format       */
/*    string into the result string until a '%' is encountered, where any    */
/*    flags, the field width, the precision, and the type of conversion are  */
/*    read in, stored in a structure called PFIELD, and passed to _SETFIELD, */
/*    where the actual conversion is processed.  This function returns       */
/*    the number of characters output.                                       */
/*                                                                           */
/*****************************************************************************/
int _printfi(char **_format, va_list _ap, void *_op, 
             int (*_outc)(char, void *), int (*_outs)(char *, void *))
{
   /*------------------------------------------------------------------------*/
   /* Local Variables                                                        */
   /*                                                                        */
   /*    *end     -  A pointer to the end of the format string               */
   /*    *pfield  -  A pointer to a structure _PFIELD, which stores all of   */
   /*                flags and parameters needed to perform a conversion.    */
   /*------------------------------------------------------------------------*/
   char     *end           =  *_format + strlen(*_format);
   int      count          =  0;
   _PFIELD  pfield;

   /*------------------------------------------------------------------------*/
   /* Iterate through the format string until the end of it is reached.      */
   /*------------------------------------------------------------------------*/
   while(*_format < end)
   {
      /*---------------------------------------------------------------------*/
      /* Initialize PFIELD.                                                  */
      /*---------------------------------------------------------------------*/
      pfield.flags     = 0;
      pfield.fwidth    = 0;
      pfield.precision = -1;
      pfield.conv      = 0;

      /*---------------------------------------------------------------------*/
      /* Copy the format string directly to the target string until a '%'    */
      /* is encountered.                                                     */
      /*---------------------------------------------------------------------*/
      for(; **_format != '%' && **_format != '\0'; 
          _outc(*((*_format)++), _op), count++);

      /*---------------------------------------------------------------------*/
      /* If the end of the format string has been reached, break out of the  */
      /* while loop.                                                         */
      /*---------------------------------------------------------------------*/
      if(! (**_format)) break;

      (*_format)++;                   /* Skip to the character after the '%' */

      /*---------------------------------------------------------------------*/
      /* Process the flags immediately after the '%'.                        */
      /*---------------------------------------------------------------------*/
      _pproc_fflags(&pfield, _format);

      /*---------------------------------------------------------------------*/
      /* Convert the field width and precision into numbers.                 */
      /*---------------------------------------------------------------------*/
      _pproc_fwp(&pfield, _format, &_ap);
 
      /*---------------------------------------------------------------------*/
      /* If the h, l, or L flag was specified, set the corresponding flag    */
      /* in pfield.                                                          */
      /*---------------------------------------------------------------------*/
      if(**_format == 'h' || **_format == 'l' || **_format == 'L')
      {
         _SET(&pfield, (**_format == 'h') ? _MFH : (**_format == 'l') ? 
              _MFL : _MFLD);
         (*_format)++;
      }
      /*---------------------------------------------------------------------*/
      /* Set the conversion character in pfield.                             */
      /*---------------------------------------------------------------------*/
      pfield.conv = *((*_format)++);

      /*---------------------------------------------------------------------*/
      /* If 'n' is the conversion specifier, process it in this function,    */
      /* since it is the only one that makes no conversions.  It just stores */
      /* the number of characters printed so far into the next argument.     */
      /* Otherwise, call _SETFIELD which performs the conversion.            */
      /*---------------------------------------------------------------------*/
      if(pfield.conv == 'n')
         switch (pfield.flags & (_MFL | _MFH))
         {
                           /* The 'l' flag was specified */
            case _MFL   :  *(va_arg(_ap, long*)) = (long)count;
                           break;

                           /* The 'h' flag was specified */
            case _MFH   :  *(va_arg(_ap, short*)) = (short)count;
                           break;

            default     :  *(va_arg(_ap, int*)) = (int)count;
                           break;

         }
      else if(pfield.conv == 's') 
         _pproc_str(&pfield, _op, &_ap, &count, _outs);   
      else
      {
         /*------------------------------------------------------------------*/
         /* Append the converted string to the result string, and reposition */
         /* its iterator, it2.                                               */
         /*------------------------------------------------------------------*/
         count += _outs(_setfield(&pfield, &_ap), _op);
      }
   }

   return (count);
}


/*****************************************************************************/
/* _PPROC_FFLAGS   -  Process the format flags for a conversion              */
/*                                                                           */
/*    This function takes the flags directly after the '%' and stores them   */
/*    in the _PFIELD structure PFIELD for later reference.                   */
/*                                                                           */
/*****************************************************************************/
static void _pproc_fflags(_PFIELD *pfield, char **it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int flags_done = 0;

   /*---------------------------------------------------------------------*/
   /* Read in all of the flags associated with this conversion, and set   */
   /* the corresponding flags in the PFIELD structure.                    */
   /*---------------------------------------------------------------------*/
   while(! flags_done)
      switch (**it)
      {
         case '-' :  _SET(pfield, _PFMINUS);
                     (*it)++;
                     break;   

         case '+' :  _SET(pfield, _PFPLUS);
                     (*it)++;
                     break;

         case ' ' :  _SET(pfield, _PFSPACE);
                     (*it)++;
                     break;

         case '#' :  _SET(pfield, _PFPOUND);
                     (*it)++;
                     break;

         case '0' :  _SET(pfield, _PFZERO);
                     (*it)++;
                     break;

         default  :  flags_done = 1;
      }

   return;
}


/*****************************************************************************/
/* _PPROC_FWP   -  Convert the field width and precision from the format     */
/*                 string into numbers.                                      */
/*                                                                           */
/*    This function reads the field and precision out of the format string   */
/*    and converts them into numbers that will be stored in the _PFIELD      */
/*    structure pointed to by PFIELD.  They will be needed for future        */
/*    reference.                                                             */
/*                                                                           */
/*****************************************************************************/
static void _pproc_fwp(_PFIELD *pfield, char **it, va_list *_ap)
{
   char tmpstr[10];
   char *tmpptr;

   /*------------------------------------------------------------------------*/
   /* If a '*' was given for the field width, use the next argument as       */
   /* the field width for the conversion.  Otherwise, copy the following     */
   /* numerical characters into a temporary string, and convert that         */
   /* string into an integer, which will be used for the field width.        */
   /*------------------------------------------------------------------------*/
   if(**it == '*')
   {
      pfield->fwidth = va_arg(*_ap, int);

      /*---------------------------------------------------------------------*/
      /* If the argument given for the field width is negative, treat it as  */
      /* if the '-' flag was used, and the field width was positive.         */
      /*---------------------------------------------------------------------*/
      if(pfield->fwidth < 0) 
      {
         pfield->fwidth = -(pfield->fwidth);
         _SET(pfield, _PFMINUS);
      }

      (*it)++;
   }
   else
   {
      /*---------------------------------------------------------------------*/
      /* Initialize the temporary string and iterator that will hold the     */
      /* field width temporarily.                                            */
      /*---------------------------------------------------------------------*/
      tmpptr = tmpstr;

      while((**it >= '0') && (**it <= '9')) *(tmpptr++) = *((*it)++);
      *tmpptr = '\0';

      if(*tmpstr != '\0') pfield->fwidth = atoi(tmpstr);
   }

   /*------------------------------------------------------------------------*/
   /* If a '.' appears as the next character, process the following          */
   /* characters as a precision.                                             */
   /*------------------------------------------------------------------------*/
   if(**it == '.')
   {
      (*it)++;

      /*---------------------------------------------------------------------*/
      /* Cancel any effects of the zero flag.                                */
      /*---------------------------------------------------------------------*/
      _UNSET(pfield, _PFZERO);

      /*---------------------------------------------------------------------*/
      /* If a '*' was given for the precision, use the next argument as      */
      /* the precision for the conversion.  Otherwise, copy the following    */
      /* numerical characters into a temporary string, and convert that      */
      /* string into an integer, which will be used for the precision.       */
      /*---------------------------------------------------------------------*/
      if(**it == '*')
      {
         pfield->precision = va_arg(*_ap, int);
         (*it)++;
      }
      else
      {
         /*------------------------------------------------------------------*/
         /* Initialize the temporary string and iterator that will hold      */
         /* the field width temporarily.                                     */
         /*------------------------------------------------------------------*/
         tmpptr = tmpstr;

         while((**it >= '0') && (**it <= '9'))  *(tmpptr++) = *((*it)++);
	 *tmpptr = '\0';

         if(*tmpstr != '\0') pfield->precision = atoi(tmpstr);
         else                pfield->precision = 0;
      }
   }
   return;
}


/*****************************************************************************/
/* _PPROC_STR  -  Processes the string conversion (%s)                       */
/*                                                                           */
/*    This function places all or a portion of the input string into the     */
/*    the temporary string.  It returns a zero, unless the input string had  */
/*    a length of zero.  In this case, a one is returned.                    */
/*                                                                           */
/*****************************************************************************/
static void _pproc_str(_PFIELD *pfield, void *_op, va_list *_ap, int *count,
                       int (*_outs)(char *, void *))
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  *strbuf;
   char  *tmpstr;
   char  *tmpptr;
   int   len, buflen;

   /*------------------------------------------------------------------------*/
   /* Get the next argument.                                                 */
   /*------------------------------------------------------------------------*/
   strbuf = va_arg(*_ap, char*);

   /*------------------------------------------------------------------------*/
   /* Handle NULL strings.                                                   */
   /*------------------------------------------------------------------------*/
   if(strbuf == NULL)
   {
      _outs("(null)", _op);
      return;
   }

   buflen = (pfield->precision >= 0 && pfield->precision < strlen(strbuf)) ?
            pfield->precision : strlen(strbuf);
   len = (pfield->fwidth > buflen) ? pfield->fwidth : buflen;
   *count += len;

   if(!(tmpstr = (char *)malloc(len + 1))) return;
   tmpptr = tmpstr;

   if(buflen < len && !_STCHK(pfield, _PFMINUS))
   {
      memset(tmpptr, ' ', (len - buflen));
      tmpptr += (len - buflen);  
   }

   strncpy(tmpptr, strbuf, buflen);
   tmpptr += buflen;

   if(buflen < len && _STCHK(pfield, _PFMINUS))
   {
      memset(tmpptr, ' ', (len - buflen));
      tmpptr += (len - buflen);
   }

   *(tmpstr + len) = '\0';

   _outs(tmpstr, _op);

   free(tmpstr);

   return;
}


/*****************************************************************************/
/* _SETFIELD   -  Performs conversions when the '%' is encountered           */
/*                                                                           */
/*    This function takes pfield, and calls the appropriate processing       */
/*    function for the conversion required in the _PFIELD structure.  It     */
/*    returns a pointer to the result string.                                */
/*                                                                           */
/*****************************************************************************/
static char *_setfield(_PFIELD *pfield, va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variable declarations, and a description of their use            */
   /*                                                                        */
   /*    FLD is a temporary string that will hold the conversion.  F_START   */
   /*    will be a pointer to the beginning of the field, and if a           */
   /*    field width was specified, F_END will be a pointer to the end of    */
   /*    the field.  This designated field is located at the beginning of    */
   /*    the string FLD.   A_END is a pointer to the end of the string FLD,  */
   /*    and this is where the primary conversion will take place.  Using    */
   /*    A_IT, an iterator beginning at the end of FLD, the number will be   */
   /*    written one digit at a time starting with the rightmost digit.      */
   /*    Using the pointer WHERE, the number in string form will be moved    */
   /*    to its appropriate place within the field after making adjustments  */
   /*    called for by various flags in the format specification (a minus    */
   /*    sign, leading zeros, etc.).  The string FLD will then be returned.  */
   /*                                                                        */
   /*    MINUS_FLAG is exactly what it says ( = 1 if number is negative).    */
   /*                                                                        */
   /*------------------------------------------------------------------------*/
   static   char fld[_ARSIZE];
            char *f_start           =  (char *)fld;
            char *f_end             =  f_start + pfield->fwidth;
            char *a_end             =  f_start + _ARSIZE -1; 
            char *a_it              =  a_end;
            char *where;
            int  minus_flag         = 0;
            int  plus_flag          = 0;

   /*------------------------------------------------------------------------*/
   /* Initialize the temporary string.  Then, since we are working from      */
   /* right to left, begin with the NULL character.                          */
   /*------------------------------------------------------------------------*/
   *(a_it--) = '\0'; 

   /*------------------------------------------------------------------------*/
   /* Call the appropriate processing function.                              */
   /*------------------------------------------------------------------------*/
   switch(pfield->conv)
   {
      case 'd' :
      case 'i' :
      case 'o' :
      case 'u' :
      case 'x' :
      case 'X' :  
      case 'p' :  _pproc_diouxp(pfield, &minus_flag, &a_it, _ap);
                  break;  

#ifndef NOFLOAT
      case 'g' :  
      case 'G' : 
      case 'e' :
      case 'E' :
      case 'f' :  _pproc_fge(pfield, &minus_flag, &a_it, _ap);
                  break;
#endif
  
      case 'c' :  *(a_it--) = va_arg(*_ap, int);
                  _UNSET(pfield, _PFPLUS);
                  break;

      case '%' :  strcpy(f_start, "%"); return((char *)fld);


   }

   plus_flag = (_STCHK(pfield, _PFPLUS) && SIGNED_CONV);

   /*------------------------------------------------------------------------*/
   /* If the number was negative, or the '+' flag was used, insert the sign. */
   /* Make sure unsigned conversions don't get a '+' sign.                   */
   /*------------------------------------------------------------------------*/
   if (minus_flag) *(a_it--) = '-';
   else if (plus_flag) *(a_it--) = '+';

   /*------------------------------------------------------------------------*/
   /* If the number was positive, the '+' flag was not used, and the ' '     */
   /* flag was used, insert a space.                                         */
   /*------------------------------------------------------------------------*/
   if(! minus_flag && ! plus_flag && _STCHK(pfield, _PFSPACE)) *(a_it--) = ' ';

   /*------------------------------------------------------------------------*/
   /* If the '-' flag was used or the resulting string is larger than the    */
   /* field, left justify the result in the array.  Otherwise right-justify  */
   /* it.                                                                    */
   /*------------------------------------------------------------------------*/
   where = (_STCHK(pfield, _PFMINUS) ||
           ((a_end - a_it) > pfield->fwidth)) ? f_start :
           (f_end - (a_end - a_it)+1);

   a_it = (char *)memccpy(where, a_it+1, '\0', _ARSIZE);

   /*------------------------------------------------------------------------*/
   /* If a resulting left-justified string is smaller than the field width,  */
   /* move the terminating NULL character to the end of the field.           */
   /*------------------------------------------------------------------------*/
   if(a_it <= f_end)
   {
      memset(a_it - 1, ' ', f_end - a_it + 1);
      *f_end = '\0';
   }

   /*------------------------------------------------------------------------*/
   /* If the '0' flag was used, and the resulting string is right-justified, */
   /* fill in the leading zeros.                                             */
   /*------------------------------------------------------------------------*/
   if(_STCHK(pfield, _PFZERO))
   {
      memset(f_start, '0', (where - f_start));

      /*---------------------------------------------------------------------*/
      /* Make sure any sign or leading space is moved to the left side of    */
      /* any leading zeros.                                                  */
      /*---------------------------------------------------------------------*/
      if((minus_flag || plus_flag || _STCHK(pfield, _PFSPACE)) &&
          where != f_start)
      {
         *f_start = *where;
         *where = '0';
      }
   }
   else
      memset(f_start, ' ', (where - f_start));

   /*------------------------------------------------------------------------*/
   /* Return the result string.                                              */
   /*------------------------------------------------------------------------*/
   return ((char *)fld);                     
}


#ifndef NOFLOAT
/*****************************************************************************/
/* _PPPROC_FGE   -  Process the conversion for f, g, G, e, and E             */
/*                                                                           */
/*    This function takes the structure PFIELD, which contains all of the    */
/*    flags and parameters to process the conversion, and it does this       */
/*    conversion, and stores the result in the string pointed to by          */
/*    *A_IT.                                                                 */
/*****************************************************************************/
static void _pproc_fge(_PFIELD *pfield, int *minus_flag, char **a_it, 
                       va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   long double cvt =  0;

   /*------------------------------------------------------------------------*/
   /* Determine what kind of argument is coming next, and read it into CVT.  */
   /*------------------------------------------------------------------------*/
   switch(_STCHK(pfield, _MFLD))
   {
      case  0  :  cvt = (double)va_arg((*_ap), double);
                  break;

      default  :  cvt = va_arg((*_ap), long double);

   }

   /*------------------------------------------------------------------------*/
   /* If CVT is negative, set the MINUS_FLAG and reverse the sign of CVT.    */
   /*------------------------------------------------------------------------*/
   if((*minus_flag = (cvt < 0)) != 0) cvt = -cvt;

   /*------------------------------------------------------------------------*/
   /* Call the proper conversion function                                    */
   /*------------------------------------------------------------------------*/
   switch(pfield->conv)
   {
      case 'f' :  _pconv_f(cvt, pfield, a_it);
                  break;
      case 'e' :
      case 'E' :  _pconv_e(cvt, pfield, a_it);
                  break;
      case 'g' :
      case 'G' :  _pconv_g(cvt, pfield, a_it);
   }
}


/*****************************************************************************/
/* _PCONV_F -  Perform the %f conversion                                     */
/*****************************************************************************/
static void _pconv_f(long double cvt, _PFIELD *pfield, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[100];
   int   dpt, 
         sign, 
         putdec;

   /*------------------------------------------------------------------------*/
   /* If no precision was specified, set it to 6.                            */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 6;

   /*------------------------------------------------------------------------*/
   /* Call the FCVT float to string function, then copy the fractional part, */
   /* determine whether or not a decimal point should be placed, and copy    */
   /* whole number part.                                                     */
   /*------------------------------------------------------------------------*/
   strcpy(tmpbuf, fcvt(cvt, pfield->precision, &dpt, &sign));
   _fcpy(tmpbuf, dpt, 1, pfield->precision, a_it);
   putdec = (dpt != (int)strlen(tmpbuf) || _STCHK(pfield, _PFPOUND)) ? 1 : 0;
   _mcpy(tmpbuf, dpt, putdec, a_it);
}


/*****************************************************************************/
/* _PCONV_E -  Perform the %e conversion                                     */
/*****************************************************************************/
static void _pconv_e(long double cvt, _PFIELD *pfield, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[100];
   int   dpt, 
         sign, 
         putdec, 
         exp      = 0;

   /*------------------------------------------------------------------------*/
   /* If no precision was specified, set it to 6.                            */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 6;

   /*------------------------------------------------------------------------*/
   /* Convert CVT to x.xxxe+xx form, keeping the exponent in EXP.            */
   /*------------------------------------------------------------------------*/
   if(cvt)
   {
      for(;cvt < 1; cvt *= 10, exp--);
      for(;cvt >= 10; cvt /= 10, exp++);
   }

   /*------------------------------------------------------------------------*/
   /* Call the FCVT float to string function, copy the exponent part, the    */
   /* fractional part, then determine whether or not a decimal point should  */
   /* be placed, and copy the whole number part.                             */
   /*------------------------------------------------------------------------*/
   strcpy(tmpbuf, fcvt(cvt, pfield->precision, &dpt, &sign));
   if(dpt==2) /* fcvt() might have rounded the number */
   {
       dpt--; exp++; tmpbuf[strlen(tmpbuf)-1] = 0;
   }
   _ecpy(exp, pfield->conv, a_it);
   _fcpy(tmpbuf, dpt, 1, pfield->precision, a_it);
   putdec = (dpt != (int)strlen(tmpbuf) || _STCHK(pfield, _PFPOUND)) ? 1 : 0;
   _mcpy(tmpbuf, dpt, putdec, a_it);
}


/*****************************************************************************/
/* _PCONV_G -  Perform the %g conversion                                     */
/*****************************************************************************/
static void _pconv_g(long double cvt, _PFIELD *pfield, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[100];
   char  *check;
   int   dpt, 
         sign, 
         putdec, 
         exp         = 0, 
         change_test = 0;

   /*------------------------------------------------------------------------*/
   /* If the precision was given as 0, set it to one.                        */
   /*------------------------------------------------------------------------*/
   if(pfield->precision == 0) pfield->precision = 1;

   /*------------------------------------------------------------------------*/
   /* If no precision was specified, set it to 6.                            */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 6;

   strcpy(tmpbuf, ecvt((double)cvt, pfield->precision, &dpt, &sign));

   /*------------------------------------------------------------------------*/
   /* If the exponent is less than -4, or greater than or equal to the       */
   /* precision, convert the number as a %e conversion.  Otherwise convert   */
   /* it as a %f conversion.                                                 */
   /*------------------------------------------------------------------------*/
   if(dpt < -3 || dpt > pfield->precision)
   {
      for(;dpt > 1; dpt--, exp++);
      for(;dpt < 1; dpt++, exp--);

      _ecpy(exp, pfield->conv-2, a_it);
   }

   /*------------------------------------------------------------------------*/
   /* Copy the fractional part of the number.  CHANGE_TEST will be set if    */
   /* there was a fractional part, otherwise it will remain a zero.          */
   /*------------------------------------------------------------------------*/
   check = *a_it;
   _fcpy(tmpbuf, dpt, (_STCHK(pfield, _PFPOUND)) ? 1 : 0, pfield->precision,
         a_it);
   change_test = (check != *a_it);

   /*------------------------------------------------------------------------*/
   /* If the '#' flag was used, or there was a fractional part to the number */
   /* a decimal point will be placed.                                        */
   /*------------------------------------------------------------------------*/
   putdec = (_STCHK(pfield, _PFPOUND) || change_test) ? 1 : 0;

   _mcpy(tmpbuf, dpt, putdec, a_it);

}


/*****************************************************************************/
/* _FCPY -  Copy the fraction part of a float to a string                    */
/*****************************************************************************/
static char *_fcpy(const char *tmpbuf, int dpt, int trail, int precision, 
                   char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   i;
   char  *tmpptr = (char *)tmpbuf + strlen(tmpbuf) -1;

   /*------------------------------------------------------------------------*/
   /* Fill all unused precision spaces with zeros.                           */
   /*------------------------------------------------------------------------*/
   for(i = 0; i < precision && dpt > (int)strlen(tmpbuf) && trail; i++)
      *((*a_it)--) = '0';
 
   /*------------------------------------------------------------------------*/
   /* Copy the fractional part of the float into the string.                 */
   /*------------------------------------------------------------------------*/
   if(dpt < (int)strlen(tmpbuf) && dpt >= 0)
   {
      i = (int)strlen(tmpbuf) - dpt;

      /*---------------------------------------------------------------------*/
      /* Skip trailing zeros if TRAIL is not set.                            */
      /*---------------------------------------------------------------------*/
      if(! trail) for(; i > 0 && *tmpptr == '0'; tmpptr--, i--);

      for(; i > 0; tmpptr--, i--) *((*a_it)--) = *tmpptr;

   }

 
   /*------------------------------------------------------------------------*/
   /* Place any leading fractional zeros if necessary.                       */
   /*------------------------------------------------------------------------*/
   if(dpt < 0)
   {
      for(i = strlen(tmpbuf); i > 0; tmpptr--, i--) *((*a_it)--) = *tmpptr;
      for(i = -dpt; i > 0; i--) *((*a_it)--) = '0';
   }

   return (*a_it);
}


/*****************************************************************************/
/* _ECPY -  Copy the "e+xx" part of a float to a string                      */
/*****************************************************************************/
static char *_ecpy(int exp, char letter, char **a_it)
{
   _ltostr((exp > 0) ? exp : -exp, 10, 'd', a_it);
   if(exp < 10 && exp > -10) *((*a_it)--) = '0';
   *((*a_it)--) = (exp < 0) ? '-' : '+';
   *((*a_it)--) = letter;

   return (*a_it);
}


/*****************************************************************************/
/* _MCPY -  Copy the whole number part of a float to a string                */
/*****************************************************************************/
static char *_mcpy(const char *tmpbuf, int dpt, int putdec, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   i;
   char  *tmpptr = NULL;

   /*------------------------------------------------------------------------*/
   /* If the number has both a whole number part and a fractional part,      */
   /* position TMPPTR to the last character of the whole number.             */
   /*------------------------------------------------------------------------*/
   if(dpt > 0 && dpt <= (int)strlen(tmpbuf)) tmpptr = (char *)tmpbuf + dpt -1;

   /*------------------------------------------------------------------------*/
   /* Place a decimal point if PUTDEC is set.                                */
   /*------------------------------------------------------------------------*/
   if(putdec) *((*a_it)--) = '.';

   /*------------------------------------------------------------------------*/
   /* Place any whole number trailing zeros.                                 */
   /*------------------------------------------------------------------------*/
   for(i = dpt; i > (int)strlen(tmpbuf); i--) *((*a_it)--) = '0';

   /*------------------------------------------------------------------------*/
   /* Copy the rest of the whole number.                                     */
   /*------------------------------------------------------------------------*/
   if(i > 0) for(; tmpptr >= tmpbuf; tmpptr--) *((*a_it)--) = *tmpptr;
   else *((*a_it)--) = '0';

   return (*a_it);
}
#endif


/*****************************************************************************/
/* _PPROC_DIOUXP   -  Process the conversion for d, i, o, u, x, and p        */
/*                                                                           */
/*    This function takes the structure PFIELD, which contains all of the    */
/*    flags and parameters to process the conversion, and it does this       */
/*    conversion, and stores the result in the string pointed to by          */
/*    *A_IT.                                                                 */
/*                                                                           */
/*****************************************************************************/
static int _pproc_diouxp(_PFIELD *pfield, int *minus_flag, char **a_it, 
                         va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int digits =  0;
   int base   = 10;
   unsigned long cvt;

   /*------------------------------------------------------------------------*/
   /* If no precision was given, set it to 1.                                */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 1; 

   /*------------------------------------------------------------------------*/
   /* Set the base of the number by the type of conversion specified.        */
   /*------------------------------------------------------------------------*/
   switch(pfield->conv)
   {
      case 'p' :
      case 'x' :
      case 'X' :  base = 16;
                  break;

      case 'o' :  base = 8;
                  break;

      default  :
      case 'u' :
      case 'd' :
      case 'i' :  base = 10;
  	          break;
   }  

   /*------------------------------------------------------------------------*/
   /* Get the next argument.                                                 */
   /*------------------------------------------------------------------------*/
   cvt = _getarg_diouxp(pfield, _ap);

   /*------------------------------------------------------------------------*/
   /* If the precision is 0, and the number is 0, do nothing and return 1.   */
   /*------------------------------------------------------------------------*/
   if(pfield->precision == 0 && cvt == 0) return 1;

   /*------------------------------------------------------------------------*/
   /* If the number is signed and negative, set the minus sign flag, and     */
   /* multiply the number by -1.                                              */
   /*------------------------------------------------------------------------*/
   if((pfield->conv == 'd' || pfield->conv == 'i')
      && ((long)cvt < 0))
   {
      *minus_flag = 1;
      cvt = (long)cvt * -1;
   }

   /*------------------------------------------------------------------------*/
   /* Call the function to convert the number to a string, and add the       */
   /* total number of digits assigned into DIGITS.                           */
   /*------------------------------------------------------------------------*/
   digits += _ltostr(cvt, base, pfield->conv, a_it);

   /*------------------------------------------------------------------------*/
   /* Fill in the remainder of the precision with zeros.                     */
   /*------------------------------------------------------------------------*/
   while(digits++ < pfield->precision) *((*a_it)--) = '0';


   /*------------------------------------------------------------------------*/
   /* If the "#" flag was used in the X or x conversion, prefix a "0x" or    */
   /* "0X" to the hexadecimal number.                                        */
   /*------------------------------------------------------------------------*/
   if((pfield->conv == 'x' || pfield->conv == 'X') && _STCHK(pfield, _PFPOUND))
   {
      *((*a_it)--) = pfield->conv;
      *((*a_it)--) = '0';
   }

   /*------------------------------------------------------------------------*/
   /* If the "#' flag was used in the o conversion, prefix a "0" to the      */
   /* octal number.                                                          */
   /*------------------------------------------------------------------------*/
   if(pfield->conv == 'o' && _STCHK(pfield, _PFPOUND)) *((*a_it)--) = '0';

   return (0);

}


/*****************************************************************************/
/* _GETARG_DIOUXP -  Get the argument for a d, i, o, u, x, or p conversion   */
/*                                                                           */
/*    This function takes the next argument off the argument list, after     */
/*    determining what kind of argument it is.  It decides this by checking  */
/*    to see if the 'h' or the 'l' flag was used.  It returns the next       */
/*    argument.                                                              */
/*****************************************************************************/
static unsigned long _getarg_diouxp(_PFIELD *pfield, va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned long cvt = 0;

   /*------------------------------------------------------------------------*/
   /* Get the number from the next argument.  Determine what kind of         */
   /* argument by checking for the h or l flag in the format specification.  */
   /*------------------------------------------------------------------------*/
   switch(_STCHK(pfield, (_MFH | _MFL)))
   {
      case _MFH   :  switch(pfield->conv)
                     {
                        case 'd' :
                        case 'i' : cvt = va_arg(*_ap, int);
                                   break;

                        case 'p' :
                        case 'o' :
                        case 'u' :
                        case 'x' :
                        case 'X' : cvt = va_arg(*_ap, unsigned int);
                     }
                     break;

      case _MFL   :  switch(pfield->conv)
                     {
                        case 'd' :
                        case 'i' : cvt = va_arg(*_ap, long int);
                                   break;

                        case 'p' : 
                        case 'o' :
                        case 'u' :
                        case 'x' :
                        case 'X' : cvt = va_arg(*_ap, unsigned long int);
                     }
                     break;
   
      default     :  switch(pfield->conv)
                     {
                        case 'd' :
                        case 'i' : cvt = va_arg(*_ap, int);;
                                   break;
 
                        case 'p' :
                        case 'o' :
                        case 'u' :
                        case 'x' :
                        case 'X' : cvt = va_arg(*_ap, unsigned int);
                     }
                     break;
   
   }

   return (cvt);
}


/*****************************************************************************/
/* _LTOSTR  -  Convert an integer to a string of up to base 16               */
/*                                                                           */
/*    This function takes an unsigned long integer, converts it to a string  */
/*    which is pointed to by *A_IT.  The result will also be converted to    */
/*    a base corresponding to the variable base.                             */
/*                                                                           */
/*****************************************************************************/
static int _ltostr(unsigned long cvt, int base, char conv, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local Variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned long  quot,
                  rem;
            char  *bnum = "0123456789abcdef0123456789ABCDEF";

   /*------------------------------------------------------------------------*/
   /* The number CVT will be converted to a string by taking the remainder   */
   /* of a division of it by its base, and converting it to a character.     */
   /* The number CVT is then set equat to itself divided by its base, and    */
   /* this continues until CVT is 0.                                         */
   /*------------------------------------------------------------------------*/

   if(! cvt) *((*a_it)--) = '0';

   while(cvt)
   {
      quot = _div(cvt, base);
      rem = cvt - (quot * base);

      if(conv == 'X') rem += 16;

      *((*a_it)--) = bnum[rem];
      cvt = quot;
   }

   return (strlen(*a_it+1));
}


/*****************************************************************************/
/* _DIV  -  Divide two integers                                              */
/*                                                                           */
/*    This function takes an unsigned long, and divides it by an integer.    */
/*    This function exists because when an integer is greater than the       */
/*    largest signed long integer, the conventional '/' operator overflows.  */
/*    This function is used by _LTOSTR when it is converting an unsigned int */
/*    to a string.                                                           */
/*                                                                           */
/*****************************************************************************/
static unsigned long _div(unsigned long cvt, int base)
{

   /*------------------------------------------------------------------------*/
   /* If the '/' operator will not overflow, use it.                         */
   /*------------------------------------------------------------------------*/

   if(cvt <= LONG_MAX) return (cvt / base);

   /*------------------------------------------------------------------------*/
   /* In the case that the base is 8 or 16, the division can be done using   */
   /* bit operations.  For base 10, the numerator and the divisor are        */
   /* converted into double floating point numbers, where the '/' operator   */
   /* will work properly.                                                    */
   /*------------------------------------------------------------------------*/

   else  
      switch(base)
      {
         case  8  :  
         case 16  :  while((base >>=1) > 0) cvt >>=1; break;
         case 10  :  cvt >>= 1;
                     cvt /= 5;
                     break;
      }

   return (cvt);
}

_scanfi.c/      925421664   0     0     0       32998     `
/*****************************************************************************/
/*  _SCANFI.C V5.11                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the main routines that all three variations of the  */
/*    scanf function use.  The main function in the file is _scanfi, and     */
/*    the other functions here are called by it.                             */
/*                                                                           */
/* FUNCTIONS:                                                                */
/*    _scanfi        -  The main scanf handling routine                      */
/*    _sget_conv     -  Read the format flags into the _SFIELD pointer sfield*/
/*    _sget_scanset  -  Read in the scanset from the format statement        */
/*    _sproc_int     -  Read an integer string into a temporary string       */
/*    _sproc_float   -  Read a float string into a temporary string          */
/*    _sproc_str     -  Copy a string from the input source to a temporary   */
/*                      string                                               */
/*    _sproc_lb      -  Process the %[ conversion                            */
/*    _sset_arg      -  Assign the converted value to the next argument      */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

static int _sget_conv(char **_format, _SFIELD *sfield);
static int _sget_scanset(_SFIELD *sfield, char **_format);
static int _sproc_int(int w_counter, char (*_inpchar)(void **inp),
                       void (*_uninpchar)(void **inp, char outchar),
                       char *tmpptr, char conv, void **inp, int *num_read);
static int _sproc_float(int w_counter, char (*_inpchar)(void **inp),
                         void (*_uninpchar)(void **inp, char outchar),
                         char *tmpptr, char conv, void **inp, int *num_read);
static int _sproc_str(int w_counter, char (*_inpchar)(void **inp),
                       void (*_uninpchar)(void **inp, char outchar),
                       char *tmpptr, char conv, void **inp, int *num_read);
static int _sproc_lb(char (*_inpchar)(void **inp),
                      void (*_uninpchar)(void **inp, char outchar),
                      char *tmpptr, _SFIELD *sfield, void **inp, int *num_read);
static void _sset_arg(_SFIELD *sfield, va_list *_ap, char *tmpbuf);






/*****************************************************************************/
/* _SCANFI  -  The main scanf handling routine                               */
/*                                                                           */
/*    This function parses all non-conversion characters in the format       */
/*    string, passes control to the appropriate function when a '%' is       */
/*    encountered, then calls _SSET_ARG, which assignes the result to the    */
/*    next argument.                                                         */
/*                                                                           */
/*****************************************************************************/
int _scanfi(void *inp, const char *_format, va_list _ap, 
            int (*_chkmbc)(void **inp, char **_format, int *num_read),
            char (*_inpchar)(void **inp), 
            void (*_uninpchar)(void **inp, char outchar))
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   _SFIELD  sfield;
   char     tmpbuf[256],
            *tmpptr,
            inchar,
            *f_ptr         = (char *)_format;
   int      num_assigned   =  0,
            num_read       =  0,
            stat           =  0;

   /*------------------------------------------------------------------------*/
   /* If the first character in the format string is a white space character */
   /* parse the format string until a non-white space character is found.    */
   /* Do the same for the input, but put the first non-white space character */
   /* back onto the input stream when finished.                              */
   /*------------------------------------------------------------------------*/
   if (isspace(*f_ptr))
   {
      for(;isspace(*f_ptr);f_ptr++);

      inchar = _inpchar(&inp);
      num_read++;

      for(;isspace(inchar); inchar = _inpchar(&inp), num_read++);

      _uninpchar(&inp, inchar);
      num_read--;
   }

   while(1)
   {
      /*---------------------------------------------------------------------*/
      /* Initialize sfield                                                   */
      /*---------------------------------------------------------------------*/
      memset(&sfield, 0, sizeof(_SFIELD));
      sfield.fwidth = -1;

      /*---------------------------------------------------------------------*/
      /* Call _chkmbc to compare the format string to the input.  If a       */
      /* mismatch occurs, return an EOF, if the end of the format string     */
      /* is reached, return the number of arguments assigned.  Otherwise     */
      /* a '%' has been encountered, so call _sget_conv to process it.       */
      /*---------------------------------------------------------------------*/
      switch(_chkmbc(&inp, &f_ptr, &num_read))
      {
         case  EOF   : return (EOF);
   
         case  0     : return (num_assigned);
   
         case  1     :  _sget_conv(&f_ptr, &sfield);
   
      }
   
      tmpptr = tmpbuf;

      /*---------------------------------------------------------------------*/
      /* Unless the conversion specifier is a [, c, or n, skip to the next   */
      /* non-white space character in the input.                             */
      /*---------------------------------------------------------------------*/
      if (sfield.conv != '[' && sfield.conv != 'c' && sfield.conv != 'n')
      {
         inchar = _inpchar(&inp);
         num_read++;
    
         for(;isspace(inchar); inchar = _inpchar(&inp), num_read++);
    
         _uninpchar(&inp, inchar);
         num_read--;
      }

      /*---------------------------------------------------------------------*/
      /* The flags have been set in sfield, so process the conversion by     */
      /* calling the appropriate function.                                   */
      /*---------------------------------------------------------------------*/
      switch(sfield.conv)
      {
         case  'X'   :  sfield.conv = 'x';
         case  'i'   :
         case  'p'   :  
         case  'x'   :
         case  'u'   :
         case  'o'   :
         case  'd'   :  stat = _sproc_int(sfield.fwidth, _inpchar, _uninpchar, 
                                         tmpptr, sfield.conv, &inp, &num_read); 
                        break;
         case  'f'   :
         case  'e'   :
         case  'E'   :
         case  'g'   :
         case  'G'   :  stat = _sproc_float(sfield.fwidth, _inpchar, _uninpchar,
                                     tmpptr, sfield.conv, &inp, &num_read);
                        break;

         case  'c'   :  
         case  's'   : {
                          char *stptr = (sfield.flags & _SFSTAR) ?
                                         NULL : va_arg(_ap, char*);

                          stat = _sproc_str(sfield.fwidth, _inpchar, _uninpchar,
                                     stptr, sfield.conv, &inp, &num_read);
                       }
                       stat = (stat != EOF);
                       if (!(sfield.flags & _SFSTAR) && stat) num_assigned++;
                       break;

         case  '['   :  stat = _sproc_lb(_inpchar, _uninpchar, tmpptr, &sfield,
                                         &inp, &num_read);

      }

      stat = (stat != EOF);

      /*---------------------------------------------------------------------*/
      /* Now, call the function to handle the actual assignment, or if there */
      /* is no assignment to take place, process it here.                    */
      /*---------------------------------------------------------------------*/
      switch(sfield.conv)
      {
         case  'i'   :
         case  'd'   :  
         case  'x'   :
         case  'u'   :
         case  'o'   :  
         case  'p'   : 
         case  'e'   :
         case  'f'   :
         case  'g'   :
         case  'E'   :
         case  'G'   :  _sset_arg(&sfield, &_ap, tmpbuf);
                        if ((!(sfield.flags & _SFSTAR)) && stat) num_assigned++;
                        break;
 
         case  'n'   :  if (!(sfield.flags & _SFSTAR))
                           switch(sfield.flags & (_MFH | _MFL))
                           {
                              case  _MFH  :  *(va_arg(_ap, short int*)) =
                                             (short int)num_read;
                                             break;
 
                              case _MFL   :  *(va_arg(_ap, long int*)) =
                                             (long int)num_read;
                                             break;
 
                              default     :  *(va_arg(_ap, int*)) =
                                             num_read;
                                             break;
                           }
                        break;

         case  '%'   :  inchar = _inpchar(&inp);
                        if (inchar != '%') return (EOF);
                        else num_read++;
                        break;
                              
         case  '['   :  if ((!(sfield.flags & _SFSTAR)) && stat)
                        {
                           strcpy(va_arg(_ap, char *), tmpbuf);
                           num_assigned++;
                        }
      }
   }

}






/*****************************************************************************/
/* _SGET_CONV  -  Read the format flags into the _SFIELD pointer sfield      */
/*                                                                           */
/*    This function reads the characters directly after the '%' character,   */
/*    and stores them as flags in sfield, a pointer to a _SFIELD structure.  */
/*    These flags will later be used to process the conversion.              */
/*                                                                           */
/*****************************************************************************/
static int _sget_conv(char **_format, _SFIELD *sfield)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[8],
         *tmpptr     =  tmpbuf,
         *strend     =  (*_format) + strlen(*_format);

   (*_format)++;                        /* Go to the character after the '%' */

   /*------------------------------------------------------------------------*/
   /* If the next character in the format statement is a '*', set the        */
   /* _SFSTAR flag in sfield                                                 */
   /*------------------------------------------------------------------------*/
   if (**_format == '*')
   {
      _SET(sfield, _SFSTAR);
      (*_format)++;
   }
 
   /*------------------------------------------------------------------------*/
   /* If numerical characters follow, read them into a temporary string,     */
   /* convert it into a number, and store it as the field width in sfield    */
   /*------------------------------------------------------------------------*/
   for(;**_format >= '0' && **_format <= '9'; *(tmpptr++) = *((*_format)++));
   *tmpptr = '\0';
 
   if (strlen(tmpbuf)) sfield->fwidth = atoi(tmpbuf);
 
   /*------------------------------------------------------------------------*/
   /* Set the h, l, or L flags if they were specified                        */
   /*------------------------------------------------------------------------*/
   switch(**_format)
   {
      case  'h'   :  _SET(sfield, _MFH);
                     (*_format)++;
                     break;
 
      case  'l'   :  _SET(sfield, _MFL);
                     (*_format)++;
                     break;
  
      case  'L'   :  _SET(sfield, _MFLD);
                     (*_format)++;
                     break;
   }

   /*------------------------------------------------------------------------*/
   /* Read in the last character as the conversion specifier                 */
   /*------------------------------------------------------------------------*/
   sfield->conv = *((*_format)++);

   /*------------------------------------------------------------------------*/
   /* For the '[' conversion, read in the scanset.  Return an EOF if         */
   /* _SGET_SCANSET fails.                                                   */
   /*------------------------------------------------------------------------*/
   if ((sfield->conv == '[') && _sget_scanset(sfield, _format)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If we read past the end of the format string, return an error          */
   /*------------------------------------------------------------------------*/
   if (*_format > strend) return (EOF);
   else return (0);
}






/*****************************************************************************/
/* _SGET_SCANSET  -  Read in the scanset from the format statement           */
/*                                                                           */
/*    This function is called when the '[' conversion specifier has been     */
/*    encountered.  It reads in the scanset from the format statement,       */
/*    and stores it in sfield for later reference during the conversion.     */
/*                                                                           */
/*****************************************************************************/
static int _sget_scanset(_SFIELD *sfield, char **_format)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  *tmpptr  =  sfield->scanset;

   if (**_format == '^')
   {
      _SET(sfield, _SFCIRC);
      (*_format)++;
   }

   if (**_format == ']') *(tmpptr++) = *((*_format)++);

   while(**_format != ']' && **_format != '\0') *(tmpptr++) = *((*_format)++);

   *tmpptr = '\0';
   if (**_format == ']') (*_format)++;
   if (**_format == '\0') return (EOF);

   return(0);
}






/*****************************************************************************/
/* _SPROC_INT  -  Read an integer string into a temporary string             */
/*                                                                           */
/*    This function takes the next integer in character form from the        */
/*    current input source, and copies it into a temporary string, where     */
/*    it can later be converted into a numerical value.                      */
/*                                                                           */
/*****************************************************************************/
static int _sproc_int(int w_counter, char (*_inpchar)(void **inp), 
                       void (*_uninpchar)(void **inp, char outchar), 
                       char *tmpptr, char conv, void **inp, int *num_read) 
{
   /*------------------------------------------------------------------------*/
   /* Note: w_counter is a parameter that holds the field width.  When       */
   /*       the number of digits specified by w_counter has been read from   */
   /*       input, the function finishes.  w_counter is checked before each  */
   /*       read to make sure that it is not equal to zero, and it is        */
   /*       decremented after each read.  If no field width was specified,   */
   /*       w_counter will be equal to -1, in which case it will never       */
   /*       equal zero, and the function will read from input until it       */
   /*       encounters the first invalid character.                          */
   /*------------------------------------------------------------------------*/

   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char inchar;
   int bnum_read = *num_read;

   /*------------------------------------------------------------------------*/
   /* Read in the next character                                             */
   /*------------------------------------------------------------------------*/
   inchar = _inpchar(inp);
   (*num_read)++;

   /*------------------------------------------------------------------------*/
   /* Accept the next character if it is a sign for the number               */
   /*------------------------------------------------------------------------*/
   if ((inchar == '+' || inchar == '-') && w_counter != 0)
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }


   /*------------------------------------------------------------------------*/
   /* Accept a leading '0' for an octal number, or a '0x' or '0X' for a      */
   /* hexadecimal number.                                                    */
   /*------------------------------------------------------------------------*/
   if ((conv == 'o' || conv == 'i' || conv =='x' || conv == 'p') && 
      w_counter != 0 && inchar == '0')
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }

   if ((conv == 'x' || conv == 'p' || conv == 'i') && w_counter != 0 &&
     (inchar == 'x' || inchar == 'X'))
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }

   /*------------------------------------------------------------------------*/
   /* Accept digits 0-9 for decimal numbers, or 0-F for hexadecimal numbers  */
   /*------------------------------------------------------------------------*/
   while(((inchar >= '0' && inchar <= '9') || 
          ((conv == 'x' || conv == 'p' || conv == 'i') &&
          ((inchar >= 'A' && inchar <= 'F') ||
          (inchar >= 'a' && inchar <= 'f')))) && w_counter != 0)
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }

   _uninpchar(inp, inchar);
   (*num_read)--;

   *tmpptr = '\0';

   if (bnum_read == *num_read) return(EOF);
   return(1);
}






/*****************************************************************************/
/* _SPROC_FLOAT   -  Read a float string into a temporary string             */
/*                                                                           */
/*    This function takes the next float in character form from the          */
/*    current input source, and copies it into a temporary string, where     */
/*    it can later be converted into a numerical value.                      */
/*                                                                           */
/*****************************************************************************/
static int _sproc_float(int w_counter, char (*_inpchar)(void **inp), 
                         void (*_uninpchar)(void **inp, char outchar), 
                         char *tmpptr, char conv, void **inp, int *num_read)
{
   /*------------------------------------------------------------------------*/
   /* Note: w_counter is a parameter that holds the field width.  When       */
   /*       the number of digits specified by w_counter has been read from   */
   /*       input, the function finishes.  w_counter is checked before each  */
   /*       read to make sure that it is not equal to zero, and it is        */
   /*       decremented after each read.  If no field width was specified,   */
   /*       w_counter will be equal to -1, in which case it will never       */
   /*       equal zero, and the function will read from input until it       */
   /*       encounters the first invalid character.                          */
   /*------------------------------------------------------------------------*/
 
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char  inchar;
   int          invalid   = 0;
   int          bnum_read = *num_read;
   int          dec_flag  =  0;
   int          e_flag    =  0;

   /*------------------------------------------------------------------------*/
   /* Read in the next character                                             */
   /*------------------------------------------------------------------------*/
   inchar = _inpchar(inp);
   (*num_read)++;

   /*------------------------------------------------------------------------*/
   /* Accept the next character if it is a sign                              */
   /*------------------------------------------------------------------------*/
   if ((inchar == '+' || inchar == '-') && w_counter != 0)
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }
 
   /*------------------------------------------------------------------------*/
   /* Accept the next character if it is a numerical digit.                  */
   /* The characters '.', 'e', 'E', '+', and '-' are accepted under the      */
   /* following conditions:                                                  */
   /*                                                                        */
   /* '.'         :  a '.', an 'e', or an 'E' has not yet been encountered   */
   /* 'e' or 'E'  :  neither of these characters have been encounterd yet    */
   /* '+' or '-'  :  If the last character read was an 'E' or an 'e'         */
   /*------------------------------------------------------------------------*/
   while((inchar >= '0' && inchar <= '9') || inchar == '.' || inchar == 'e'
          || inchar == 'E' || inchar == '+' || inchar == '-')
   {

      switch(inchar)
      {
         case  '.'   :  if (dec_flag || e_flag) { invalid = 1; break; } 
                        else dec_flag = 1;
                        break;

         case  'e'   :
         case  'E'   :  if (e_flag) { invalid = 1; break; }
                        else e_flag = 1;
                        break;

         case  '+'   :  
         case  '-'   :  if (*(tmpptr-1) != 'E' && *(tmpptr-1) != 'e')
                        { invalid = 1; break; }
      }

      if (invalid) break;
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      if (inchar != EOF) (*num_read)++;
      w_counter--;
   }

   _uninpchar(inp, inchar);
   (*num_read)--;

   *tmpptr = '\0';

   if (bnum_read == *num_read) return(EOF);
   return(1);
}






/*****************************************************************************/
/* _SPROC_STR  -  Copy a string from the input source to a temporary string  */
/*                                                                           */
/*    This function takes a string from the input source, and copies it      */
/*    into a temporary string, to be later assigned to a scanf argument.     */
/*                                                                           */
/*****************************************************************************/
static int _sproc_str(int w_counter, char (*_inpchar)(void **inp), 
                       void (*_uninpchar)(void **inp, char outchar), 
                       char *tmpptr, char conv, void **inp, int *num_read)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char inchar;
   int bnum_read = *num_read;

   /*------------------------------------------------------------------------*/
   /*	If no precision was given for the %c conversion, set it to one.        */
   /*------------------------------------------------------------------------*/
   if ((conv == 'c') && (w_counter < 0)) w_counter = 1;

   /*------------------------------------------------------------------------*/
   /* Read in the next character, then while that character is not a white   */
   /* space character, a null terminator, an EOF character, and the field    */
   /* width has not been exceeded, copy it to the temporary string, and      */
   /* get another character.                                                 */
   /*------------------------------------------------------------------------*/
   inchar = _inpchar(inp);
   (*num_read)++;

   while((conv == 'c' || !isspace(inchar)) && inchar != '\0' &&
         inchar != EOF && w_counter--)
   { 
      if (tmpptr) *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
   }
   
   /*------------------------------------------------------------------------*/
   /* The %s conversion specifies that a null terminator be placed at the    */
   /* end of the conversion.                                                 */
   /*------------------------------------------------------------------------*/
   if (conv == 's' && tmpptr) *tmpptr = '\0';

   _uninpchar(inp, inchar);
   (*num_read)--;

   if (bnum_read == *num_read) return(EOF);
   return(1);
}






/*****************************************************************************/
/* _SPROC_LB   -  Process the %[ conversion                                  */
/*                                                                           */
/*    This function copies characters from the input stream into a           */
/*    temporary string until it satisfies the field width, or encounters a   */
/*    character that is not in the scanset.  The scanset is defined as the   */
/*    characters passed between the left and right brackets.  If a '^' is    */
/*    first character after the left bracket, then the scanset is every      */
/*    character that is not listed between the two brackets.                 */
/*                                                                           */
/*****************************************************************************/
static int _sproc_lb(char (*_inpchar)(void **inp), 
                      void (*_uninpchar)(void **inp, char outchar),
                      char *tmpptr, _SFIELD *sfield, void **inp, int *num_read)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char  inchar;
   int          bnum_read = *num_read;
   int          w_counter =  sfield->fwidth;
   int          test;

   inchar = _inpchar(inp);
   (*num_read)++;

   for (; w_counter != 0 && inchar != EOF; w_counter--)
   {
      test = (int)strrchr(sfield->scanset, inchar);
      if (_STCHK(sfield, _SFCIRC)) test = !test;
             
      if (test)
      {
         *(tmpptr++) = inchar;
         inchar = _inpchar(inp);
         (*num_read)++;
      }
      else
      {
         _uninpchar(inp, inchar);
         (*num_read)--;
         break;
      }
   }

   *tmpptr = '\0';

   if (bnum_read == *num_read) return(EOF);
   return(1);
}






/*****************************************************************************/
/* _SSET_ARG   -  Assign the converted value to the next argument            */
/*                                                                           */
/*    This function takes a pointer to the result conversion string, and     */
/*    assigns it to the next argument.  The type of argument to be assigned  */
/*    is determined by the conversion specifier, and the h, l, or L flags    */
/*    if they were used.                                                     */
/*                                                                           */
/*****************************************************************************/
static void _sset_arg(_SFIELD *sfield, va_list *_ap, char *tmpbuf)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int base;

   /*------------------------------------------------------------------------*/
   /* Do the assignment only if the result string has a length greater than  */
   /* zero, and the '*' flag was not used                                    */
   /*------------------------------------------------------------------------*/
   if (tmpbuf[0] != '\0' && !_STCHK(sfield, _SFSTAR))
      switch(sfield->conv)
      {
         case  'i'   :
         case  'd'   :  base = (sfield->conv == 'd') ? 10 : 0;
   
                        switch(_STCHK(sfield, (_MFH | _MFL)))
                        {
                           case  _MFH  :  *(va_arg(*_ap, short int*)) =
                                          (short int)strtol(tmpbuf, NULL,
                                          base);
                                          break;

                           case _MFL   :  *(va_arg(*_ap, long int*)) =
                                          strtol(tmpbuf, NULL, base);
                                          break;

                           default     :  *(va_arg(*_ap, int*)) =
                                          (int)strtol(tmpbuf, NULL, base);
                                          break;
                        }
                        break;

      case  'p'   :
      case  'x'   :
      case  'u'   :
      case  'o'   :  base = (sfield->conv == 'u') ? 10 :
                            (sfield->conv == 'x' || sfield->conv == 'p') ? 16 :
                            8;

                     switch(_STCHK(sfield, (_MFH | _MFL)))
                     {
                        case _MFH : *(va_arg(*_ap, unsigned short int*))=
                                    (unsigned short int)strtoul(tmpbuf,
                                    NULL, base);
                                    break;

                        case _MFL : *(va_arg(*_ap, unsigned long int*)) =
                                    strtoul(tmpbuf, NULL, base);
                                    break;

                        default   : *(va_arg(*_ap, unsigned int*)) =
                                    (unsigned int)strtoul(tmpbuf, NULL,
                                    base);
                                    break;
                     }
                     break;

      case  'e'   :
      case  'f'   :
      case  'g'   :
      case  'E'   :
      case  'G'   :  switch(_STCHK(sfield, (_MFL | _MFLD)))
                     {
                        case _MFL : *(va_arg(*_ap, double*))=
                                    strtod(tmpbuf, NULL);
                                    break;

                        case _MFLD: *(va_arg(*_ap, long double*)) =
                                    (long double)strtod(tmpbuf, NULL);
                                    break;

                        default   : *(va_arg(*_ap, float*)) =
                                    (float)strtod(tmpbuf, NULL);
                                    break;
                     }
                     break;

   }
}

abs.c/          925421664   0     0     0       492       `
/*****************************************************************************/
/* abs.c V5.11 for TMS3203x/4x                                              */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <stdlib.h>

int abs(int i)
{
   int j;
   return ( (j = -i) < 0 ) ? i : j;
}

long labs(long i)
{
   long j;
   return ( (j = -i) < 0 ) ? i : j;
}
acos.c/         925421664   0     0     0       2387      `
/*****************************************************************************/
/* acos.c V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/

#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  ACOS() - Arccosine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 10.             */
/*									    */
/*  Y = abs(x)								    */
/*  if Y > 0.5, g = (1 - Y) / 2, Y = - 2 * sqrt(g), i = 1		    */
/*  if Y < 0.5, g = Y * Y, i = 0					    */
/*  R = polynomial expression			 			    */
/*									    */
/*  result = Y + Y * R							    */
/*									    */
/*  if x < 0, result = bi - result + bi 				    */
/*  if x > 0, result = ci + result + ci 				    */
/****************************************************************************/
double acos(double x)
{
  double p, q, g, y;
  static double b[2] = {1.57079632679489661923, 0.78539816339744830962};
  static double c[2] = {0.0, 0.78539816339744830962};
  int i = 1;

  /*************************************************************************/
  /* acos(x) = acos(-x)                                                    */  
  /*************************************************************************/
  if ((y = fabs(x)) > 0.5)
  {
     /**********************************************************************/
     /* check if x is out of domain                                        */
     /**********************************************************************/
     if (y > 1.0) { errno = EDOM; return (0.0); }

     i = 0;
     g = (1.0 - y) * 0.5;
     y = -2.0 * sqrt(g);
  }
  else g = y * y;

  /*************************************************************************/
  /* determine polynomial expansion                                        */
  /*************************************************************************/
  p = (ASP2 * g + ASP1) * g;
  q = (g + ASQ1) * g + ASQ0;

  return (x < 0) ? ((b[i] + y + y * p / q) + b[i])
		 : ((c[i] - y - y * p / q) + c[i]);
}

asctime.c/      925421664   0     0     0       996       `
/*****************************************************************************/
/* asctime.c V5.11 for TMS3203x/4x                                          */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <time.h>

extern int sprintf(char *_string, const char *_format, ...);

char *asctime(const struct tm *timeptr)
{
    struct tm   temp = *timeptr;
    static char result[26];
    static char *day[7]  = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
    static char *mon[12] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", 
			     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };

    mktime(&temp);     /* MAKE SURE THIS A SANE TIME */

    sprintf(result, "%s %s%3d %02d:%02d:%02d %d\n",
		    day[temp.tm_wday], mon[temp.tm_mon], temp.tm_mday, 
		    temp.tm_hour, temp.tm_min, temp.tm_sec,
		    temp.tm_year + 1900);

    return result;
}
asin.c/         925421666   0     0     0       2106      `
/*****************************************************************************/
/* asin.c V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/

#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  ASIN() - Arcsine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 10.             */
/*									    */
/*  Y = abs(x)								    */
/*  if Y > 0.5, g = (1 - Y) / 2, Y = - 2 * sqrt(g), i = 1		    */
/*  if Y < 0.5, g = Y * Y, i = 0					    */
/*  R = polynomial expression			 			    */
/*									    */
/*  result = Y + Y * R							    */
/*									    */
/*  if x < 0, result = -ci - result - ci 				    */
/*  if x > 0, result = ci + result + ci		  			    */
/****************************************************************************/
double asin(double x)
{
    double p, q, g, y;
    static double c[2] = {0.0, 0.78539816339744830962};
    int i = 0;

    if ((y = fabs(x)) > 0.5)
    {
       /*******************************************************************/
       /* check if input is out of the domain of the function             */
       /*******************************************************************/
       if (y > 1.0) { errno = EDOM; return (0.0); }

       i = 1;	
       g = (1.0 - y) * 0.5;	
       y = -2.0 * sqrt(g);
    }
    else g = y * y;		

  /************************************************************************/
  /* determine polynomial expression                                      */
  /************************************************************************/
    p = (ASP2 * g + ASP1) * g;
    q = (g + ASQ1) * g + ASQ0;

    return (x < 0) ? (-((c[i] + y + y * p / q) + c[i]))
		   : ((c[i] + y + y * p / q) + c[i]);
}
assert.c/       925421666   0     0     0       1573      `
/*****************************************************************************/
/* assert.c V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Inc.                            */
/*****************************************************************************/
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

/****************************************************************************/
/* _ASSERT() - Implements the assert macro. Checks the argument. Aborts     */
/*             with a message if not true.                                  */
/****************************************************************************/
void _assert(int expr, char *string)
{
    if (!expr) _abort_msg(string);
}

/****************************************************************************/
/* _NASSERT() - Special version of assert, which assumes the expression is  */
/*              true.                                                       */
/****************************************************************************/
void _nassert(int expr)
{
    return;
}

/****************************************************************************/
/* _ABORT_MSG() - Write out a string and never return.  Abort function for  */
/*                false assertions.                                         */
/****************************************************************************/
void _abort_msg(char *string)
{
    fprintf(stderr, "Abort: %s\n", string);
    abort();
}


atan.c/         925421666   0     0     0       2856      `
/*****************************************************************************/
/* atan.c V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/

#include <math.h>
#include <values.h>

/****************************************************************************/
/*  ATAN() - Arctangent							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 11.             */
/*									    */
/*  if x > 1, x = 1 / x 						    */
/*  if x > 2 - sqrt(3), x = (x * sqrt(3) - 1) / (sqrt(3) + x)		    */
/*  g = x * x								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = (t * (x + x * R) + an) * s					    */
/****************************************************************************/
double atan(double x)
{
    double g, p, q;
    float  s = (x < 0.0) ? -1.0F : 1.0F;            /* sign */
    float  t = 1.0;
    int    n = 0;

#if defined(_TMS320C30) || defined(_TMS320C40)
    static double a[4] = {0.0, 0.5235987905, 1.570796371, 1.047197805};
#else
    static double a[4] = {0.0, 0.52359877559829887308, 1.57079632679489661923,
		   1.04719755119659774615};
#endif

    if ((x = fabs(x)) > 1.0)
    {
	x = 1.0 / x;	
	n = 2;	

	/******************************************************************/
	/* the partial result needs to be negated                         */
	/******************************************************************/
	t = -1.0;
    }

    /**********************************************************************/
    /* for x > (2 - sqrt(3)  )                                            */
    /**********************************************************************/
    if (x > TWO_SQRT3)			
    {
	/******************************************************************/
	/* x = (x * sqrt(3) -1)	/ (sqroot(3) + x)                         */
	/******************************************************************/
	x = (x * SQRTTHREE - 1.0) / (SQRTTHREE + x);
	++n; 			
    }

    /*********************************************************************/
    /* determine polynomial expression                                   */
    /*********************************************************************/
    g = x * x;	

    p = (ATP1 * g + ATP0) * g;
    q = g + ATQ0;

    /**********************************************************************/
    /* calculate the result multiplied by the correct sign                */
    /**********************************************************************/
    return ((((p / q) * x + x) * t + a[n]) * s);  
}
atan2.c/        925421666   0     0     0       3438      `
/*****************************************************************************/
/* atan2.c V5.11 for TMS3203x/4x                                            */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated.                   */
/*****************************************************************************/

#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  ATAN2() - Arctangent2						    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 11.             */
/*									    */
/*  if x >= 0, result = atan(y / x)		  			    */
/*  if x < 0 & y >= 0, result = pi + atan(y / x)			    */
/*  if x < 0 & y < 0, result = atan (y / x) - pi			    */
/*									    */
/****************************************************************************/
double atan2(double y, double x)
{
    double g, p, q, r;
    float  s;
    float  t = 1.0;
    int   ys = (y >= 0);
    int   xs = (x >= 0);
    int    n = 0;

#if defined(_TMS320C30) || defined(_TMS320C40)
    static double a[4] = {0.0, 0.5235987905, 1.570796371, 1.047197805};
#else
    static double a[4] = {0.0, 0.52359877559829887308, 1.57079632679489661923,
		   1.04719755119659774615};
#endif

    /*********************************************************************/
    /* check for error in domain                                         */
    /*********************************************************************/
    if (x == 0)
    {
       if (y == 0) { errno = EDOM; return (0.0); }
       else          return (ys ? HALFPI : -HALFPI);
    }

    /*********************************************************************/
    /* check for negative                                                */
    /*********************************************************************/
    s = ((x = y / x) < 0.0) ? -1.0 : 1.0;

    if ((x = fabs(x)) > 1.0)
    {
       x = 1.0 / x;	
       n = 2;	
       t = -1.0;	                         /* negate partial result */
    }

    /**********************************************************************/
    /* if (x > (2 - sqrt(3)) x = (x * sqrt(3) -1) / (sqroot(3) + x)       */
    /**********************************************************************/
    if (x > TWO_SQRT3)
    {
       x = (x * SQRTTHREE - 1.0) / (SQRTTHREE + x); 
       ++n;
    }

    /**********************************************************************/
    /* determine polynomial expression                                    */
    /**********************************************************************/
    g = x * x;

    p = (ATP1 * g + ATP0) * g;
    q = g + ATQ0;

    /*********************************************************************/
    /* calculate the result multiplied by the correct sign               */
    /*********************************************************************/
    r = (((p / q) * x + x) * t + a[n]) * s;

    /*********************************************************************/
    /* adjust result to be in correct quadrant                           */
    /*********************************************************************/
    if (!xs && ys)  r = (PI + r);
    if (!xs && !ys) r = (r - PI);

    return (r);
}
atof.c/         925421666   0     0     0       417       `
/*****************************************************************************/
/* atof.c V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <stdlib.h>

double atof(const char *st)
{
    return strtod(st, (char **)0);
}

atoi.c/         925421668   0     0     0       875       `
/*****************************************************************************/
/* atoi.c V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <stdlib.h>
#include <ctype.h>

int atoi(register const char *st)
{
    int  result = 0;
    char cp;
    int  sign;

    while (isspace(*st)) ++st;      /* SKIP WHITE SPACE */

    if ((sign = ((cp = *st) == '-')) != 0) cp = *++st;
    else if (cp == '+')                    cp = *++st;

    while (isdigit(cp))
    {
        result *= 10;
        result += cp - '0';
        cp      = *++st;
    }

    if (sign) result = -result;
    return result;
}

long atol(register const char *st)
{
    return atoi(st);
}

bsearch.c/      925421668   0     0     0       1276      `
/*****************************************************************************/
/* bsearch.c V5.11 for TMS3203x/4x                                          */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <stdlib.h>

typedef const void *OBJPTR; 

void *bsearch(OBJPTR key,                    /* ITEM TO SEARCH FOR           */
              OBJPTR base,                   /* POINTER TO ARRAY OF ELEMENTS */
              size_t nmemb,                  /* NUMBER OF ELEMENTS TO SORT   */
              size_t size,                   /* SIZE IN WORDS OF EACH ITEM   */
              int (*compar)(OBJPTR, OBJPTR)) /* COMPARE FUNCTION             */
{
   int i = 0;                                /* LEFT SCAN INDEX              */
   int j = nmemb - 1;                        /* RIGHT SCAN INDEX             */

   while( i <= j )
   {
      int    pivot = (j + i) / 2;            
      OBJPTR elem  = (char *)base + (pivot * size);
      int    diff  = (*compar)(key, elem);

      if (diff == 0) return (void *)elem;
      if (diff < 0) j = pivot - 1;
	       else i = pivot + 1;
   }

   return 0;    /* NOT FOUND */
}

ceil.c/         925421668   0     0     0       772       `
/*****************************************************************************/
/* ceil.c V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <math.h>

/****************************************************************************/
/*  CEIL() - Ceiling							    */
/*									    */
/*  Returns the closest integer to x which is >= x   			    */
/****************************************************************************/
double ceil(double x)
{
     double y; 
     return (modf(x, &y) > 0 ? y + 1.0 : y);
}
clearerr.c/     925421668   0     0     0       882       `
/*****************************************************************************/
/*  CLEARERR.C V5.11                                                        */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <stdio.h>


/*****************************************************************************/
/* CLEARERR -  Clear the I/O error flag (_STATERR)                           */
/*                                                                           */
/*    This function calls a macro defined in stdio.h                         */
/*                                                                           */
/*****************************************************************************/
void clearerr(FILE *_fp) { _clearerr(_fp); }

clock.c/        925421668   0     0     0       1077      `
/*****************************************************************************/
/* clock.c V5.11 for TMS3203x/4x                                            */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/

/****************************************************************************/
/* THIS FUNCTION IS SYSTEM SPECIFIC AND SHOULD BE MODIFIED TO SUIT YOUR     */
/* APPLICATION.                                                             */
/*--------------------------------------------------------------------------*/
/* OBVIOUSLY, THIS IS NO LONGER A STUB.  THIS WILL RETURN THE CLK REGISTER  */
/* FROM THE EMULATOR OR SIMULATOR.  THIS IS A CYCLE ACURATE COUNT OF THE    */
/* NUMBER OF CYCLES THAT HAVE ELAPSED SINCE THE START OF THE PROGRAM.       */
/****************************************************************************/
#include <time.h>
extern long HOSTclock();
 
clock_t clock(void)   
{
    return (clock_t)HOSTclock();
}

cos.c/          925421668   0     0     0       2680      `
/*****************************************************************************/
/* cos.c V5.11 for TMS3203x/4x                                              */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/

#include <math.h>
#include <values.h>

/****************************************************************************/
/*  COS() - Cosine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 8.              */
/*									    */
/*  N = round(x / PI + 1/2) - 0.5					    */
/*  f = x - N * PI							    */
/*  g = f * f								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = f + f * R							    */
/*  if N is even, result = - result					    */
/*									    */
/*  This will return the wrong result for x >= MAXINT * PI		    */
/****************************************************************************/
double cos(double x)
{
  float sgn;           /* the sign of the result */
  double xn, f, g, rg;
  int n;
  
  /**************************************************************************/
  /* cos(x) = cos(-x)                                                       */
  /**************************************************************************/
  x = fabs(x);
  
  /**************************************************************************/
  /* n = round(x/PI + 1/2) (can be rounded this way, since positive number) */
  /**************************************************************************/
  n  = (int) (((x + HALFPI) * INVSPI) + 0.5);
  xn = (double) n - 0.5;

  /**************************************************************************/
  /* if n is odd, negate the sign                                           */
  /**************************************************************************/
  sgn = (n % 2) ? -1.0 : 1.0;

  /**************************************************************************/
  /* f = x - xn * PI (but more mathematically stable)                       */
  /**************************************************************************/
  f = (x - xn * C1) - xn * C2;

  /**************************************************************************/
  /* determine polynomial expression                                        */
  /**************************************************************************/
  g = f * f;

  rg = (((R4 * g + R3) * g + R2) * g + R1) * g;

  return (sgn * (f + f * rg));
}
cosh.c/         925421670   0     0     0       3266      `
/*****************************************************************************/
/* cosh.c V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/

#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  COSH() - Hyperbolic Cosine						    */
/*               							    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 6.              */
/*               							    */
/*  result = (exp(x) + 1 / exp(x)) / 2		  			    */
/****************************************************************************/
double cosh(double x)
{
  double g, z, q, p, r, a, b;
  int n;

  /**************************************************************************/
  /* cosh(x) = cosh(-x)                                                     */
  /**************************************************************************/
  x = fabs(x);

  /**************************************************************************/
  /* check to see if overflow would occur                                   */
  /**************************************************************************/
  if (x > MAXH) { errno = ERANGE; return (HUGE_VAL); }

  if (x < 0) n = (int) (x * INVLOGe2 - 0.5);     /* since (int) -1.5 = -1.0 */
  else       n = (int) (x * INVLOGe2 + 0.5);

  /**************************************************************************/
  /* g = x - n * ln(2) (but more mathematically stable)                     */
  /**************************************************************************/
  g  = (x - n * C3) - n * C4;

  /**************************************************************************/
  /* determine polynomial expression                                        */
  /**************************************************************************/
  z  = g * g;

  p = (EXP1 * z + EXP0) * g;
  q = EXQ1 * z + EXQ0;

  /**************************************************************************/
  /* calculate exp(g)                                                       */
  /**************************************************************************/
  r  = 0.5 + p / (q - p);

  /**************************************************************************/
  /* exp(x)/2 = exp(g) * 2 ^ (n)                                            */
  /**************************************************************************/
  a = ldexp(r, n);

  /**************************************************************************/
  /* exp(-x)*2 = 1 / (exp(x)/2)                                             */
  /**************************************************************************/
  b  = 1.0 / a;

  /**************************************************************************/
  /* cosh(x) = exp(x)/2 + exp(-x)*2 / 4                                     */
  /**************************************************************************/
  return (a + b * 0.25);
}
ctime.c/        925421670   0     0     0       422       `
/*****************************************************************************/
/* ctime.c V5.11 for TMS3203x/4x                                            */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <time.h>

char *ctime(const time_t *timer)
{
   return asctime(localtime(timer));
}
ctype.c/        925421670   0     0     0       7804      `
/*****************************************************************************/
/* ctype.c V5.11 for TMS3203x/4x                                            */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <ctype.h>

/****************************************************************************/
/*  DECLARATION OF CHARACTER TYPING LOOKUP TABLE                            */
/****************************************************************************/
unsigned char _ctypes_[] = {
                     /*  -1   EOF   */     0,    
                     /* 0x00  NUL   */     _CL_,
                     /* 0x01  SOH   */     _CL_,
                     /* 0x02  STX   */     _CL_,
                     /* 0x03  ETX   */     _CL_,
                     /* 0x04  EOT   */     _CL_,
                     /* 0x05  ENQ   */     _CL_,
                     /* 0x06  ACK   */     _CL_,
                     /* 0x07  BEL   */     _CL_,
                     /* 0x08  BS    */     _CL_,
                     /* 0x09  HT    */     _CL_ | _SP_,
                     /* 0x0A  LF    */     _CL_ | _SP_,
                     /* 0x0B  VT    */     _CL_ | _SP_,
                     /* 0x0C  FF    */     _CL_ | _SP_,
                     /* 0x0D  CR    */     _CL_ | _SP_,
                     /* 0x0E  SO    */     _CL_,
                     /* 0x0F  SI    */     _CL_,

                     /* 0x10  DLE   */     _CL_,
                     /* 0x11  DC1   */     _CL_,
                     /* 0x12  DC2   */     _CL_,
                     /* 0x13  DC3   */     _CL_,
                     /* 0x14  DC4   */     _CL_,
                     /* 0x15  NAK   */     _CL_,
                     /* 0x16  SYN   */     _CL_,
                     /* 0x17  ETB   */     _CL_,
                     /* 0x18  CAN   */     _CL_,
                     /* 0x19  EM    */     _CL_,
                     /* 0x1A  SUB   */     _CL_,
                     /* 0x1B  ESC   */     _CL_,
                     /* 0x1C  FS    */     _CL_,
                     /* 0x1D  GS    */     _CL_,
                     /* 0x1E  RS    */     _CL_,
                     /* 0x1F  US    */     _CL_,

                     /* 0x20  ' '   */     _SP_ | _BL_,
                     /* 0x21  '!'   */     _PU_,
                     /* 0x22  '"'   */     _PU_,
                     /* 0x23  '#'   */     _PU_,
                     /* 0x24  '$'   */     _PU_,
                     /* 0x25  '%'   */     _PU_,
                     /* 0x26  '&'   */     _PU_,
                     /* 0x27  '''   */     _PU_,
                     /* 0x28  '('   */     _PU_,
                     /* 0x29  ')'   */     _PU_,
                     /* 0x2A  '*'   */     _PU_,
                     /* 0x2B  '+'   */     _PU_,
                     /* 0x2C  ','   */     _PU_,
                     /* 0x2D  '-'   */     _PU_,
                     /* 0x2E  '.'   */     _PU_,
                     /* 0x2F  '/'   */     _PU_,

                     /* 0x30  '0'   */     _NM_ | _HX_,
                     /* 0x31  '1'   */     _NM_ | _HX_,
                     /* 0x32  '2'   */     _NM_ | _HX_,
                     /* 0x33  '3'   */     _NM_ | _HX_,
                     /* 0x34  '4'   */     _NM_ | _HX_,
                     /* 0x35  '5'   */     _NM_ | _HX_,
                     /* 0x36  '6'   */     _NM_ | _HX_,
                     /* 0x37  '7'   */     _NM_ | _HX_,
                     /* 0x38  '8'   */     _NM_ | _HX_,
                     /* 0x39  '9'   */     _NM_ | _HX_,
                     /* 0x3A  ':'   */     _PU_,
                     /* 0x3B  ';'   */     _PU_,
                     /* 0x3C  '<'   */     _PU_,
                     /* 0x3D  '='   */     _PU_,
                     /* 0x3E  '>'   */     _PU_,
                     /* 0x3F  '?'   */     _PU_,

                     /* 0x40  '@'   */     _PU_,
                     /* 0x41  'A'   */     _UC_ | _HX_,
                     /* 0x42  'B'   */     _UC_ | _HX_,
                     /* 0x43  'C'   */     _UC_ | _HX_,
                     /* 0x44  'D'   */     _UC_ | _HX_,
                     /* 0x45  'E'   */     _UC_ | _HX_,
                     /* 0x46  'F'   */     _UC_ | _HX_,
                     /* 0x47  'G'   */     _UC_,
                     /* 0x48  'H'   */     _UC_,
                     /* 0x49  'I'   */     _UC_,
                     /* 0x4A  'J'   */     _UC_,
                     /* 0x4B  'K'   */     _UC_,
                     /* 0x4C  'L'   */     _UC_,
                     /* 0x4D  'M'   */     _UC_,
                     /* 0x4E  'N'   */     _UC_,
                     /* 0x4F  'O'   */     _UC_,

                     /* 0x50  'P'   */     _UC_,
                     /* 0x51  'Q'   */     _UC_,
                     /* 0x52  'R'   */     _UC_,
                     /* 0x53  'S'   */     _UC_,
                     /* 0x54  'T'   */     _UC_,
                     /* 0x55  'U'   */     _UC_,
                     /* 0x56  'V'   */     _UC_,
                     /* 0x57  'W'   */     _UC_,
                     /* 0x58  'X'   */     _UC_,
                     /* 0x59  'Y'   */     _UC_,
                     /* 0x5A  'Z'   */     _UC_,
                     /* 0x5B  '['   */     _PU_,
                     /* 0x5C  '\'   */     _PU_,
                     /* 0x5D  ']'   */     _PU_,
                     /* 0x5E  '^'   */     _PU_,
                     /* 0x5F  '_'   */     _PU_,

                     /* 0x60  '`'   */     _PU_,
                     /* 0x61  'a'   */     _LC_ | _HX_,
                     /* 0x62  'b'   */     _LC_ | _HX_,
                     /* 0x63  'c'   */     _LC_ | _HX_,
                     /* 0x64  'd'   */     _LC_ | _HX_,
                     /* 0x65  'e'   */     _LC_ | _HX_,
                     /* 0x66  'f'   */     _LC_ | _HX_,
                     /* 0x67  'g'   */     _LC_,
                     /* 0x68  'h'   */     _LC_,
                     /* 0x69  'i'   */     _LC_,
                     /* 0x6A  'j'   */     _LC_,
                     /* 0x6B  'k'   */     _LC_,
                     /* 0x6C  'l'   */     _LC_,
                     /* 0x6D  'm'   */     _LC_,
                     /* 0x6E  'n'   */     _LC_,
                     /* 0x6F  'o'   */     _LC_,

                     /* 0x70  'p'   */     _LC_,
                     /* 0x71  'q'   */     _LC_,
                     /* 0x72  'r'   */     _LC_,
                     /* 0x73  's'   */     _LC_,
                     /* 0x74  't'   */     _LC_,
                     /* 0x75  'u'   */     _LC_,
                     /* 0x76  'v'   */     _LC_,
                     /* 0x77  'w'   */     _LC_,
                     /* 0x78  'x'   */     _LC_,
                     /* 0x79  'y'   */     _LC_,
                     /* 0x7A  'z'   */     _LC_,
                     /* 0x7B  '{'   */     _PU_,
                     /* 0x7C  '|'   */     _PU_,
                     /* 0x7D  '}'   */     _PU_,
                     /* 0x7E  '~'   */     _PU_,
                     /* 0x7F  DEL   */     _CL_,

		     /* 0x80-0x8F   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0x90-0x9F   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xA0-0xAF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xB0-0xBF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xC0-0xCF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xD0-0xDF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xE0-0xEF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xF0-0xFF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  };
defs.c/         925421670   0     0     0       2834      `
/*****************************************************************************/
/*  DEFS.C V5.11                                                            */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file defines some data structures declared in stdio.h.            */
/*****************************************************************************/
#include <stdio.h>

/*---------------------------------------------------------------------------*/
/* Define the streams for stdin, stdout, and stderr, and assign them as the  */
/* first three streams in _FTABLE upon its initialization.                   */
/*---------------------------------------------------------------------------*/
FILE _ftable[_NFILE] = {{  0, NULL, NULL, NULL, NULL, (_MODER | _IOLBF), 0},
                        {  1, NULL, NULL, NULL, NULL, (_MODEW | _IOLBF), 1},
                        {  2, NULL, NULL, NULL, NULL, (_MODEW | _IONBF), 2},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           3},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           4},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           5},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           6},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           7},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           8},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           9},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           10},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           11},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           12},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           13},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           14},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           15},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           16},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           17},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           18},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           19} };

/*---------------------------------------------------------------------------*/
/* Allocate a table to store the filenames of temporary files, so they can   */
/* be deleted when they are closed.                                          */
/*---------------------------------------------------------------------------*/
char _tmpnams[_NFILE][L_tmpnam];

/*---------------------------------------------------------------------------*/
/* This global variable _FT_END is used to mark the end of used streams in   */
/* the file table.                                                           */
/*---------------------------------------------------------------------------*/
int _ft_end = 3; 
difftime.c/     925421670   0     0     0       808       `
/*****************************************************************************/
/* difftime.c V5.11 for TMS3203x/4x                                         */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <time.h>

double difftime(time_t time1, time_t time0)
{
    /*----------------------------------------------------------------------*/
    /* THE FOLLOWING CONVERSION INSURES THAT ANY POSSIBLE DIFFERENCE IN THE */
    /* RANGE OF UNSIGNED LONG IS PROPERLY REPRESENTED IN THE RESULT.        */
    /*----------------------------------------------------------------------*/
    return ((time1 > time0) ?  (double)(time1 - time0)
			    : -(double)(time0 - time1));
}
div.c/          925421670   0     0     0       639       `
/*****************************************************************************/
/* div.c V5.11 for TMS3203x/4x                                              */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <stdlib.h>

div_t div(int numer, int denom)
{
    div_t local;
    local.quot = numer / denom;
    local.rem  = numer % denom;
    return local;
}

ldiv_t ldiv(long numer, long denom)
{
    ldiv_t local;
    local.quot = numer / denom;
    local.rem  = numer % denom;
    return local;
}


dtos.c/         925421672   0     0     0       1193      `
/*****************************************************************************/
/* dtos.c V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
extern int ltoa(long, char*);
extern void dtos(double num, char *buf, int prec);

/****************************************************************************/
/* THIS FUNCTION IS NON-STANDARD AND IS PROVIDED ONLY FOR COMPATIBILITY.    */
/* THE STANDARD EQUIVALENT IS SPRINTF.                                      */
/****************************************************************************/
void dtos(double num, char *buf, int prec)
{
    int    ival;
    int    pow = 0;
    double max = 0x7FFFFFFF;

    if (num < 0) 
    { 
        *buf++ = '-'; 
        num    = -num;
    }

    while (num > max) { num /= 10; pow++; }

    buf += ltoa(ival = num, buf);

    if (prec > 0) do
    {
       num -= ival;
       if (pow-- == 0) *buf++ = '.';
       *buf++ = (ival = num *= 10) + '0';
    }
    while (--prec);

    *buf = 0;
}

ecvt.c/         925421672   0     0     0       2725      `
/*****************************************************************************/
/* ecvt.c V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
extern int ltoa(long, char*);

/****************************************************************************/
/* THIS FUNCTION IS NON-STANDARD AND IS PROVIDED ONLY AS A BUILDING BLOCK   */
/* FOR PRINTF.                                                              */
/****************************************************************************/
char *ecvt(double value, int ndigit, int *decpt, int *sign)
{
    static char out[100]; 

    int   digits = 0;                  /* NUMBER OF DIGITS BEFORE .       */
    char *pos    = out + 1;     
    int   temp;

    out[0] = '0';                      /* JUST IN CASE WE ROUND.          */
    ndigit++;                          /* DO ONE EXTRA DIGIT FOR ROUNDING */

    /*--------------------------------------------------------------------*/
    /* PERFORM PRESCALING - MAKE SURE NUMBER HAS INTEGRAL WHOLE PART      */
    /*--------------------------------------------------------------------*/
    if (*sign = (value < 0)) value = -value;
    while (value > 0x7FFFFFFF) { value /= 10; digits++; }
    while (value && value < 1) { value *= 10; digits--; }

    /*--------------------------------------------------------------------*/
    /* WRITE OUT INTEGRAL PART OF NUMBER.                                 */
    /*--------------------------------------------------------------------*/
    pos    += temp = ltoa((int)value, pos);
    *decpt  = digits + temp;

    /*--------------------------------------------------------------------*/
    /* WRITE OUT FRACTIONAL PART OF NUMBER                                */
    /*--------------------------------------------------------------------*/
    if (temp >= ndigit) 
	pos = out + ndigit + 1;
    else if ((ndigit -= temp) > 0) do
    {
        value -= (int)value;
        *pos++ = (int)(value *= 10.0) + '0';
    } 
    while (--ndigit);

    /*--------------------------------------------------------------------*/
    /* PERFORM ROUNDING.  NOTE THAT pos IS CURRENTLY POINTING AT AN EXTRA */
    /* DIGIT WHICH WAS CONVERTED FOR THIS PURPOSE.                        */
    /*--------------------------------------------------------------------*/
    if (*--pos >= '5')
    {
	char *ptr = pos;
	while ((*--ptr += 1) > '9') *ptr = '0';
	if (ptr == out) { *--pos = 0; *decpt += 1; return out; }
    }
	
    *pos = 0;
    return out + 1;
}


errno.c/        925421672   0     0     0       361       `
/*****************************************************************************/
/* errno.c V5.11 for TMS3203x/4x                                            */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <errno.h>

int errno = 0;

exit.c/         925421672   0     0     0       2514      `
/*****************************************************************************/
/*  EXIT.C V5.11                                                            */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <stdlib.h>

#define MAX_FUN   32

static int    at_exit_count = 0;
static void (*at_exit_fun[MAX_FUN])();
void        (*_cleanup_ptr)(void) = NULL;

/****************************************************************************/
/* EXIT() - NORMAL PROGRAM TERMINATION.                                     */
/****************************************************************************/
void exit(int status)        
{
   register int i = at_exit_count;

   /*-------------------------------------------------------------------*/
   /* HANDLE FUNCTIONS REGISTERED THROUGH atexit().                     */
   /*-------------------------------------------------------------------*/
   while (i) (*at_exit_fun[--i])(); 

   /*-------------------------------------------------------------------*/
   /* IF FILES ARE POSSIBLY OPEN, _CLEANUP_PTR() WILL BE SETUP TO CLOSE */
   /* THEM.                                                             */
   /*-------------------------------------------------------------------*/
   if (_cleanup_ptr)  (*_cleanup_ptr)();

   /*-------------------------------------------------------------------*/
   /* SET C$$EXIT LABEL SO THE DEBUGGER KNOWS WHEN THE C++ PROGRAM HAS  */
   /* COMPLETED.  THIS CAN BE REMOVED IF THE DEBUGGER IS NOT USED.      */
   /*-------------------------------------------------------------------*/
   asm("        .global C$$EXIT");
   asm("C$$EXIT: nop");

   for (;;);   /* CURRENTLY, THIS SPINS FOREVER */
}

/****************************************************************************/
/* ATEXIT - ATTEMPT TO REGISTER A FUNCTION FOR CALLING AT PROGRAM END       */
/****************************************************************************/
int atexit(void (*fun)())
{
   if (at_exit_count >= MAX_FUN) return 1;
   at_exit_fun[at_exit_count++] = fun;
   return 0;
}

/****************************************************************************/
/* ABORT - ABNORMAL PROGRAM TERMINATION.  CURRENTLY JUST HALTS EXECUTION.   */
/****************************************************************************/
void abort(void)
{
   for (;;);   /* SPINS FOREVER */
}
exp.c/          925421672   0     0     0       2391      `
/*****************************************************************************/
/* exp.c V5.11 for TMS3203x/4x                                              */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/

#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  EXP() - e ^ x							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 6.              */
/*									    */
/*  N = round(x / ln(2))						    */
/*  g = x - N * ln(2)							    */
/*  z = g * g								    */
/*									    */
/*  R = polynomial expansion						    */
/*									    */
/*  result = R * 2 ^ (N	+ 1)						    */
/****************************************************************************/
double exp(double x)
{
    double g, z, q, p;
    int n;

    /*************************************************************************/
    /* check if input would produce output out of the range of this function */
    /*************************************************************************/
    if (x > MAXX) { errno = ERANGE; return (HUGE_VAL); }

    if (x < 0) n = (int) (x * INVLOGe2 - 0.5);    /* since (int) -1.5 = -1.0 */
    else       n = (int) (x * INVLOGe2 + 0.5);

    /*************************************************************************/
    /* g = x - n * ln(2) (but more mathematically stable)                    */
    /*************************************************************************/
    g  = (x - n * C3) - n * C4;

    /*************************************************************************/
    /* determine polynomial expression                                       */
    /*************************************************************************/
    z  = g * g;

    p = (EXP1 * z + EXP0) * g;
    q = EXQ1 * z + EXQ0;

    /*************************************************************************/
    /* exp(x) = exp(g) * 2 ^ (n + 1)                                         */
    /*************************************************************************/
    return ldexp(0.5 + p / (q - p), n + 1); 
}

fabs.c/         925421674   0     0     0       848       `
/*****************************************************************************/
/* fabs.c V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/

#include <math.h>

/****************************************************************************/
/*  FABS() - Floating Point Absolute Value				    */
/*									    */
/*  The definition below is NOT a recursive definition!  The compiler       */
/*  generates calls to fabs() inline, using a single ABS instruction.       */
/****************************************************************************/
double fabs(double x)
{
    return fabs(x);        /* This will be generated inline by the compiler */
}
fclose.c/       925421674   0     0     0       3768      `
/*****************************************************************************/
/*  FCLOSE.C V5.11                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    Functions:                                                             */
/*       FCLOSE   -  Close a stream                                          */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <string.h>
#include <stdlib.h>

extern int _doflush(FILE *_fp);






/*****************************************************************************/
/* FCLOSE   -  Close a stream                                                */
/*                                                                           */
/*    This function flushes the current stream, deallocates any buffers      */
/*    associated with the stream, and closes it.  This function returns a 0  */
/*    if the close was successful, or an EOF if an error occured.            */
/*                                                                           */
/*****************************************************************************/
int fclose(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int fd = _fp->fd;
   int errchk;
   int remove_flag = _STCHK(_fp, _TMPFILE);

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* Flush the buffer.                                                      */
   /*------------------------------------------------------------------------*/
   if(_doflush(_fp)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* Free the buffer if there was one, and it was malloc'd by SETVBUF.      */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _BUFFALOC))
   {
      free((_fp->buf)-1);
      _UNSET(_fp, _BUFFALOC);
   }

   /*------------------------------------------------------------------------*/
   /* Reset the buffer pointers in the stream.                               */
   /*------------------------------------------------------------------------*/
   _fp->buf = NULL;
   _fp->pos = NULL;
   _fp->bufend = NULL;

   /*------------------------------------------------------------------------*/
   /* Close the file, and give the FILE structure an invalid file descriptor */
   /* so it cannot be used until it is assigned to another stream.           */
   /*------------------------------------------------------------------------*/
   errchk = close(_fp->fd);
   _fp->fd = -1;

   /*------------------------------------------------------------------------*/
   /* If the FILE pointer was associated with a temporary file, look up that */
   /* temporary file's filename, and remove it.                              */
   /*------------------------------------------------------------------------*/
   if(remove_flag) remove(_tmpnams[fd]);  

   return (errchk);
}

fcvt.c/         925421674   0     0     0       2849      `
/*****************************************************************************/
/* fcvt.c V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
extern int ltoa(long,char*);
char *fcvt(double value, int ndigit, int *decpt, int *sign);

/****************************************************************************/
/* THIS FUNCTION IS NON-STANDARD AND IS PROVIDED ONLY AS A BUILDING BLOCK   */
/* FOR PRINTF.                                                              */
/****************************************************************************/
char *fcvt(double value, int ndigit, int *decpt, int *sign)
{
    static char out[100]; 

    int   digits = 0;                  /* NUMBER OF DIGITS BEFORE .       */
    char *pos    = out + 1;     
    int   temp;

    out[0] = '0';                      /* JUST IN CASE WE ROUND.          */
    ndigit++;                          /* DO ONE EXTRA DIGIT FOR ROUNDING */

    /*--------------------------------------------------------------------*/
    /* PERFORM PRESCALING - MAKE SURE NUMBER HAS INTEGRAL WHOLE PART      */
    /*--------------------------------------------------------------------*/
    if (*sign = (value < 0)) value = -value;
    while (value > 0x7FFFFFFF) { value /= 10; digits++; }
    while (value && value < 1) { value *= 10; digits--; }

    /*--------------------------------------------------------------------*/
    /* WRITE OUT INTEGRAL PART OF NUMBER.                                 */
    /*--------------------------------------------------------------------*/
    pos   += temp    = ltoa((int)value, pos);
    *decpt = digits + temp; 

    if (digits < 0) ndigit += digits;

    /*--------------------------------------------------------------------*/
    /* WRITE OUT FRACTIONAL PART OF NUMBER                                */
    /*--------------------------------------------------------------------*/
    if (ndigit > 0) do
    {
         value -= (int)value;
         *pos++ = (int)(value *= 10.0) + '0';
    }
    while (--ndigit);

    /*--------------------------------------------------------------------*/
    /* PERFORM ROUNDING.  NOTE THAT pos IS CURRENTLY POINTING AT AN EXTRA */
    /* DIGIT WHICH WAS CONVERTED FOR THIS PURPOSE.                        */
    /*--------------------------------------------------------------------*/
    if (*--pos >= '5')
    {
	char *ptr = pos;
	while ((*--ptr += 1) > '9') *ptr = '0';
	if (ptr == out) 
	   if (--pos > out) { *pos   = 0; *decpt += 1; return out; }
	   else             { out[1] = 0;              return out; }
    }
	
    *pos = 0;
    return out + 1;
}


feof.c/         925421674   0     0     0       815       `
/*****************************************************************************/
/*  FEOF.C V5.11                                                            */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the function FEOF, which returns a 1 if an EOF      */
/*    has occured on that stream.  The function merely calls a macro         */
/*    that is defined in STDIO.H.                                            */
/*****************************************************************************/
#include <stdio.h>

int feof(FILE *_fp) { return (((_fp)->flags & _STATEOF)); }


ferror.c/       925421674   0     0     0       813       `
/*****************************************************************************/
/*  FERROR.C V5.11                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the function FERROR, which returns a 1 if an I/O    */
/*    error has occured on that stream.  The function merely calls a macro   */
/*    that is defined in STDIO.H.                                            */
/*****************************************************************************/
#include <stdio.h>

int ferror(FILE *_fp) { return (_STCHK(_fp, _STATERR)); }


fflush.c/       925421676   0     0     0       4827      `
/*****************************************************************************/
/*  FFLUSH.C V5.11                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* FUNCTIONS:                                                                */
/*    fflush   -  Call _doflush for all streams that require flushing        */
/*    _doflush -  Flush one stream                                           */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int _ft_end;

int _doflush(FILE *_fp);






/*****************************************************************************/
/* FFLUSH   -  Call _doflush for all streams that require flushing           */
/*                                                                           */
/*    This function returns a 0 upon success, and an EOF upon failure.       */
/*                                                                           */
/*****************************************************************************/
int fflush(register FILE *_fp)
{
   int result = 0;
 
   /*------------------------------------------------------------------------*/
   /* If _fp is not a NULL pointer, call _DOFLUSH for that stream.           */
   /* Otherwise, call _DOFLUSH for all file streams in the table that are    */
   /* active.                                                                */
   /*------------------------------------------------------------------------*/
   if (_fp) result = _doflush(_fp);
   else
   {
      int index;
 
      for(index = 0; index < _ft_end; index++)
         if(_ftable[index].fd != -1) result |= _doflush(&_ftable[index]);
   }
 
   return (result);
}






/*****************************************************************************/
/* _DOFLUSH -  Flush one stream                                              */
/*                                                                           */
/*    This function flushes the stream pointed to by _fp.  If the function   */
/*    is successful, it returns a 0.  If unsuccessful, it returns an EOF     */
/*                                                                           */
/*****************************************************************************/
int _doflush(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*                                                                        */
   /*    num_write   -  The number of bytes to be written to the file        */
   /*    errchk      -  An indicator to see if WRITE was successful          */
   /*------------------------------------------------------------------------*/
   unsigned num_write = _fp->pos - _fp->buf;
   int errchk = 0;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the stream is writable, and it has a buffer, call WRITE, and store  */
   /* its return value in errchk                                             */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODEW)) errchk = write(_fp->fd, (char *)_fp->buf, num_write);
 
   /*------------------------------------------------------------------------*/
   /* If WRITE fails, set the error flag in the stream pointer, and return   */
   /* an EOF                                                                 */
   /*------------------------------------------------------------------------*/
   if(errchk < 0)
   {
      _SET(_fp, _STATERR);
      return (EOF);
   }
 
   /*------------------------------------------------------------------------*/
   /* Reset the buffer pointer, make files opened with the "+" flag          */
   /* available for wither reading or writing, and return a 0, indicating    */
   /* a success                                                              */
   /*------------------------------------------------------------------------*/
   _fp->pos          =  _fp->buf;
   _fp->buff_stop    =  NULL;
   if (_STCHK(_fp, _MODERW)) _UNSET(_fp, (_MODER | _MODEW));
   return 0;
 
}
 

fgetc.c/        925421676   0     0     0       4080      `
/*****************************************************************************/
/*  FGETC.C V5.11                                                           */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    GETC     -  Get a character from a stream                              */
/*    GETCHAR  -  Get a character from stdin                                 */
/*    FGETC    -  Get a character from a stream                              */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int _buff_read(FILE *_fp);
extern int _rd_ok    (FILE *_fp);

int fgetc(register FILE *_fp);






/*****************************************************************************/
/* GETC  -  Get a character from a stream                                    */
/*                                                                           */
/*    This function is equivalent to FGETC.                                  */
/*                                                                           */
/*****************************************************************************/
int getc(FILE *_fp) { return (fgetc(_fp)); }






/*****************************************************************************/
/* GETCHAR  -  Get a character from stdin                                    */
/*                                                                           */
/*    This function calls a macro defined in STDIO.H, which calls FGETC with */
/*    stdin as its argument.                                                 */
/*                                                                           */
/*****************************************************************************/
int getchar(void) { return(_getchar()); }






/*****************************************************************************/
/* FGETC -  Get a character from a stream                                    */
/*****************************************************************************/
int fgetc(register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Make sure that it is OK to read from this stream.                      */
   /*------------------------------------------------------------------------*/
   if(! _rd_ok(_fp)) return (EOF);
   
   /*------------------------------------------------------------------------*/
   /* For non-buffered streams, call the lowlevel READ function.             */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF)
   {
      int   errchk;
      char  result;

      errchk = read(_fp->fd, &result, 1);
      if(errchk <= 0)
      {
         _SET(_fp, (errchk == 0) ? _STATEOF : _STATERR);
         return (EOF);
      }

      return ((int)result);
   }

   /*------------------------------------------------------------------------*/
   /* If the buffer has been entirely read, or is empty, call _BUFF_READ to  */
   /* fill the buffer.                                                       */
   /*------------------------------------------------------------------------*/
   if(_fp->pos == _fp->buff_stop || !_fp->buff_stop) _buff_read(_fp);
 
   /*------------------------------------------------------------------------*/
   /* If the buffer read was unsuccessful, return an EOF.  Otherwise, clear  */
   /* the _UNGETC flag in the stream, and return the next character.         */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, (_STATERR | _STATEOF))) return (EOF);
   _UNSET(_fp, _UNGETC);

   return ((int)*(_fp->pos++)); 
   
}

fgetpos.c/      925421676   0     0     0       1004      `
/*****************************************************************************/
/*  FGETPOS.C V5.11                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This function contains the function FGETPOS, which stores the current  */
/*    position in the file into the variable pointed to by _POS.  A 0 is     */
/*    returned upon success, and upon failure, ERRNO is set to 5, and a -1L  */
/*    is returned.                                                           */
/*****************************************************************************/
#include <stdio.h>
#include <errno.h>
#include "file.h"

int fgetpos(FILE *_fp, fpos_t *_pos)
{
   if((*_pos = ftell(_fp)) != -1L) return (0);
   else { errno = 5; return (-1);  }
}

fgets.c/        925421676   0     0     0       7213      `
/*****************************************************************************/
/*  FGETS.C V5.11                                                           */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FGETS    -  Get a string from a stream                                 */
/*    GETS     -  Get a string from stdin                                    */
/*    _DOFGETS -  Perform the main FGETS routine                             */
/*****************************************************************************/
#include <string.h>
#include <stdio.h>
#include "file.h"

extern int  _rd_ok(FILE *_fp);
extern void _buff_read(FILE *_fp);

static char *_dofgets(char *_ptr, register int _size, register FILE *_fp,
                      int _gets_flag);






/*****************************************************************************/
/* FGETS -  Get a string from a stream                                       */
/*                                                                           */
/*    This function calls _DOFGETS, with a 0 for the _GETS_FLAG argument.    */
/*                                                                           */
/*****************************************************************************/
char *fgets(char *_ptr, register int _size, register FILE *_fp)
{
   return(_dofgets(_ptr, _size, _fp, 0));
}






/*****************************************************************************/
/* GETS  -  Get a string from stdin                                          */
/*                                                                           */
/*    This function calls FGETS with stdin as the stream argument.           */
/*                                                                           */
/*****************************************************************************/
char *gets(char *_ptr) { return (_dofgets(_ptr, 1, stdin, 1)); }






/*****************************************************************************/
/* _DOFGETS -  Perform the main FGETS routine                                */
/*                                                                           */
/*    This function gets a string from the stream _FP.  It returns a pointer */
/*    to the string upon success, or NULL upon failure.                      */
/*                                                                           */
/*****************************************************************************/
static char *_dofgets(char *_ptr, register int _size, register FILE *_fp, 
                      int _gets_flag)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned    char     *next_nl    = NULL;
               char     *fpos       = _ptr;
               size_t   num_left    = _size -1,
                        num_to_read;
               int      skipped_nl  = 0;

   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is readable.                                 */
   /*------------------------------------------------------------------------*/
   if(! _rd_ok(_fp) || _STCHK(_fp, _STATEOF) || (_size -1) < 0) return (NULL);

   /*------------------------------------------------------------------------*/
   /* If the stream is non buffered, read the string in one character at a   */
   /* time, using the lowlevel READ function.                                */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF)
   {
      int errchk;
 
      while((errchk = read(_fp->fd, fpos, 1) > 0) && (*(fpos++) != '\n'));
 
      switch(errchk)
      {
         case  0 :
         case -1 : return (NULL);
      }
 
      *fpos = '\0';
 
      return (_ptr);
   }
 
   while((num_left > 0 || _gets_flag) && ! next_nl)
   {
      /*---------------------------------------------------------------------*/
      /* If the buffer is empty or completely read, fill it up.  If the read */
      /* is unsuccessful, return a NULL                                      */
      /*---------------------------------------------------------------------*/
      if(_fp->pos == _fp->buff_stop || !_fp->buff_stop) _buff_read(_fp);
      if(_STCHK(_fp, (_STATERR | _STATEOF))) return (NULL);

      /*---------------------------------------------------------------------*/
      /* Determine the location of the next newline character (NEXT_NL).     */
      /*---------------------------------------------------------------------*/
      next_nl = (unsigned char *)memchr(_fp->pos, '\n', (_fp->buff_stop - 
                                        _fp->pos));

      /*---------------------------------------------------------------------*/
      /* Determine how many characters to read from the buffer.  If this     */
      /* function was called from GETS (_GETS_FLAG == 1), read until a       */
      /* newline character, EOF character, or the end of the buffer is       */
      /* encountered.  Do the same otherwise, but do not read any more       */
      /* characters than specified by NUM_LEFT.                              */
      /*---------------------------------------------------------------------*/
      num_to_read =  _fp->buff_stop - _fp->pos;
      num_to_read =  (next_nl) ? (next_nl - _fp->pos + 1) : num_to_read;
      num_to_read =  (_gets_flag) ? num_to_read :
                     (num_left < num_to_read) ? num_left : num_to_read;

      /*---------------------------------------------------------------------*/
      /* If this function was called from GETS (_GETS_FLAG == 1), do not     */
      /* retain a newline character if one is present                        */
      /*---------------------------------------------------------------------*/
      if(next_nl && _gets_flag)
      {
         num_to_read--;
         skipped_nl = 1;
      }

      /*---------------------------------------------------------------------*/
      /* Copy the characters, and update pointers and counters.              */
      /*---------------------------------------------------------------------*/
      memcpy(fpos, _fp->pos, num_to_read);
      _fp->pos += (skipped_nl + num_to_read);
      num_left -= num_to_read;
      fpos += num_to_read;
   }

   /*------------------------------------------------------------------------*/
   /* Tack on the NULL terminator, clear the _UNGETC flag and the _GETS_FLAG.*/
   /*------------------------------------------------------------------------*/
   *fpos = '\0';
   _UNSET(_fp, _UNGETC);
   _gets_flag = 0; 

   return(_ptr);
}


floor.c/        925421676   0     0     0       774       `
/*****************************************************************************/
/* floor.c V5.11 for TMS3203x/4x                                            */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <math.h>

/****************************************************************************/
/*  FLOOR() - Floor							    */
/*									    */
/*  Floor returns the integer closest to x, that is <= x		    */
/****************************************************************************/
double floor(double x)
{
     double y; 
     return (modf(x, &y) < 0 ? y - 1.0 : y);
}
fmod.c/         925421676   0     0     0       1818      `
/*****************************************************************************/
/* fmod.c V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <math.h>

/****************************************************************************/
/*  FMOD() - Floating point remainder                                       */
/*									    */
/*  Returns the remainder after dividing x by y an integral number of times.*/
/*                                                                          */
/****************************************************************************/
double fmod(double x, double y)
{
   double d = fabs(x); 
   double e = fabs(y);

   /*************************************************************************/
   /* if y is too small or y == x, any remainder is negligible.             */
   /*************************************************************************/
   if (d - e == d || d == e) return (0.0);

   /*************************************************************************/
   /* if x and y are integers, just do a %.                                 */
   /*************************************************************************/
   if (((float)(int)d == d) && ((float)(int)e == e))
      return ((float)((int)x % (int)y));

   /*************************************************************************/
   /* otherwise, divide; result = dividend - (quotient * divisor)           */
   /*************************************************************************/
   modf(x/y, &d);
   return (x - d * y);
}
fopen.c/        925421678   0     0     0       8879      `
/*****************************************************************************/
/*  FOPEN.C V5.11                                                           */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* FUNCTIONS:                                                                */
/*    FOPEN       -  Open a file and return a pointer to it                  */
/*    FREOPEN     -  Switch a FILE pointer to a different stream             */
/*    _OPENFILE   -  Set file flags, and call lowlevel OPEN                  */
/*    _SEARCH_FP  -  Find an open slot in the file table                     */
/*****************************************************************************/
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "file.h"
 
extern int    _ft_end;
extern void   _cleanup(void);
extern void   (*_cleanup_ptr)(void);
 
static FILE *_search_fp(void);
static FILE *_openfile(const char *_fname, register FILE *_fp, const char
                       *_mode);
       void _cleanup();


/*****************************************************************************/
/* FOPEN    -  Open a file and return a pointer to it                        */
/*                                                                           */
/*    This function calls _SEARCH_FP to locate an empty slot in the file     */
/*    table (_ftable), and calls _OPENFILE with it to open a stream to the   */
/*    file _FNAME.  It returns a pointer to the stream that was allocated,   */
/*    or NULL if it was not successful.                                      */
/*                                                                           */
/*****************************************************************************/
FILE *fopen(const char *_fname, const char *_mode)
{
   return (_openfile(_fname, _search_fp(), _mode));
}

 
/*****************************************************************************/
/* FREOPEN  -  Switch a FILE pointer to a different stream                   */
/*                                                                           */
/*    This function attempts to close any file associated with _FP, and then */
/*    reassigns _FP to the file _FNAME by calling _OPENFILE.  It returns a   */
/*    pointer to the stream if successful, or NULL if the function is not    */
/*    successful.                                                            */
/*                                                                           */
/*****************************************************************************/
FILE *freopen(const char *_fname, const char *_mode, register FILE *_fp)
{
   fclose(_fp); 
   return (_openfile(_fname, _fp, _mode));
}


/*****************************************************************************/
/* _SEARCH_FP  -  Find an open slot in the file table                        */
/*                                                                           */
/*    This function looks through the array _ftable, searching for a null    */
/*    pointer which indicates an empty slot.  It mallocs a stream for that   */
/*    slot, and assigns a pointer to it there, initializing it and returning */
/*    it to the calling function.                                            */
/*                                                                           */
/*****************************************************************************/
static FILE *_search_fp(void)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int index;
	
   /*------------------------------------------------------------------------*/
   /* Search the file table for an empty slot.  Return a NULL is there       */
   /* aren't any available.                                                  */
   /*------------------------------------------------------------------------*/
   for(index = 0; (index < _ft_end) && _ftable[index].fd != -1; index++);
   if (index == _NFILE) return (NULL);
   if (index == _ft_end) _ft_end++;

   /*------------------------------------------------------------------------*/
   /* Initialize the new stream.                                             */
   /*------------------------------------------------------------------------*/
   memset(&_ftable[index], '\0', sizeof(FILE));

   return (&_ftable[index]);
}
 

/*****************************************************************************/
/* _OPENFILE   -  Set file flags, and call lowlevel OPEN                     */
/*                                                                           */
/*    This function sets FILE flags for reading or writing by the character  */
/*    string _MODE.  It then calls the lowlevel OPEN function to open the    */
/*    file, and assigns the file descriptor returned from that function into */
/*    the FD member of the stream.                                           */
/*                                                                           */
/*****************************************************************************/
static FILE *_openfile(const char *_fname, register FILE *_fp, const char 
                       *_mode)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int         wr, 
               bin, 
               plus;
   unsigned    lflags   =  0;

   if (! _fp) return (NULL);
 
   /*------------------------------------------------------------------------*/
   /* SETUP _CLEANUP_PTR SO THAT ALL OPENED FILES WILL BE CLOSED AT EXIT.    */
   /*------------------------------------------------------------------------*/
   _cleanup_ptr = _cleanup;
   
   /*------------------------------------------------------------------------*/
   /* Set the flags in the stream to reflect to I/O mode of the stream to be */
   /* opened.                                                                */
   /*------------------------------------------------------------------------*/
   wr    = _mode[0];
   bin   = ((_mode[1] == 'b') || (_mode[2] == 'b'));
   plus  = ((_mode[1] == '+') || (_mode[2] == '+'));
 
   _fp->flags = 0;

   if(!plus)
      _SET(_fp, (wr == 'r') ? _MODER : 
                (wr == 'w' || wr == 'a') ? _MODEW : 0);

   _SET(_fp, (wr == 'a') ? _MODEA : 0);
   _SET(_fp, (bin)  ? _MODEBIN : 0);
   _SET(_fp, (plus) ? _MODERW  : 0);
 
   if(bin) lflags |= (O_BINARY);

   /*------------------------------------------------------------------------*/
   /* Set the flags in LFLAGS to reflect the flags that will be necessary to */
   /* call the lowlevel OPEN function properly for this stream.              */
   /*------------------------------------------------------------------------*/
   switch (wr)
   {
      case 'r' : lflags |= (plus) ? O_RDWR : O_RDONLY;
                 break;
 
      case 'a' : lflags |= (plus) ? O_RDWR : O_WRONLY;
                 lflags |= (O_APPEND | O_CREAT);
                 break;
 
      case 'w' : lflags |= (plus) ? O_RDWR : O_WRONLY;
                 lflags |= (O_TRUNC | O_CREAT);
                 break;
   }

   /*------------------------------------------------------------------------*/
   /* Call the lowlevel OPEN function, and store the returned file           */
   /* descriptor into the stream.  If the OPEN function fails, return NULL.  */
   /*------------------------------------------------------------------------*/
   if ((_fp->fd = open(_fname, lflags, 0666)) < 0) return (NULL);

   return (_fp);
}


/*****************************************************************************/
/* _CLEANUP   -  CLOSE ALL OPEN STREAMS.  THIS IS CALLED BY EXIT() IF A FILE */
/*               IS EVER OPENED OR A BUFFER IS EVER CREATED.                 */
/*****************************************************************************/
void _cleanup(void)
{
   int j;

   /*------------------------------------------------------------------------*/
   /* CLOSE ALL STREAMS THAT ARE CURRENTLY OPEN.                             */
   /*------------------------------------------------------------------------*/
   fclose(&_ftable[0]);
   for(j = 1; j < _ft_end; j++) 
       if (_ftable[j].fd > 0) fclose(&_ftable[j]); 
}

fprintf.c/      925421678   0     0     0       2893      `
/*****************************************************************************/
/*  FPRINTF.C V5.11                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FPRINTF  -  Print formatted output to a stream                         */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op, 
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));

static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);






/*****************************************************************************/
/* FPRINTF  -  Print formatted output to a stream                            */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream _FP.              */
/*                                                                           */
/*****************************************************************************/
int fprintf(FILE *_fp, const char *_format, ...)
{
   va_list  _ap;
   int rval;
   char *fptr = (char *)_format;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (-1);

   va_start(_ap, _format);
   rval = _printfi(&fptr, _ap, (void *)_fp, _outc, _outs);
   va_end(_ap);
   return (rval);
}
 
 
 
 
 

/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }






/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }


fputc.c/        925421678   0     0     0       4380      `
/*****************************************************************************/
/*  FPUTC.C V5.11                                                           */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PUTC     -  Write a character to a stream                              */
/*    PUTCHAR  -  Write a character to stdout                                */
/*    FPUTC    -  Write a character to a stream                              */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int _wrt_ok(FILE *_fp);
extern int _doflush(FILE *_fp);






/*****************************************************************************/
/* PUTC  -  Write a character to a stream                                    */
/*                                                                           */
/*    This function is equivalent to FPUTC.                                  */
/*                                                                           */
/*****************************************************************************/
int putc(int _x, FILE *_fp) { return(fputc(_x, _fp)); }






/*****************************************************************************/
/* PUTCHAR  -  Write a character to stdout                                   */
/*                                                                           */
/*    This function calls a macro defined in STDIO.H, which in turn calls    */
/*    FPUTC, with stdout as its stream argument.                             */
/*                                                                           */
/*****************************************************************************/
int putchar(int _x) { return(_putchar(_x)); }






/*****************************************************************************/
/* FPUTC -  Write a character to a stream                                    */
/*                                                                           */
/*    This function writes character _C into the stream specified by _FP.    */
/*    Upon success, it returns the character written.  Upon failure, it      */
/*    returns an EOF.                                                        */
/*                                                                           */
/*****************************************************************************/
int fputc(int _c, register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is writeable.                                */
   /*------------------------------------------------------------------------*/
   if(! _wrt_ok(_fp)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the stream is non-buffered, call the lowlevel WRITE function.       */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF)
   {
      char cbuf = (char)_c;

      if((write(_fp->fd, &cbuf, 1)) == -1)
      {
         _SET(_fp, _STATERR);
         return (EOF);
      }
      else return ((unsigned char)_c);
   }

   /*------------------------------------------------------------------------*/
   /* Put the character in the buffer.                                       */
   /*------------------------------------------------------------------------*/
   *(_fp->pos++) = (unsigned char)_c;

   /*------------------------------------------------------------------------*/
   /* If the buffer is full, or a line-buffered stream reached a newline     */
   /* character, flush it.                                                   */
   /*------------------------------------------------------------------------*/
   if((_fp->pos == _fp->bufend) || (_STCHK(_fp, _IOLBF) && _c == '\n'))
      if(_doflush(_fp))
      {
         _SET(_fp, _STATERR);
         return (EOF);
      }

   return((unsigned char)_c);
}

fputs.c/        925421678   0     0     0       4797      `
/*****************************************************************************/
/*  FPUTS.C V5.11                                                           */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PUTS  -  Write a string to stdout                                      */
/*    FPUTS -  Write a string to a stream                                    */
/*****************************************************************************/
#include <string.h>
#include <stdio.h>
#include "file.h"

extern int _wrt_ok(FILE *_fp);
extern int _doflush(FILE *_fp);






/*****************************************************************************/
/* PUTS  -  Write a string + newline to stdout.                              */
/*                                                                           */
/*    This function calls FPUTS, with stdout as the stream argument.         */
/*                                                                           */
/*****************************************************************************/
int puts(const char *_ptr) 
{ 
    int count = fputs(_ptr, stdout);
    count += fputs("\n", stdout); 
    return count;
}



/*****************************************************************************/
/* FPUTS -  Write a string to a stream                                       */
/*                                                                           */ 
/*    This function writes string _PTR to stream _FP, returning the number   */
/*    of characters written upon success, or an EOF upon failure.            */
/*                                                                           */ 
/*****************************************************************************/
int fputs(const char *_ptr, register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   size_t   num_left;
   char     *fpos          = (char *)_ptr;
   int      room_left,
            flush_flag     = 0,
            num_to_write;

   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is writeable.                                */
   /*------------------------------------------------------------------------*/
   if(! _wrt_ok(_fp)) return (EOF);
 
   room_left = (int)(_fp->bufend - _fp->pos);
   num_left = strlen(_ptr);

   /*------------------------------------------------------------------------*/
   /* If the stream is non-buffered, call the lowlevel WRITE function.       */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF) return (write(_fp->fd, _ptr, num_left));
 
   /*------------------------------------------------------------------------*/
   /* Write the string into the buffer, flushing it when full.               */
   /*------------------------------------------------------------------------*/
   while(num_left > 0)
   {
      num_to_write = (num_left > room_left) ? room_left : num_left;
      if((_BUFFMODE(_fp) == _IOLBF) && memchr(fpos, '\n', num_to_write))
      { 
         num_to_write = (char *)memchr(fpos, '\n', num_to_write) - fpos + 1;
         flush_flag = 1;
      }
      memcpy(_fp->pos, fpos, num_to_write);

      /*---------------------------------------------------------------------*/
      /* Update pointers and counters.                                       */
      /*---------------------------------------------------------------------*/
      _fp->pos  += num_to_write;
      fpos      += num_to_write;
      num_left  -= num_to_write;
      room_left -= num_to_write;

      /*---------------------------------------------------------------------*/
      /* If the buffer is full, flush it.  Any I/O errors cause this         */
      /* function to exit, returning an EOF.                                 */
      /*---------------------------------------------------------------------*/
      if(room_left == 0 || flush_flag)
      {
         if(_doflush(_fp))
         {
            _SET(_fp, _STATERR);
            return (EOF);
         }
         room_left = (int)(_fp->bufend - _fp->pos);
         _SET(_fp, _MODEW);
         flush_flag = 0;
      }
   }
   return(strlen(_ptr));
}


fread.c/        925421678   0     0     0       4588      `
/*****************************************************************************/
/*  FREAD.C V5.11                                                           */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FREAD       -  Read a block of bytes from a stream                     */
/*****************************************************************************/
#include <string.h>
#include <stdio.h>
#include "file.h"
 
extern int  _rd_ok(FILE *_fp);
extern void _buff_read(FILE *_fp);





/*****************************************************************************/
/* FREAD -  Read a block of bytes from a stream                              */
/*                                                                           */
/*    This function reads _COUNT blocks of _SIZE size from stream _FP, and   */
/*    stores them in string _PTR.  The function returns the number of        */
/*    blocks read.                                                           */
/*                                                                           */
/*****************************************************************************/
size_t fread(void *_ptr, size_t _size, size_t _count, FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned char     *fpos       = (unsigned char *)_ptr;
            size_t   num_left    = _size * _count,
                     num_read    = 0,
                     num_to_read = 0;
 
   /*------------------------------------------------------------------------*/
   /* Make sure that the file is readable.                                   */
   /*------------------------------------------------------------------------*/
   if(! _rd_ok(_fp) || _size == 0 || _count == 0) return (0);
 
   while (num_left > 0)
   {
      /*---------------------------------------------------------------------*/
      /* If the stream is non-buffered, call the lowlevel READ function.     */
      /*---------------------------------------------------------------------*/
      if(_BUFFMODE(_fp) == _IONBF)
      {
         num_read = (size_t)(read(_fp->fd, (char *)fpos, num_left));
         if(num_read != num_left)
         {
            _SET(_fp, (num_read == 0) ? _STATEOF : _STATERR);
            if ((int)num_read == -1) num_read = 0;
         }
         return (num_read / _size);
      }

      /*---------------------------------------------------------------------*/
      /* If the buffer has been completely read, fill it up.  Exit the loop  */
      /* if an I/O error occurs, or the end of the file is reached.          */
      /*---------------------------------------------------------------------*/
      if(_fp->pos == _fp->buff_stop || !_fp->buff_stop)  _buff_read(_fp);
      if(_STCHK(_fp, (_STATERR | _STATEOF))) break;

      /*---------------------------------------------------------------------*/
      /* Determine how many characters can fit in the buffer, and read them  */
      /* in.                                                                 */
      /*---------------------------------------------------------------------*/
      num_to_read = (num_left < (_fp->buff_stop - _fp->pos)) ?
                    num_left : (_fp->buff_stop - _fp->pos);
      memcpy(fpos, _fp->pos, num_to_read);

      /*---------------------------------------------------------------------*/
      /* Update pointers and counters.                                       */
      /*---------------------------------------------------------------------*/
      fpos += num_to_read;
      _fp->pos += num_to_read;
      num_read += num_to_read;
      num_left -= num_to_read;
   
 
   }

   /*------------------------------------------------------------------------*/
   /* Clear the _UNGETC flag in the stream, and return the number of blocks  */
   /* read.                                                                  */
   /*------------------------------------------------------------------------*/
   _UNSET(_fp, _UNGETC);
 
   return (num_read / _size);
 
}
 
fscanf.c/       925421680   0     0     0       5715      `
/*****************************************************************************/
/*  FSCANF.C V5.11                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FSCANF      -  Read formatted input from a stream                      */
/*    SCANF       -  Read formatted input from stdin                         */
/*    _INPCHAR    -  Get a character from the stream                         */
/*    _UNINPCHAR  -  Put a character back onto the stream                    */
/*    _CHKMBC     -  Check that the characters match the input               */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <ctype.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

static char _inpchar(void **inp);
static void _uninpchar(void **inp, char outchar);
static int _chkmbc(void **inp, char **_format, int *num_read);






/*****************************************************************************/
/* FSCANF   -  Read formatted input from a stream                            */
/*                                                                           */
/*    This function returns the number of arguments that were assigned a     */
/*    value.                                                                 */
/*                                                                           */ 
/*****************************************************************************/
int fscanf(FILE *_fp, const char *_fmt, ...)
{
   va_list _ap;
   va_start(_ap, _fmt);
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if (_fp->fd == -1) return (EOF);

   return (_scanfi((void *)_fp, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));
   
}






/*****************************************************************************/
/* SCANF -  Read formatted input from stdin                                  */
/*                                                                           */ 
/*    This function returns the number of arguments that were assigned a     */
/*    value.                                                                 */
/*                                                                           */ 
/*****************************************************************************/ 
int scanf(const char *_fmt, ...)
{
   va_list _ap;
   va_start(_ap, _fmt);
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if (stdin->fd == -1) return (EOF);

   return (_scanfi((void *)stdin, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));
 
}




 


/*****************************************************************************/
/* _INPCHAR -  Get a character from the stream                               */
/*****************************************************************************/
static char _inpchar(void **inp) { return (fgetc((FILE *)(*inp))); }






/*****************************************************************************/
/* _UNINPCHAR  -  Put a character back onto the stream                       */
/*****************************************************************************/
static void _uninpchar(void **inp, char outchar)
{ 
   ungetc(outchar, (FILE *)*inp);
}






/*****************************************************************************/
/* _CHKMBC  -  Check that the characters match the input                     */
/*                                                                           */
/*    Check that all characters in the format string that are not part of a  */
/*    conversion specification match the input, until the next '%' or the    */
/*    end of the format string is reached.  The function returns an EOF if   */
/*    the end of the file is reached prematurely, a 0 upon reaching the end  */
/*    of the format string, or a 1 if a '%' is encountered.                  */
/*                                                                           */
/*****************************************************************************/
static int _chkmbc(void **inp, char **_format, int *num_read)
{
   FILE        *_fp = (FILE *)*inp;
   signed char  c;

   /*------------------------------------------------------------------------*/
   /* If there is a white space character in the format statement, skip to   */
   /* the next non-white space character in the input.                       */
   /*------------------------------------------------------------------------*/
   while (isspace(**_format))
   {
      for(c = fgetc(_fp);isspace(c);c = fgetc(_fp)) (*num_read)++;
      ungetc(c, _fp);
      (*_format)++;
   }

   for(;(**_format != '%') && (**_format != '\0');)
      if (*((*_format)++) != (c = fgetc(_fp))) 
      {
         ungetc(c, _fp);
         return ((c == EOF) ? EOF : 0);
      }
      else (*num_read)++;

   if (**_format == '%') return 1;
   else return (0);
}
      

fseek.c/        925421680   0     0     0       2310      `
/*****************************************************************************/
/*  FSEEK.C V5.11                                                           */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FSEEK -  Reposition the file pointer of a stream                       */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int _doflush(FILE *_fp);




/*****************************************************************************/ 
/* FSEEK -  Reposition the file pointer of a stream                          */
/*                                                                           */ 
/*    This funtion flushes stream _FP, clears the EOF and I/O Error flags,   */
/*    repositions the file pointer of the stream.  It returns a 0 upon       */
/*    success, and an EOF upon failure.                                      */
/*                                                                           */ 
/*****************************************************************************/ 
int fseek(register FILE *_fp, long _offset, int _ptrname)
{
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* When positioning to a location relative to the current location,       */
   /* adjust for the fact that there may be something in the buffer.         */
   /*------------------------------------------------------------------------*/
   if(_ptrname == SEEK_CUR && _STCHK(_fp, _MODER))
      _offset -= (_fp->buff_stop - _fp->pos);

   _doflush(_fp);

   _UNSET(_fp, (_STATEOF | _UNGETC));
   
   if((lseek(_fp->fd, _offset, _ptrname)) == -1) return (EOF);
   
   return (0);
}
   
fsetpos.c/      925421680   0     0     0       1092      `
/*****************************************************************************/
/*  FSETPOS.C V5.11                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FSETPOS  -  Position the file indicator for stream _FP                 */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int errno;
extern int _doflush(FILE *_fp);






/*****************************************************************************/
/* FSETPOS  -  Position the file indicator for stream _FP                    */
/*****************************************************************************/
int fsetpos(FILE *_fp, const fpos_t *_pos)
{
   return (fseek(_fp, *_pos, SEEK_SET));
}

ftell.c/        925421680   0     0     0       3108      `
/*****************************************************************************/
/*  FTELL.C V5.11                                                           */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int errno;
extern int _ft_end;






/*****************************************************************************/
/* FTELL -  Get the location of the file pointer in a stream                 */
/*                                                                           */
/*    This function gets the current location of the file pointer for the    */
/*    given stream, and returns it after adjusting it for any inaccuracies   */
/*    that buffering might have caused.                                      */
/*                                                                           */
/*****************************************************************************/
long ftell(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   fpos_t  _pos;
   int   adjust   = 0;

   /*------------------------------------------------------------------------*/
   /* If the stream pointer given is not currently open, return a -1.        */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) { errno = 5; return (-1L);}

   /*------------------------------------------------------------------------*/
   /* For files in read mode, we must subtract the unread data in the buffer */
   /* from the location of the file pointer.  For files in write mode, we    */
   /* must add the data in the buffer that has not yet gone to disk.         */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODER) && _fp->buff_stop > _fp->pos)
      adjust = -(_fp->buff_stop - _fp->pos);
   if(_STCHK(_fp, _MODEW)) adjust = (_fp->pos - _fp->buf); 
 
   /*------------------------------------------------------------------------*/
   /* Get the file pointer's position                                        */
   /*------------------------------------------------------------------------*/
   _pos = lseek(_fp->fd, 0L, SEEK_CUR);

   /*------------------------------------------------------------------------*/
   /* If the call to lseek was unsuccessful, return an -1                    */
   /*------------------------------------------------------------------------*/
   if(_pos < 0) { errno = 5; return (-1L);}

   /*------------------------------------------------------------------------*/
   /* Make the necessary adjustment, and return the value                    */
   /*------------------------------------------------------------------------*/
   _pos += adjust;
   return (_pos);
}

fwrite.c/       925421680   0     0     0       7111      `
/*****************************************************************************/
/*  FWRITE.C V5.11                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FWRITE   -  Write a block of bytes to a stream                         */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <stdlib.h>
#include <string.h>
 
extern int _doflush(FILE *_fp);
extern int _wrt_ok(FILE *_fp);





 
/*****************************************************************************/
/* FWRITE   -  Write a block of bytes to a stream                            */
/*                                                                           */
/*    This function reads _COUNT blocks of size _SIZE from a buffer          */
/*    pointed to by _PTR, and writes them to stream _FP.  It returns the     */
/*    number of blocks successfully written.                                 */
/*                                                                           */
/*****************************************************************************/
size_t fwrite(const void *_ptr, size_t _size, size_t _count,
              register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned char    *fpos       = (unsigned char *)_ptr;
   unsigned char    *nl_pos;
            size_t   buffer_size = (_fp->bufend - _fp->buf),
                     next_nl,
                     room_left;
            size_t   num_left    = _size * _count,
                     num_to_write,
                     num_written  = 0;

   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is writeable.                                */
   /*------------------------------------------------------------------------*/
   if(! _wrt_ok(_fp) || _size == 0 || _count == 0) return (0);
 
   room_left   = (_fp->bufend - _fp->pos);
   next_nl     = (char *)memchr(fpos, '\n', num_left) - (char *)fpos + 1;
 
   while (num_left > 0)
   {
      /*---------------------------------------------------------------------*/
      /* Determine how many characters should be written based on buffering  */
      /* mode.  For non-buffered streams, call the lowlever WRITE function.  */
      /* For fully buffered streams, put as many characters in the buffer as */
      /* possible.  For line buffered streams, put characters into the       */
      /* util the buffer is full, the last character is reached, or a        */
      /* newline character is reached.                                       */
      /*---------------------------------------------------------------------*/
      switch (_BUFFMODE(_fp))
      {
         case _IONBF : num_written = (write(_fp->fd, (char *)fpos, num_left));
                       if(num_written != num_left)
                       {
                          _SET(_fp, _STATERR);
                          if ((int)num_written == -1) num_written = 0;
                       }
                       return (num_written / _size);
 
         case _IOFBF : num_to_write = (room_left > num_left) ? 
                       num_left : room_left;
                       break;
 
         case _IOLBF : num_to_write = (room_left > next_nl) ? next_nl :
                       (room_left > num_left) ? num_left : room_left;
                       break;
 
         default     : return (0);
      }
 
      /*---------------------------------------------------------------------*/
      /* Write the data to the buffer, and update the buffer pointer and the */
      /* ROOM_LEFT coutner.                                                  */
      /*---------------------------------------------------------------------*/
      memcpy(_fp->pos, fpos, num_to_write);
      _fp->pos += num_to_write;
      room_left = (_fp->bufend - _fp->pos);

      /*---------------------------------------------------------------------*/
      /* If the buffer is full, or a newline character has been encountered  */
      /* on a line-buffered stream, flush it.                                */
      /*---------------------------------------------------------------------*/
      if (room_left == 0 || (_STCHK(_fp, _IOLBF) && num_to_write == next_nl))
      {
         if(_doflush(_fp))
         {
            _SET(_fp, _STATERR); 
            return (num_written / _size);
         }
         room_left = buffer_size;

         /*------------------------------------------------------------------*/
         /* The _DOFLUSH function clears the write flag on streams opened in */
         /* update mode.  Make sure that the write flag is still set here.   */
         /*------------------------------------------------------------------*/
         _SET(_fp, _MODEW);
      }

      /*---------------------------------------------------------------------*/
      /* Update pointers and counters.                                       */
      /*---------------------------------------------------------------------*/
      num_written += num_to_write;
      fpos += num_to_write;
      num_left -= num_to_write;
 
      /*---------------------------------------------------------------------*/
      /* For line-buffered streams, find the next occurance of a newline     */
      /* character.  If there are no more, and the remaining data will fit   */
      /* in the buffer, exit the loop where the remaining data will be moved */
      /* there.  Otherwise loop until this condition is true.                */
      /*---------------------------------------------------------------------*/
      if (_STCHK(_fp, _IOLBF))
      {
         nl_pos = (unsigned char *)memchr((fpos + 1), '\n', 
					  (num_left > 0) ? (num_left-1) : 0);
         if (! nl_pos)
         {
            if (num_left < room_left) break;
            else next_nl = buffer_size + 1;
         }
         else next_nl = (nl_pos - fpos) + 1;
      }
   }

   /*------------------------------------------------------------------------*/
   /* Copy the rest of the characters into the buffer for line-buffered      */
   /* streams.                                                               */
   /*------------------------------------------------------------------------*/
   if (_STCHK(_fp, _IOLBF))
   {
      memcpy(_fp->pos, fpos, num_left);
      num_written += num_left;
      _fp->pos += num_left;
   }
 
   return (num_written / _size);
}
 

gmtime.c/       925421682   0     0     0       590       `
/*****************************************************************************/
/* gmtime.c V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <time.h>

struct tm *gmtime(const time_t *timer)
{
    time_t gtime = _tz.timezone;     /* DIFFERENCE BETWEEN CURRENT TIME ZONE */
				     /*   AND GMT                            */

    if (timer) gtime += *timer;
    return localtime(&gtime);
}
isxxx.c/        925421682   0     0     0       984       `
/*****************************************************************************/
/* isxxx.c V5.11 for TMS3203x/4x                                            */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <ctype.h>

int isalnum(int c)  { return _isalnum(c);  }
int isalpha(int c)  { return _isalpha(c);  }
int isascii(int c)  { return _isascii(c);  }           /* NON-STANDARD */
int iscntrl(int c)  { return _iscntrl(c);  }
int isdigit(int c)  { return _isdigit(c);  }
int isgraph(int c)  { return _isgraph(c);  }
int islower(int c)  { return _islower(c);  }
int isprint(int c)  { return _isprint(c);  }
int ispunct(int c)  { return _ispunct(c);  }
int isspace(int c)  { return _isspace(c);  }
int isupper(int c)  { return _isupper(c);  }
int isxdigit(int c) { return _isxdigit(c); }
localtim.c/     925421682   0     0     0       1147      `
/*****************************************************************************/
/* localtime.c V5.11 for TMS3203x/4x                                        */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <time.h>

struct tm *localtime(const time_t *timer)
{
   static struct tm local;
   time_t ltime  = timer ? *timer : 0;

   local.tm_sec  = 0;
   local.tm_min  = 0;
   local.tm_hour = 0;
   local.tm_mday = 1;
   local.tm_mon  = 0;
   local.tm_year = 0;

   if (timer == 0 || ltime == (time_t)-1) return &local;

   /*------------------------------------------------------------------*/
   /* MAKE SURE THE NUMBER OF SECONDS SINCE Jan 1, 1900 CAN BE         */
   /* REPRESENTED IN A SIGNED INT.                                     */
   /*------------------------------------------------------------------*/
   if ((int)ltime < 0)
   {
       local.tm_sec  = ltime % 60; 
       local.tm_min  = ltime / 60; 
   }
   else local.tm_sec = ltime;

   mktime(&local);
   return &local;
}


log.c/          925421682   0     0     0       4863      `
/*****************************************************************************/
/* log.c V5.11 for TMS3203x/4x                                              */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/

#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  LOG() - natural log							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 5.              */
/*									    */
/*  N = exponent x							    */
/*  f = mantissa x, 0.5 <= f < 1					    */
/*  if f < sqrt(0.5), znum = f - 0.5, zden = znum * 0.5 + 0.5		    */
/*  if f > sqrt(0.5), znum = f - 1, zden = f * 0.5 + 0.5		    */
/*  z = znum / zden							    */
/*  w = z * z								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = R + N * ln(2)						    */
/****************************************************************************/
double log(double x)
{
    int n;

#if defined(_TMS320C30) || defined(_TMS320C40)
    double x2;

    /************************************************************************/
    /* check for errors in domain and range                                 */
    /************************************************************************/
    if (x <= 0) { errno = (x == 0) ? ERANGE : EDOM; return (-HUGE_VAL); }

    /************************************************************************/
    /* x = mantissa of x, n = exponent of x                                 */
    /************************************************************************/
    x = 2.0 * frexp(x, &n);
    --n;

    /************************************************************************/
    /* log2(x) is approximately (x - sqrt(2) / x + sqrt(2))                 */
    /************************************************************************/
    x = (x - SQRTWO) / (x + SQRTWO);

    /************************************************************************/
    /* polynomial expansion for log2(x)                                     */
    /************************************************************************/
    x2 = x * x;
    x  = ((((L7 * x2 + L5) * x2 + L3) * x2 + L1) * x + 0.5);

    /************************************************************************/
    /* log2(x) = log2(mantissa(x)) + exponent(x)                            */
    /************************************************************************/
    return ((x + n) * LOGe2);
#else
    double a, b, f, r, w, z, znum;

    /************************************************************************/
    /* check for errors in domain and range                                 */
    /************************************************************************/
    if (x <= 0) { errno = (x == 0) ? ERANGE : EDOM; return (-HUGE_VAL); }

    /************************************************************************/
    /* f = mantissa(x), n = exponent(x)            			    */
    /************************************************************************/
    f = frexp(x, &n);

    /************************************************************************/
    /* for numbers <= sqrt(0.5)                                             */
    /************************************************************************/
    if (f <= SQRTHALF)
    {
	--n;
	znum = f - 0.5;
	z    = znum / (znum * 0.5 + 0.5);
    }

    /************************************************************************/
    /* for numbers > sqrt(0.5)                                              */
    /************************************************************************/
    else
    {
	znum = (f - 0.5) - 0.5;
	z    = znum / (f * 0.5 + 0.5);
    }

    /************************************************************************/
    /* determine polynomial expression                                      */
    /************************************************************************/
    w = z * z;

    a = A0;
    b = w + B0;

    /************************************************************************/
    /* calculate the natural log of (mant x) / 2                            */
    /************************************************************************/
    r = z + z * w * (a / b);

    /************************************************************************/
    /* ln(x) = ln (mant x) + 2 * (exp x) (but more mathematically stable)   */
    /************************************************************************/
    return ((n * C4 + r) + n * C3);
#endif
}

log10.c/        925421682   0     0     0       4331      `
/*****************************************************************************/
/* log10.c V5.11 for TMS3203x/4x                                            */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  LOG10() - Logarithm							    */
/*									    */
/*  result = log10(e) * log(x)						    */
/****************************************************************************/
double log10(double x)
{
    int n;

#if defined(_TMS320C30) || defined(_TMS320C40)
    double x2;

    /*********************************************************************/
    /* check for domain and range errors                                 */
    /*********************************************************************/
    if (x <= 0) { errno = (x == 0) ? ERANGE : EDOM; return (-HUGE_VAL); }

    /*********************************************************************/
    /* x = mantissa of x, n = exponent of x                              */
    /*********************************************************************/
    x = 2.0 * frexp(x, &n);
    --n;

    /*********************************************************************/
    /* log2(x) is approximately (x - sqrt(2) / x + sqrt(2))              */
    /*********************************************************************/
    x = (x - SQRTWO) / (x + SQRTWO);

    /*********************************************************************/
    /* polynomial expansion for log2(x)                                  */
    /*********************************************************************/
    x2 = x * x;
    x  = ((((L7 * x2 + L5) * x2 + L3) * x2 + L1) * x + 0.5);

    /*********************************************************************/
    /* log2(x) = log2(mantissa(x)) + exponent(x)                         */
    /*********************************************************************/
    return ((x + n) * LOG102);
#else
    double a, b, f, r, w, z, znum;

    /*********************************************************************/
    /* check for domain and range errors                                 */
    /*********************************************************************/
    if (x <= 0) { errno = (x == 0) ? ERANGE : EDOM; return (-HUGE_VAL); }

    /*********************************************************************/
    /* f = mantissa(x), n = exponent(x)                                  */
    /*********************************************************************/
    f = frexp(x, &n);

    /*********************************************************************/
    /* for numbers < sqrt(0.5)                                           */
    /*********************************************************************/
    if (f <= SQRTHALF)
    {
	--n;
	znum = f - 0.5;
	z    = znum / (znum * 0.5 + 0.5);
    }

    /*********************************************************************/
    /* for numbers > sqrt(0.5)                                           */
    /*********************************************************************/
    else
    {
	znum = (f - 0.5) - 0.5;
	z    = znum / (f * 0.5 + 0.5);
    }

    /*********************************************************************/
    /* determine polynomial expression                                   */
    /*********************************************************************/
    w = z * z;

    a = A0;
    b = w + B0;

    /*********************************************************************/
    /* calculate the natural log of (mant x) / 2		         */
    /*********************************************************************/
    r = z + z * w * (a / b);

    /*********************************************************************/
    /* log10(x) = (ln (mant x) + 2 * (exp x)) * log10(e) (but more       */
    /* mathematically stable)	                                         */
    /*********************************************************************/
    return (((n * C4 + r) + n * C3) * LOG10e);
#endif
}

lowlev.c/       925421684   0     0     0       14033     `
/*****************************************************************************/
/*  LOWLEV.C V5.11                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Low level I/O routines                                                    */
/*                                                                           */
/* Functions:                                                                */
/*   getnexfildes()    - Allocate next entry in stream table.                */
/*   tabinit()         - Initialize the stream and device tables.            */
/*   finddevice()      - Search the device table for a device name.          */
/*   getdevice()       - Extract the device name and <find> it.              */
/*   add_device()      - Add a device record to the device table.            */
/*   removedevice()    - Remove the specified device record from the device  */
/*                              table.                                       */
/*   open()            - Open file/device and assign file descriptor.        */
/*   read()            - Read data from an open file/device.                 */
/*   write()           - Write to an open file/device.                       */
/*   lseek()           - Perform lseek on open file/device.                  */
/*   close()           - Close an open file/device.                          */
/*   unlink()          - Perform unlink on file/device.                      */
/*   rename()          - Rename file                                         */
/*****************************************************************************/
#include <stdio.h>
#include <string.h>

extern int  HOSTopen(const char *path, unsigned flags, int fno),
            HOSTclose(int fno),
            HOSTread(int fno, char *buf, unsigned count),
            HOSTwrite(int fno, const char *buf, unsigned count),
            HOSTunlink(const char *path),
            HOSTrename(const char *old_name, const char *new_name);
extern fpos_t HOSTlseek(int fno, fpos_t offset, int origin);
extern void tabinit(void);
extern int getnexfildes(void);
extern _DEVICE *finddevice(const char *devname);
extern _DEVICE *getdevice (const char **path);
extern int remove_device(char *name);
extern int open(const char *path, unsigned flags, int mode);
extern int read(int fildes, char *bufptr, unsigned cnt);
extern int write(int fildes, const char *bufptr, unsigned cnt);
extern long lseek(int  fildes, long offset, int  origin);
extern int close(int fildes);
extern int unlink(const char *path);

_DEVICE  _device[_NDEVICE] = { { "", _MSA, HOSTopen,  HOSTclose, HOSTread,
                                   HOSTwrite, HOSTlseek, HOSTunlink,
                                   HOSTrename} };

_DEVICE *_stream[_NSTREAM] =  { &_device[0],  &_device[0],   &_device[0] };

/*****************************************************************************/
/*  GETNEXFILDES() - allocate a location in the stream table                 */
/*****************************************************************************/

int getnexfildes(void)
{
   _DEVICE **ptr;

   /*-------------------------------------------------------------------------*/
   /* SEARCH THE STREAM TABLE FOR EMPTY ENTRY - RETURN -1 IF FULL             */
   /*-------------------------------------------------------------------------*/
   for (ptr = &_stream[3] ; ptr != &_stream[_NSTREAM] && *ptr != NULL; ++ptr );

   return ( ptr == &_stream[_NSTREAM] ) ? -1 : ptr - &_stream[0];
}


/*****************************************************************************/
/*  TABINIT() - initialize the stream table and the device table             */
/*****************************************************************************/

void tabinit(void)
{
   _DEVICE **st;
   _DEVICE  *dt;

   static int init = 0;

   if (init) return;

   /*-------------------------------------------------------------------------*/
   /* STEP THROUGH THE TABLES SETTING NAME AND POINTER ENTRIES TO NULL        */
   /* (SKIP PREDEFINED DEVICE AND STREAMS)                                    */
   /*-------------------------------------------------------------------------*/

   for ( st = &_stream[3] ; st != &_stream[_NSTREAM] ; *st++ = NULL );
   for ( dt = &_device[1] ; dt != &_device[_NDEVICE] ; *(dt++)->name = '\0');
   init = 1;
}

/*****************************************************************************/
/*  FINDDEVICE() - find the device record that matches devname in the device */
/*                     table                                                 */
/*****************************************************************************/

_DEVICE *finddevice(const char *devname)
{
   _DEVICE    *dt;

   if (devname[0] == '\0') return NULL;

   /*-------------------------------------------------------------------------*/
   /* SEARCH THE STREAM TABLE FOR THE DEVICE NAME - RETURN NULL IF NOT FOUND  */
   /*-------------------------------------------------------------------------*/
   for (dt = &_device[1]; 
   dt != _device+_NDEVICE && strcmp(dt->name,devname);
   ++dt);

   return (dt == &_device[_NDEVICE]) ? NULL : dt;
}


/*****************************************************************************/
/*  GETDEVICE() - extract the device name and call finddevice                */
/*****************************************************************************/

_DEVICE *getdevice (const char **path)   /* RETURN PTR TO DEVICE RECORD */
                                         /*   ASSOCIATED WITH PATH      */
{
   char    devname[9];
   char   *devnamptr   = devname;
   _DEVICE *dev;

  /*------------------------------------------------------------------------*/
  /* COPY OUT OF THE FIRST 8 CHARS WHAT SHOULD BE A DEVICE NAME             */
  /*------------------------------------------------------------------------*/
  if ((devnamptr = strchr(*path,':')) != NULL)
  {
     *devnamptr = '\0';
     dev = finddevice(*path);
     *devnamptr = ':';
     if (dev) { *path = devnamptr + 1; return dev; }
  }
   return stdevice;
}


/*****************************************************************************/
/*  ADDEVICE() - add a device record to the device table                     */
/*****************************************************************************/
int add_device(char      *name,
               unsigned   flags,
               int      (*dopen)  (const char *path, unsigned flags, int foo),
               int      (*dclose) (int fno),
               int      (*dread)  (int fno, char *buf, unsigned count),
               int      (*dwrite) (int fno, const char *buf, unsigned count),
               fpos_t     (*dlseek) (int fno, fpos_t offset, int origin),
               int      (*dunlink)(const char *path),
               int      (*drename)(const char *old_name, const char *new_name))
{
   _DEVICE *dt;

   tabinit();

   /*-------------------------------------------------------------------------*/
   /* SEARCH THE DEVICE TABLE FOR AN EMPTY SLOT, RETURN -1 IF NONE FOUND      */
   /*-------------------------------------------------------------------------*/
   for (dt = &_device[1]; dt != _device+_NDEVICE && dt->name[0] != '\0'; ++dt);
   if (dt == &_device[_NDEVICE]) return -1;

   strncpy(dt->name,name,8);
   dt->name[8] = '\0';
   dt->flags   = flags;
   dt->OPEN    = dopen;
   dt->CLOSE   = dclose;
   dt->READ    = dread;
   dt->WRITE   = dwrite;
   dt->LSEEK   = dlseek;
   dt->UNLINK  = dunlink;
   dt->RENAME  = drename;

   return 0;
}

/******************************************************************************/
/*  REMOVEDEVICE() - remove the specified device record from the device table */
/******************************************************************************/

int remove_device(char *name)
{
   _DEVICE *ptr;

  /*------------------------------------------------------------------------*/
  /* FIND RECORD AND SET NAME TO NULL                                       */
  /*------------------------------------------------------------------------*/
   if ( !(ptr = finddevice(name)) ) return -1;

   ptr->name[0] = '\0';
   return 0;
}


/*****************************************************************************/
/*  OPEN() - open file/device specified by path and assign file descriptor   */
/*****************************************************************************/

int open(const char *path,
         unsigned flags, 
         int      mode)
{
   _DEVICE    *dev;
   int        result;
   int        nexfildes;

   /*-------------------------------------------------------------------------*/
   /* INITIALIZE STREAM AND DEVICE TABLE FIRST TIME AROUND                    */
   /*-------------------------------------------------------------------------*/
   tabinit();

   /*-------------------------------------------------------------------------*/
   /* GET THE NEXT AVAILABLE FILE DESCRIPTOR - RETURN -1 IF NONE AVAILABLE    */
   /*-------------------------------------------------------------------------*/
   if ( (nexfildes = getnexfildes()) == -1 )
      return -1;

   /*------------------------------------------------------------------------*/
   /* GET DEVICE AND PEFORM OPEN - SET STREAM TABLE ENTRY AND FLAGS          */
   /*------------------------------------------------------------------------*/
   dev    = getdevice(&path);
   result = (dev->flags & _BUSY) ? -1 : (*(dev->OPEN))(path,flags,nexfildes);

   if ( result != -1 )
   {
      _stream[nexfildes] = dev;
      if ( !(dev->flags & _MSA) ) dev->flags |= _BUSY;
      result         = nexfildes;
   }
   return result;
}

/*****************************************************************************/
/*  READ() - read data from an open device/file                              */
/*****************************************************************************/

int read(int           fildes,
         char         *bufptr,
         unsigned      cnt)
{
   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM READ FOR THIS DEVICE/FILE   */
   /*------------------------------------------------------------------------*/
   return (*(_stream[fildes]->READ)) (fildes,bufptr,cnt);
}

/*****************************************************************************/
/*  WRITE() - write data to an open device/file                              */
/*****************************************************************************/

int write(int           fildes,
          const char   *bufptr,
          unsigned      cnt)
{
   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM WRITE FOR THIS DEVICE/FILE  */
   /*------------------------------------------------------------------------*/
   return (*(_stream[fildes]->WRITE)) (fildes,bufptr,cnt);
}

/*****************************************************************************/
/*  LSEEK() - lseek on an open device/file                                   */
/*****************************************************************************/

long lseek(int  fildes,
	   long offset,
	   int  origin)
{
   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM LSEEK FOR THIS DEVICE/FILE  */
   /*------------------------------------------------------------------------*/
   return (*(_stream[fildes]->LSEEK)) (fildes,(fpos_t)offset,origin);
}

/*****************************************************************************/
/*  CLOSE() - close an open device/file                                      */
/*****************************************************************************/

int close(int fildes)
{
   int result;

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM CLOSE FOR THIS DEVICE/FILE  */
   /* CLEAR STREAM TABLE ENTRY AND DEVICE FLAGS                              */
   /*------------------------------------------------------------------------*/
   if ( (result = (*(_stream[fildes]->CLOSE))(fildes)) != -1 )
   {
      _stream[fildes]->flags &= ~_BUSY;
      _stream[fildes] = NULL;
   }
   return result;
}

/*****************************************************************************/
/*  UNLINK() - unlink an open device/file                                    */
/*****************************************************************************/

int unlink(const char *path)
{
   _DEVICE *dev = getdevice(&path);

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM UNLINK FOR THIS DEVICE/FILE */
   /*------------------------------------------------------------------------*/
   return (*(dev->UNLINK)) (path);
}

/*****************************************************************************/
/*  RENAME() - rename a device/file                                          */
/*****************************************************************************/

int rename(const char *old_name, const char *new_name)
{
   _DEVICE *dev = getdevice(&old_name);

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM RENAME FOR THIS DEVICE/FILE */
   /*------------------------------------------------------------------------*/
   return (*(dev->RENAME)) (old_name, new_name);
}

ltoa.c/         925421684   0     0     0       1018      `
/*****************************************************************************/
/* LTOA.C V5.11							     */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
/* THIS FUNCTION IS NON-STANDARD AND IS PROVIDED ONLY FOR COMPATIBILITY.     */
/* THE STANDARD EQUIVALENT IS SPRINTF.                                       */
/*****************************************************************************/
#include <string.h>

extern int ltoa(long val, char *buffer);

#define BUFLEN 20

int ltoa(long val, char *buffer)
{
    char  tempc[BUFLEN];
    char *bufptr;
    int   neg = val < 0;
    int   uval = neg ? -val : val;

    *(bufptr = &tempc[BUFLEN - 1]) = 0;

    do { *--bufptr = (uval % 10) + '0'; }  while(uval /= 10);
    if (neg) *--bufptr = '-';

    memcpy(buffer, bufptr, uval = (tempc + BUFLEN) - bufptr);
    return uval - 1;    /* DON'T COUNT NULL TERMINATION */
}

memccpy.c/      925421684   0     0     0       945       `
/*****************************************************************************/
/*  MEMCCPY.C  V5.11                                                        */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include "stdlib.h"

extern char *memccpy(char *dest, const char *src, int ch, int count);

/*--------------------------------------------------------------------------*/
/* PERFORM SAME OPERATION AS MEMCPY, ABORT IF "ch" is COPIED.               */
/* RETURN POINTER TO BYTE AFTER ch IS FOUND, OR NULL IF NOT FOUND           */
/*--------------------------------------------------------------------------*/
char *memccpy(char *dest, const char *src, int ch, int count)
{
   if (count <= 0) return NULL;
   do
      if ((*dest++ = *src++) == ch) return (dest);
   while (--count != 0);

   return NULL;
}

memchr.c/       925421684   0     0     0       708       `
/*****************************************************************************/
/* memchr.c V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <string.h>

void *memchr(const void *cs, int c, size_t n)
{
   size_t length;

   if ( (length=n) > 0 )
   {
      const unsigned char *mem = cs;   
      unsigned char       ch   = c;

      do if ( *mem++ == ch ) return (void *)(mem - 1);
      while (--length != 0);
   }
   
   return NULL;
}


memcmp.c/       925421684   0     0     0       630       `
/*****************************************************************************/
/*  memcmp.c V5.11 for TMS3203x/4x                                	     */
/*  Copyright (c) 1992-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <string.h>

int memcmp(const void *mem1, const void *mem2, size_t length)
{
     const char *r1 = (char *)mem1 - 1;
     const char *r2 = (char *)mem2 - 1;

     while (length--) if (*++r1 != *++r2) return *r1 - *r2;
     return 0;
}
memcpy.c/       925421684   0     0     0       1678      `
/*****************************************************************************/
/* memcpy.c V5.11 for TMS3203x/4x					     */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <limits.h>
#include <string.h>

void *memcpy(void *s, const void *ct, size_t n)
{
    const char *from = (char*)ct;
    char *to = (char *)s;
    
    if (n == 0) return s;

    /*------------------------------------------------------------------------*/
    /* We cannot use an unsigned counter for a repeat loop in assembly, so    */
    /* see if the count is too large to be copied to a signed index.  If so,  */
    /* do the loop the slow way, "else" use a faster signed index loop.       */
    /*------------------------------------------------------------------------*/
    /* To make the fast loop as fast as possible, we want to use the assert   */
    /* to remove the loop kernel test from the assembly code.  Therefore, if  */
    /* only one byte to copy, also enter the slow loop.  The test of          */
    /* (size < 2), where size=(int)n tests for the case of n=1 and n>INT_MAX. */
    /*------------------------------------------------------------------------*/
    if ((n > INT_MAX) || (n == 1))
    {
        do
            *to++ = *from++;
        while (--n != 0);
    }
    else
    {
	int size = (int)n;
        _nassert(size > 1);    /* Don't need kernel iteration test! */
 
        for(size; size > 0; size--) *to++ = *from++;
    }
    
    return s;
}
memmov.c/       925421686   0     0     0       645       `
/*****************************************************************************/
/* memmove.c V5.11 for TMS3203x/4x					     */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <string.h>

void *memmove(void *s, const void *ct, size_t n)
{
    char *from, *to;

    if (n > 0)
    {
       if ((from = (char *)ct) > (to = (char *)s)) 
	  do *to++ = *from++; while (--n != 0);
       else
       {
	  from  += n;
	  to    += n;
	  do *--to = *--from; while (--n != 0);
       }
    }

    return s;
}


memory.c/       925421686   0     0     0       20461     `
/*****************************************************************************/
/* memory.c V5.11 for TMS32032						     */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*---------------------------------------------------------------------------*/
/*  This module contains the functions which implement the dynamic memory    */
/*  management routines for 320C30 C.  The following assumptions/rules       */
/*  apply:                                                                   */
/*									     */
/*   1) Packets are allocated a minimum of one word, max 2^31 words. 	     */
/*   2) The allocation system can be reset at any time by calling the        */
/*      function "minit()".                                                  */
/*                                                                           */
/*   The system memory area is declared as a .usect called ".sysmem".  The   */
/*   size of the heap is set a link time using the -heap option.  This       */
/*   defaults to 1K words if -heap is not used.                              */
/*                                                                           */
/*  The following items are defined in this module :			     */
/*    minit()	   : Function to initialize dynamic memory management.       */
/*    malloc()	   : Function to allocate memory from mem mgmt system.	     */
/*    calloc()	   : Allocate an clear memory from mem mgmt system.	     */
/*    realloc()    : Reallocate a packet.				     */
/*    free()	   : Function to free allocated memory.			     */
/*									     */
/*    minsert()    : Insert a packet into free list, sorted by size	     */
/*    mremove()    : Remove a packet from the free list.		     */
/*									     */
/*    bmalloc()	   : Function to allocate memory from mem mgmt system on a   */
/*		     boundary suitable for circular addressing.		     */
/*									     */
/*    sys_free	   : Pointer to free list 				     */
/*									     */
/*****************************************************************************/
#include <stdlib.h>
#include <string.h>

/*---------------------------------------------------------------------------*/
/* Declare the memory pool as a usect called .sysmem.                        */
/*---------------------------------------------------------------------------*/
/* asm("__sys_memory   .usect   .sysmem,0"); */
#pragma DATA_SECTION(_sys_memory, ".sysmem")
int _sys_memory[1]; 

/*---------------------------------------------------------------------------*/
/*  _SYSMEM_SIZE is declared as an absolute external label.  By taking its   */
/*  "address" here in the C file, we get the actual value assigned to the    */
/*   symbol, which is the size of the system memory area.                    */
/*---------------------------------------------------------------------------*/
extern int _SYSMEM_SIZE;

#define MEMORY_SIZE ((int)&_SYSMEM_SIZE)         /* ASSIGNED BY LINKER */

/*---------------------------------------------------------------------------*/
/* "PACKET" is the template for a data packet.  Packet size contains         */
/* the number of words allocated for the user, excluding the size            */
/* required for management of the packet (1 word).  Packets are always       */
/* allocated memory in words.  A negative size indicates a free packet.      */
/*---------------------------------------------------------------------------*/
typedef struct pack 
{
   int           packet_size;	      /* in words */
   struct pack  *size_ptr;
} PACKET;

static int init = 0;

static PACKET *sys_free = (PACKET *)_sys_memory;

static void minsert(PACKET *);
static void mremove(PACKET *);

/*****************************************************************************/
/*									     */
/*  MINSERT - Insert a packet into the free list.  This list is sorted by    */
/*	      size in increasing order. 				     */
/*									     */
/*****************************************************************************/
static void minsert(PACKET *ptr)
{
    PACKET *current = (PACKET *) sys_free;
    PACKET *last    = NULL;

    /*------------------------------------------------------------------*/
    /* CHECK SPECIAL CASE, EMPTY FREE LIST.				*/
    /*------------------------------------------------------------------*/
    if (current == NULL)
    {
       sys_free = ptr;
       ptr->size_ptr = NULL;
       return;
    }

    /*------------------------------------------------------------------*/
    /* SCAN THROUGH LIST, LOOKING FOR A LARGER PACKET.			*/
    /*------------------------------------------------------------------*/
    while ((current != NULL) && (current->packet_size > ptr->packet_size))
    {
	last	= current;
	current = current->size_ptr;
    }

    /*------------------------------------------------------------------*/
    /* LINK THE NEW PACKET INTO THE LIST. THERE ARE THREE CASES :	*/
    /*	 THE NEW POINTER WILL EITHER BE THE FIRST, THE LAST, OR IN THE	*/
    /*	 MIDDLE SOMEWHERE.						*/
    /*------------------------------------------------------------------*/
    if (current == NULL) 	 /* PTR WILL BE LAST IN LIST */
    {
       last->size_ptr = ptr;
       ptr->size_ptr  = NULL;
    }

    else if (last == NULL)	 /* PTR WILL BE FIRST IN THE LIST */
    {
       ptr->size_ptr  = sys_free;
       sys_free       = ptr;
    }

    else			 /* PTR IS IN THE MIDDLE OF THE LIST */
    {
       ptr->size_ptr  = current;
       last->size_ptr = ptr;
    }
}


/*****************************************************************************/
/*									     */
/* MREMOVE - REMOVE AN ITEM FROM THE FREE LIST. 			     */
/*									     */
/*****************************************************************************/
static void mremove(PACKET *ptr)
{
    PACKET *current = sys_free;
    PACKET *last    = NULL;

    /*------------------------------------------------------------------*/
    /* SCAN THROUGH LIST, LOOKING FOR PACKET TO REMOVE			*/
    /*------------------------------------------------------------------*/
    while ((current != NULL) && (current != ptr))
    {
	last	= current;
	current = current->size_ptr;
    }

    /*------------------------------------------------------------------*/
    /* REMOVE THE PACKET FROM THE LIST.   THERE ARE TWO CASES : 	*/
    /*	 THE OLD POINTER WILL EITHER BE THE FIRST, OR NOT THE FIRST.	*/
    /*------------------------------------------------------------------*/
    if (current == NULL) 	 /* POINTER NOT FOUND IN LIST		*/
       sys_free = NULL;		 /* FATAL ERROR 			*/

    else if (last == NULL)	 /* PTR WAS BE FIRST IN THE LIST	*/
       sys_free = ptr->size_ptr;

    else			 /* PTR IS IN THE MIDDLE OF THE LIST	*/
       last->size_ptr = ptr->size_ptr;
}


/*****************************************************************************/
/*									     */
/*  MINIT - This function can be called by the user to completely reset the  */
/*	    memory management system.					     */
/*									     */
/*****************************************************************************/
void minit(void)
{
    /*----------------------------------------------------------------------*/
    /* TO INITIALIZE THE MEMORY SYSTEM, DEALLOCATE ONE PACKET WHICH USES    */
    /* AVAILABLE MEMORY, INITIALIZE THE FREE LIST TO POINT TO IT.	    */
    /*----------------------------------------------------------------------*/
    sys_free = (PACKET *)_sys_memory;

    sys_free->packet_size = -(MEMORY_SIZE - 1);
    sys_free->size_ptr	  = NULL;
}


/*****************************************************************************/
/*									     */
/*  MALLOC - Allocate a packet of a given size, and return pointer to it.    */
/*	     This function only allocates in multiple of ints.      	     */
/*									     */
/*****************************************************************************/
void *malloc(size_t size)
{
    PACKET *current = sys_free;
    int     newsize = size;
    int     oldsize;

    if (!init) { minit(); init = 1; }

    if (newsize == 0) newsize = 1;

    /*---------------------------------------------------------------------*/
    /* SCAN THROUGH FREE LIST FOR PACKET LARGE ENOUGH TO CONTAIN PACKET    */
    /* REMEMBER THAT FREE PACKAGE SIZES ARE NEGATIVE, SO NEGATE SIZE.      */
    /*---------------------------------------------------------------------*/
    newsize = -newsize;
    while ((current != NULL) && (current->packet_size > newsize))
       current = current->size_ptr;

    if (current == NULL) return NULL;

    oldsize = current->packet_size;	 /* REMEMBER OLD SIZE		 */
    mremove(current);		         /* REMOVE PACKET FROM FREE LIST */

    /*---------------------------------------------------------------------*/
    /* IF PACKET IS LARGER THAN NEEDED, FREE EXTRA SPACE AT END	           */
    /* BY INSERTING REMAINING SPACE INTO FREE LIST.                        */
    /*---------------------------------------------------------------------*/
    if (newsize - oldsize >= 2)
    {
       PACKET *next = (PACKET *) ((char *) current + 1 - newsize);
       next->packet_size = oldsize - newsize + 1;
       minsert(next);
       current->packet_size = -newsize;
    }
    else current->packet_size = -oldsize;

    return &current->size_ptr;
}


/*****************************************************************************/
/*									     */
/*  CALLOC - Allocate a packet of a given size, set the data in the packet   */
/*	     to nulls, and return a pointer to it.			     */
/*									     */
/*****************************************************************************/
void *calloc(size_t num, size_t size)
{
    size_t i       = num * size;
    void  *result  = malloc(i);

    if (result)
    {
       char *cp   = result;
       if (i) do *cp++ = 0; while (--i);
    }
    return result;
}


/*****************************************************************************/
/*									     */
/*  REALLOC - Reallocate a packet to a new size.			     */
/*									     */
/*****************************************************************************/
void *realloc(void *packet, size_t newsize)
{
    char *pptr = (char *)packet - 1;      /* PTR TO START OF PACKET */
    int   oldsize;

    /*--------------------------------------------------------------*/
    /* HANDLE SPECIAL CASES                                         */
    /*--------------------------------------------------------------*/
    if (packet == NULL)     return malloc(newsize);
    if (newsize == 0)     { free(packet);  return NULL; }
    oldsize = ((PACKET *)pptr)->packet_size;
    if (oldsize <= 0)       return NULL;
    if (newsize == oldsize) return packet;

    /*--------------------------------------------------------------*/
    /* IF NEW SIZE IS LESS THAN CURRENT PACKET SIZE,		    */
    /* TRUNCATE THE PACKET AND RETURN END TO FREE LIST		    */
    /*--------------------------------------------------------------*/
    if (newsize < oldsize)
    {
       if (oldsize - newsize < 2) return packet;
       ((PACKET *)pptr)->packet_size = newsize;   /* SET NEW PACKET SIZE   */
       pptr += newsize + 1;                       /* SET PTR TO NEW PACKET */
       ((PACKET *)pptr)->packet_size = oldsize - newsize - 1; 
       free(pptr + 1);      			  /* FREE TRAILING PACKET  */
       return packet;
    }

    /*--------------------------------------------------------------*/
    /* IF NEW SIZE IS BIGGER THAN CURRENT PACKET,		    */
    /*	1) CHECK NEXT PACKET IN LIST, SEE IF PACKET CAN BE EXPANDED */
    /*	2) IF NOT, MOVE PACKET TO NEW LOCATION. 		    */
    /*--------------------------------------------------------------*/
    else
    {
      PACKET *next = (PACKET *)(pptr + oldsize + 1);
      int temp;

      if (((int *)next < &_sys_memory[MEMORY_SIZE - 2]) &&
	 ((next->packet_size < 0)                       &&
	 ((temp = oldsize - next->packet_size - newsize + 1) >= 0)))
      {
	  mremove(next);
	  if (temp < 2)
	  {
	     ((PACKET *)pptr)->packet_size = newsize + temp;
	     return packet;
	  }

	  /*-------------------------------------------------------*/
          /* FREE TRAILING PACKET                                  */
	  /*-------------------------------------------------------*/
	  ((PACKET *)pptr)->packet_size = newsize;
	  pptr += newsize + 1;
	  ((PACKET *)pptr)->packet_size = -(temp - 1);
	  minsert((PACKET *)pptr);
	  return packet;
      }
      else
      {
	  /*-------------------------------------------------------*/
	  /* ALLOCATE NEW PACKET AND MOVE DATA INTO IT. 	   */
	  /*-------------------------------------------------------*/
	  char *new = malloc(newsize);
	  if (new == NULL) return NULL;
	  memcpy(new, pptr+1, oldsize);
	  free(packet);
	  return new;
      }
    }
}


/*****************************************************************************/
/*									     */
/*  FREE - Return a packet allocated by malloc to free memory pool.	     */
/*									     */
/*****************************************************************************/
void free(void *packet)
{
    char   *ptr     = (char *)packet - 1;
    PACKET *current = (PACKET *)_sys_memory;
    PACKET *next    = NULL;
    PACKET *last    = NULL;

    /*-------------------------------------------------------------------*/
    /* SEARCH FOR THE POINTER IN THE PACKET POINTED TO			 */
    /*-------------------------------------------------------------------*/
    if (packet == NULL) return;

    while (current < (PACKET *)ptr)
    {
      int tempsize = current->packet_size;
      last = current;
      if (tempsize < 0) tempsize = -tempsize; 
      current = (PACKET *)((char *)current + tempsize + 1);
    }

    /*-------------------------------------------------------------------*/
    /* CHECK FOR POINTER OR PACKET ERRORS.				 */
    /*-------------------------------------------------------------------*/
    if ((current != (PACKET *) ptr) || (current->packet_size < 0))
       return;

    current->packet_size = -current->packet_size; /* MARK PACKET AS FREE */

    /*-------------------------------------------------------------------*/
    /* GET POINTER TO NEXT PACKET IN MEMORY, IF ANY.			 */
    /*-------------------------------------------------------------------*/
    next = (PACKET *) ((char *)current - current->packet_size + 1);
    if (next > (PACKET *) &_sys_memory[MEMORY_SIZE - 1]) next = NULL;

    /*-------------------------------------------------------------------*/
    /* ATTEMPT TO COALESCE THE THREE PACKETS (PREVIOUS, CURRENT, NEXT)	 */
    /*-------------------------------------------------------------------*/
    if ((last != NULL) && (last->packet_size < 0))
    {
       if ((next != NULL) && (next->packet_size < 0))
       {
	  mremove(last);
	  mremove(next);
	  last->packet_size += next->packet_size + current->packet_size - 2;
	  minsert(last);
	  return;
       }
       else
       {
	  mremove(last);
	  last->packet_size += current->packet_size - 1;
	  minsert(last);
	  return;
       }
    }

    /*-------------------------------------------------------------------*/
    /* ATTEMPT TO COALESCE THE CURRENT WITH NEXT PACKET. (CURRENT, NEXT) */
    /*-------------------------------------------------------------------*/
    else if ((next != NULL) && (next->packet_size < 0))
    {
       mremove(next);
       current->packet_size += next->packet_size - 1;
       minsert(current);
       return;
    }

    /*-------------------------------------------------------------------*/
    /* NO COALESCENCE POSSIBLE, JUST INSERT THIS PACKET INTO LIST	 */
    /*-------------------------------------------------------------------*/
    else minsert(current);
    return;
}


/*****************************************************************************/
/*									     */
/*  BMALLOC - Allocate a packet of a given size, and return pointer to it.   */
/*	      This function only allocates in multiple of ints. 	     */
/*	      The packet of a given size is aligned on the proper boundary   */
/*	      suitable for TMS320C3x and TMS320C4x circular buffers and      */
/*	      bit-reversed addressed buffers. Refer to TMS320C3x U.G.	     */
/*	      (SPRU031B) for information on circular buffers and bit-reverse */
/*	      addressing.						     */
/*									     */
/*****************************************************************************/
void *bmalloc(size_t size)
{
    PACKET *current;
    PACKET *cb_ptr = current = sys_free;   /* ptr to word aligned buffer */
    int     newsize = size;
    int     oldsize;
    int     k;
    int     avail;

    if (!init) { minit();      init = 1; }

    if (newsize == 0) newsize = 1;

    /*--------------------------------------------------------------------*/
    /* k is the next power of 2 that is greater than the packet size	  */
    /*--------------------------------------------------------------------*/
    for(k=1; k <= newsize; k <<= 1);

    newsize = -newsize;

    /*---------------------------------------------------------------------*/
    /* Scan through free list for packet large enough to contain the word  */
    /* aligned packet. Remember that free package sizes are negative, so   */
    /* negate size. In order for a packet to be big enough first find a    */
    /* regular packet, calculate the next word aligned pointer and see if  */
    /* there is enough memory remaining in the packet for the desired	   */
    /* buffer size and that the word aligned address is not 1 away from    */
    /* the current packet since this will leave a packet (starting at	   */
    /* current) that is 0 words in size (NOT GOOD). Recall that the word   */
    /* aligned packet starts one word before the word aligned address.	   */
    /*---------------------------------------------------------------------*/
    /* cp_ptr = next address (maybe current) that is a multiple of k_size  */
    /*---------------------------------------------------------------------*/
    /* avail = available space from cb_ptr to end of current packet	   */
    /*---------------------------------------------------------------------*/
    /* Search forever until end of heap is reached (i.e. current = NULL)   */
    /* or a valid word aligned packet is reached (i.e. enough space	   */
    /* is available and it is not 1 away from current.			   */
    /*---------------------------------------------------------------------*/
    for(;;)
    {
	cb_ptr = (PACKET *) ((k*(((int) cb_ptr + 1 + (k-1))/k)) -1);

	if(((int) cb_ptr - (int) current) == 1)
	    cb_ptr = (PACKET *) ((int) cb_ptr + k);

	avail =  current->packet_size - (int) current + (int) cb_ptr;
	if ((current == NULL) || (avail <= newsize)) break;
	cb_ptr = current = current->size_ptr;
    }

    if (current == NULL) return NULL;

    mremove(current);			   /* remove packet from free list */

    /*---------------------------------------------------------------------*/
    /* If space exists between current and cb_ptr, then return this packet */
    /* to the free list 						   */
    /*---------------------------------------------------------------------*/
    if(cb_ptr != current)
    {
       current->packet_size = (int) current - (int) cb_ptr + 1;
       minsert(current);
       current = cb_ptr;
    }

    /*---------------------------------------------------------------------*/
    /* If space exists between the end of the required packet and the end  */
    /* of the current packet, return this packet to the free list	   */
    /*---------------------------------------------------------------------*/
    oldsize = avail;			       /* remember old size	   */

    if (newsize - oldsize >= 2)
    {
       PACKET *next = (PACKET *) ((char *) current + 1 - newsize);
       next->packet_size = oldsize - newsize + 1;
       minsert(next);
       current->packet_size = -newsize;
    }
    else current->packet_size = -oldsize;

    return &current->size_ptr;
}

memory16.c/     925421686   0     0     0       22237     `
/*****************************************************************************/
/* memory16.c V5.11 for TMS32032				             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*---------------------------------------------------------------------------*/
/*  This module contains the functions which implement the dynamic memory    */
/*  management routines for 320C32 C.  The following assumptions/rules       */
/*  apply:                                                                   */
/*									     */
/*   1) Packets are allocated a minimum of one 16-bit word, max 2^31 words.  */
/*   2) The allocation system can be reset at any time by calling the        */
/*      function "minit16()".                                                */
/*                                                                           */
/*   The 16-bit system memory area is declared as a .usect called ".sysm16". */
/*   The size of the heap is set a link time using the -heap16 option.  No   */
/*   16-bit system memory area is allocated if -heap16 is not used, unless   */
/*   these routines are linked, in which case the size defaults to 0x400.    */
/*                                                                           */
/*  The following items are defined in this module :			     */
/*    minit16()	   : Function to initialize dynamic memory management.       */
/*    malloc16()   : Function to allocate memory from mem mgmt system.	     */
/*    calloc16()   : Allocate an clear memory from mem mgmt system.	     */
/*    realloc16()  : Reallocate a packet.				     */
/*    free16()	   : Function to free allocated memory.			     */
/*									     */
/*    minsert16()  : Insert a packet into free list, sorted by size	     */
/*    mremove16()  : Remove a packet from the free list.		     */
/*									     */
/*    bmalloc16()  : Function to allocate memory from mem mgmt system on a   */
/*		     boundary suitable for circular addressing.		     */
/*									     */
/*    sys_free16   : Pointer to free list 				     */
/*									     */
/*****************************************************************************/
#include <stdlib.h>
#include <string.h>

/*---------------------------------------------------------------------------*/
/* Declare the memory pool as a usect called .sysmem.                        */
/*---------------------------------------------------------------------------*/
#pragma DATA_SECTION(_sys_memory16, ".sysm16")
int _sys_memory16[1]; 

/*---------------------------------------------------------------------------*/
/*  _SYSMEM16_SIZE is declared as an absolute external label.  By taking its */
/*  "address" here in the C file, we get the actual value assigned to the    */
/*   symbol, which is the size of the system memory area.                    */
/*---------------------------------------------------------------------------*/
extern int _SYSMEM16_SIZE;

#define MEMORY16_SIZE ((int)&_SYSMEM16_SIZE)         /* ASSIGNED BY LINKER */

/*---------------------------------------------------------------------------*/
/* "PACKET" is the template for a data packet.  Packet size contains         */
/* the number of words allocated for the user, excluding the size            */
/* required for management of the packet (2 words).  Packets are always      */
/* allocated memory in words.  A negative size indicates a free packet.      */
/*---------------------------------------------------------------------------*/
typedef struct pack16 
{
  int           packet_size[2];  /* high/low order 16-bits of packet size  */
  unsigned int  size_ptr[2];     /* high/low 0rder 16-bits of size pointer */
} PACKET16;

/*---------------------------------------------------------------------------*/
/* MACROS TO ACCESS PACKET16 VALUES AS 32-BIT VALUES                         */
/*---------------------------------------------------------------------------*/
typedef unsigned int uint;

#define GETPACK16(p,s) do { (s) = ((p)->packet_size[0] << 16) |              \
                                   (p)->packet_size[1];                      \
                          } while(0)

#define PUTPACK16(p,s) do { (p)->packet_size[0] =  (s) >> 16;                \
			    (p)->packet_size[1] = ((s) << 16) >> 16; } while(0)

#define GETSIZE16(p,s) do { (s) = (PACKET16 *)(((p)->size_ptr[0]<<16) |      \
					     (p)->size_ptr[1]); } while(0)

#define PUTSIZE16(p,s) do { (p)->size_ptr[0] = (uint) (s) >> 16;             \
			    (p)->size_ptr[1] = ((uint)(s) << 16) >> 16;      \
                          } while(0)

static int init = 0;

static PACKET16 *sys_free16 = (PACKET16 *)_sys_memory16;

static void minsert16(PACKET16 *);
static void mremove16(PACKET16 *);


/*****************************************************************************/
/*									     */
/*  MINSERT16 - Insert a packet into the free list.  This list is sorted by  */
/*	      size in increasing order. 				     */
/*									     */
/*****************************************************************************/
static void minsert16(PACKET16 *ptr)
{
  int      t1,t2;
  PACKET16 *current = (PACKET16 *) sys_free16;
  PACKET16 *last    = NULL;

  /*------------------------------------------------------------------*/
  /* CHECK SPECIAL CASE, EMPTY FREE LIST.	                      */
  /*------------------------------------------------------------------*/
  if (current == NULL)
  {
    sys_free16 = ptr;
    PUTSIZE16(ptr, NULL);
    return;
  }

  /*------------------------------------------------------------------*/
  /* SCAN THROUGH LIST, LOOKING FOR A LARGER PACKET.		      */
  /*------------------------------------------------------------------*/
  GETPACK16(current,t1);
  GETPACK16(ptr,t2);
  while ((current != NULL) && (t1 > t2))
  {
    last = current;
    GETSIZE16(current, current);
    GETPACK16(current, t1);
  }

  /*------------------------------------------------------------------*/
  /* LINK THE NEW PACKET INTO THE LIST. THERE ARE THREE CASES :       */
  /* THE NEW POINTER WILL EITHER BE THE FIRST, THE LAST, OR IN THE    */
  /* MIDDLE SOMEWHERE.					              */
  /*------------------------------------------------------------------*/
  if (current == NULL)         /* PTR WILL BE LAST IN LIST */
  {
    PUTSIZE16(last, ptr);
    PUTSIZE16(ptr, NULL);
  }

  else if (last == NULL)       /* PTR WILL BE FIRST IN THE LIST */
  {
    PUTSIZE16(ptr, sys_free16);
    sys_free16 = ptr;
  }

  else                         /* PTR IS IN THE MIDDLE OF THE LIST */
  {
    PUTSIZE16(ptr, current);
    PUTSIZE16(last, ptr);
  }
}


/*****************************************************************************/
/*									     */
/* MREMOVE16 - REMOVE AN ITEM FROM THE FREE LIST. 			     */
/*									     */
/*****************************************************************************/
static void mremove16(PACKET16 *ptr)
{
  PACKET16 *current = sys_free16;
  PACKET16 *last    = NULL;
  PACKET16 *next    = NULL;

  /*------------------------------------------------------------------*/
  /* SCAN THROUGH LIST, LOOKING FOR PACKET TO REMOVE                  */
  /*------------------------------------------------------------------*/
  while ((current != NULL) && (current != ptr))
  {
    last    = current;
    GETSIZE16(current, current);
  }

  /*------------------------------------------------------------------*/
  /* REMOVE THE PACKET FROM THE LIST.   THERE ARE TWO CASES :         */
  /* THE OLD POINTER WILL EITHER BE THE FIRST, OR NOT THE FIRST.      */
  /*------------------------------------------------------------------*/
  if (current == NULL) 	 /* POINTER NOT FOUND IN LIST		*/
    sys_free16 = NULL;	 /* FATAL ERROR 			*/
  
  else if (last == NULL)
    GETSIZE16(ptr, sys_free16); /* PTR MUST BE FIRST IN THE LIST */

  else			 /* PTR IS IN THE MIDDLE OF THE LIST	*/
  {
    GETSIZE16(ptr, next);
    PUTSIZE16(last, next);
  }
}


/*****************************************************************************/
/*									     */
/*  MINIT16 - This function can be called by the user to completely reset    */
/*	      the memory management system.			       	     */
/*									     */
/*****************************************************************************/
void minit16(void)
{
  /*----------------------------------------------------------------------*/
  /* TO INITIALIZE THE MEMORY SYSTEM, DEALLOCATE ONE PACKET WHICH USES    */
  /* AVAILABLE MEMORY, INITIALIZE THE FREE LIST TO POINT TO IT.	          */
  /*----------------------------------------------------------------------*/
  sys_free16 = (PACKET16 *)_sys_memory16;

  PUTPACK16(sys_free16, -(MEMORY16_SIZE - 2));
  PUTSIZE16(sys_free16, NULL);
}


/*****************************************************************************/
/*									     */
/*  MALLOC16 - Allocate a packet of a given size, and return pointer to it.  */
/*	     This function only allocates in multiples of 16-bit words.	     */
/*									     */
/*****************************************************************************/
void *malloc16(size_t size)
{
  PACKET16 *current = sys_free16;
  PACKET16 *next;
  int       newsize = size;
  int       tmpsize, oldsize;

  if (!init) { minit16(); init = 1; }

  if (newsize == 0) newsize = 2;

  /*---------------------------------------------------------------------*/
  /* SINCE SMALLEST PACKET IS 4 16-BIT WORDS, SMALLEST SIZE IS 2.        */
  /*---------------------------------------------------------------------*/
  if (newsize < 2) newsize = 2;

  /*---------------------------------------------------------------------*/
  /* SCAN THROUGH FREE LIST FOR PACKET LARGE ENOUGH TO CONTAIN PACKET    */
  /* REMEMBER THAT FREE PACKAGE SIZES ARE NEGATIVE, SO NEGATE SIZE.      */
  /*---------------------------------------------------------------------*/
  newsize = -newsize;
  GETPACK16(current, tmpsize);
  while ((current != NULL) && (tmpsize > newsize))
  {
    GETSIZE16(current, current);
    GETPACK16(current, tmpsize);
  }
  
  if (current == NULL) return NULL;

  GETPACK16(current, oldsize);           /* REMEMBER OLD SIZE            */
  mremove16(current);		         /* REMOVE PACKET FROM FREE LIST */

  /*---------------------------------------------------------------------*/
  /* IF PACKET IS LARGER THAN NEEDED, FREE EXTRA SPACE AT END	         */
  /* BY INSERTING REMAINING SPACE INTO FREE LIST.                        */
  /*---------------------------------------------------------------------*/
  if (newsize - oldsize >= 4)
  {
    next = (PACKET16 *) ((char *) current + 2 - newsize);
    PUTPACK16(next, (oldsize - newsize + 2));
    PUTSIZE16(next, NULL);
    minsert16(next);
    PUTPACK16(current, -newsize);
  }
  else PUTPACK16(current, -oldsize);

  return &current->size_ptr;
}


/*****************************************************************************/
/*									     */
/*  CALLOC16 - Allocate a packet of a given size, set the data in the packet */
/*	       to nulls, and return a pointer to it.			     */
/*									     */
/*****************************************************************************/
void *calloc16(size_t num, size_t size)
{
  size_t i       = size * num;
  void  *result  = malloc16(i);

  if (result)
  {
    char *cp   = result;
    if (i) do *cp++ = 0; while (--i);
  }
  return result;
}


/*****************************************************************************/
/*									     */
/*  REALLOC16 - Reallocate a packet to a new size.			     */
/*									     */
/*****************************************************************************/
void *realloc16(void *packet, size_t newsize)
{
  PACKET16 *pptr = (PACKET16 *)((int)packet - 2);  /* PTR TO START OF PACKET */
  int   oldsize;

  /*--------------------------------------------------------------*/
  /* HANDLE SPECIAL CASES                                         */
  /*--------------------------------------------------------------*/
  if (packet == NULL)     return malloc16(newsize);
  if (newsize == 0)     { free16(packet);  return NULL; }
  GETPACK16(pptr, oldsize);
  if (oldsize <= 0)       return NULL;
  if (newsize == oldsize) return packet;

  /*--------------------------------------------------------------*/
  /* IF NEW SIZE IS LESS THAN CURRENT PACKET SIZE,                */
  /* TRUNCATE THE PACKET AND RETURN END TO FREE LIST	          */
  /*--------------------------------------------------------------*/
  if (newsize < oldsize)
  {
    if (oldsize - newsize < 4) return packet;
    PUTPACK16(pptr, newsize);                  /* SET NEW PACKET SIZE   */
    pptr += newsize + 2;                       /* SET PTR TO NEW PACKET */
    PUTPACK16(pptr, (oldsize - newsize -2));
    free16(pptr + 2);      		       /* FREE TRAILING PACKET  */
    return packet;
  }

  /*--------------------------------------------------------------*/
  /* IF NEW SIZE IS BIGGER THAN CURRENT PACKET,		          */
  /* 1) CHECK NEXT PACKET IN LIST, SEE IF PACKET CAN BE EXPANDED  */
  /* 2) IF NOT, MOVE PACKET TO NEW LOCATION. 		          */
  /*--------------------------------------------------------------*/
  else
  {
    PACKET16 *next = (PACKET16 *)(pptr + oldsize + 2);
    int temp,t1;

    GETPACK16(next, t1);
    if (((int *)next < &_sys_memory16[MEMORY16_SIZE - 4]) &&
	((t1 < 0) && ((temp = oldsize - newsize - t1 + 2) >= 0)))
    {
      mremove16(next);
      if (temp < 4)
      {
	PUTPACK16(pptr, newsize + temp);
	return packet;
      }

      /*-------------------------------------------------------*/
      /* FREE TRAILING PACKET                                  */
      /*-------------------------------------------------------*/
      PUTPACK16(pptr, newsize);
      pptr += newsize + 2;
      PUTPACK16(pptr,-(temp - 2));
      minsert16(pptr);
      return packet;
    }
    else
    {
      /*-------------------------------------------------------*/
      /* ALLOCATE NEW PACKET AND MOVE DATA INTO IT. 	       */
      /*-------------------------------------------------------*/
      char *new = malloc16(newsize);
      if (new == NULL) return NULL;
      memcpy(new, pptr+2, oldsize);
      free16(packet);
      return new;
    }
  }
}


/*****************************************************************************/
/*									     */
/*  FREE16 - Return a packet allocated by malloc to free memory pool.	     */
/*									     */
/*****************************************************************************/
void free16(void *packet)
{
  int       size, t1;
  char     *ptr     = (char *)((int)packet - 2);
  PACKET16 *current = (PACKET16 *)_sys_memory16;
  PACKET16 *next    = NULL;
  PACKET16 *last    = NULL;

  /*-------------------------------------------------------------------*/
  /* SEARCH FOR THE POINTER IN THE PACKET POINTED TO                   */
  /*-------------------------------------------------------------------*/
  if (packet == NULL) return;

  while (current < (PACKET16 *)ptr)
  {
    int tempsize;
    GETPACK16(current, tempsize);
    last = current;
    if (tempsize < 0) tempsize = -tempsize; 
    current = (PACKET16 *)((char *)current + tempsize + 2);
  }

  /*-------------------------------------------------------------------*/
  /* CHECK FOR POINTER OR PACKET ERRORS.			       */
  /*-------------------------------------------------------------------*/
  GETPACK16(current, size);
  if ((current != (PACKET16 *) ptr) || (size < 0))
    return;

  PUTPACK16(current, -size);                    /* MARK PACKET AS FREE */
  GETPACK16(current, size);                     /* RESET SIZE VALUE    */
  /*-------------------------------------------------------------------*/
  /* GET POINTER TO NEXT PACKET IN MEMORY, IF ANY.		       */
  /*-------------------------------------------------------------------*/
  next = (PACKET16 *) ((char *)current - size + 2);
  if (next > (PACKET16 *) &_sys_memory16[MEMORY16_SIZE - 4]) next = NULL;

  /*-------------------------------------------------------------------*/
  /* ATTEMPT TO COALESCE THE THREE PACKETS (PREVIOUS, CURRENT, NEXT)   */
  /*-------------------------------------------------------------------*/
  size = 0;
  if (last != NULL) GETPACK16(last, size);
  if (size < 0)
  {
    t1 = 0;
    if (next != NULL) GETPACK16(next, t1);
    if (t1 < 0)
    {
      mremove16(last);
      mremove16(next);
      size += t1;
      GETPACK16(current, t1);
      size += t1 - 4;
      PUTPACK16(last, size);
      minsert16(last);
      return;
    }
    else
    {
      mremove16(last);
      GETPACK16(last, size);
      GETPACK16(current, t1);
      size += t1 - 2;
      PUTPACK16(last, size);
      minsert16(last);
      return;
    }
  }

  /*-------------------------------------------------------------------*/
  /* ATTEMPT TO COALESCE THE CURRENT WITH NEXT PACKET. (CURRENT, NEXT) */
  /*-------------------------------------------------------------------*/
  else if (next != NULL)
  {
    GETPACK16(next, t1);
    if (t1 < 0)
    {
      mremove16(next);
      GETPACK16(current, size);
      size += t1 - 2;
      PUTPACK16(current, size);
    }
    minsert16(current);
  }

  /*-------------------------------------------------------------------*/
  /* NO COALESCENCE POSSIBLE, JUST INSERT THIS PACKET INTO LIST        */
  /*-------------------------------------------------------------------*/
  else minsert16(current);
  return;
}


/*****************************************************************************/
/*									     */
/*  BMALLOC16 - Allocate a packet of a given size, and return pointer to it. */
/*	        This function only allocates in multiple of ints. 	     */
/*	        The packet of a given size is aligned on the proper boundary */
/*	        suitable for TMS320C3x and TMS320C4x circular buffers and    */
/*	        bit-reversed addressed buffers. Refer to TMS320C3x U.G.	     */
/*	        (SPRU031B) for information on circular buffers and           */
/*	        bit-reverse addressing.		 			     */
/*									     */
/*****************************************************************************/
void *bmalloc16(size_t size)
{
  PACKET16 *current;
  PACKET16 *cb_ptr = current = sys_free16;   /* ptr to word aligned buffer */
  int       newsize = size;
  int       oldsize;
  int       k;
  int       avail;

  if (!init) { minit(); init = 1; }

  if (newsize == 0) newsize = 2;

  /*--------------------------------------------------------------------*/
  /* k is the next power of 2 that is greater than the packet size      */
  /*--------------------------------------------------------------------*/
  for(k = 1; k <= newsize; k <<= 1);

  newsize = -newsize;

  /*---------------------------------------------------------------------*/
  /* Scan through free list for packet large enough to contain the word  */
  /* aligned packet. Remember that free package sizes are negative, so   */
  /* negate size. In order for a packet to be big enough first find a    */
  /* regular packet, calculate the next word aligned pointer and see if  */
  /* there is enough memory remaining in the packet for the desired	 */
  /* buffer size and that the word aligned address is not 2 away from    */
  /* the current packet since this will leave a packet (starting at	 */
  /* current) that is 0 words in size (NOT GOOD). Recall that the word   */
  /* aligned packet starts one word before the word aligned address.	 */
  /*---------------------------------------------------------------------*/
  /* cp_ptr = next address (maybe current) that is a multiple of k_size  */
  /*---------------------------------------------------------------------*/
  /* avail = available space from cb_ptr to end of current packet	 */
  /*---------------------------------------------------------------------*/
  /* Search forever until end of heap is reached (i.e. current = NULL)   */
  /* or a valid word aligned packet is reached (i.e. enough space	 */
  /* is available and it is not 1 away from current.			 */
  /*---------------------------------------------------------------------*/
  for(;;)
  {
    cb_ptr = (PACKET16 *) ((k*(((int) cb_ptr + 2 + (k-1))/k)) - 2);

    if((((int) cb_ptr - (int) current) <= 2) && 
       (((int) cb_ptr - (int) current) != 0))
      cb_ptr = (PACKET16 *) ((int) cb_ptr + k);

    GETPACK16(current, avail);
    avail = avail - (int) current + (int) cb_ptr;
    if ((current == NULL) || (avail <= newsize)) break;
    GETSIZE16(current, current);
    cb_ptr = current;
  }

  if (current == NULL) return NULL;

  mremove16(current);			 /* remove packet from free list */

  /*---------------------------------------------------------------------*/
  /* If space exists between current and cb_ptr, then return this packet */
  /* to the free list   						 */
  /*---------------------------------------------------------------------*/
  if(cb_ptr != current)
  {
    PUTPACK16(current, ((int) current - (int) cb_ptr + 2));
    minsert16(current);
    current = cb_ptr;
  }

  /*---------------------------------------------------------------------*/
  /* If space exists between the end of the required packet and the end  */
  /* of the current packet, return this packet to the free list	         */
  /*---------------------------------------------------------------------*/
  oldsize = avail;			     /* remember old size        */

  if (newsize - oldsize >= 4)
  {
    PACKET16 *next = (PACKET16 *) ((char *) current + 2 - newsize);
    PUTPACK16(next, (oldsize - newsize + 2));
    minsert16(next);
    PUTPACK16(current, -newsize);
  }
  else PUTPACK16(current, -oldsize);

  return &current->size_ptr;
}

memory8.c/      925421686   0     0     0       22573     `
/*****************************************************************************/
/* memory8.c V5.11 for TMS32032					     */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*---------------------------------------------------------------------------*/
/*  This module contains the functions which implement the dynamic memory    */
/*  management routines for 320C32 C.  The following assumptions/rules       */
/*  apply:                                                                   */
/*									     */
/*   1) Packets are allocated a minimum of one 8-bit word, max 2^31 words.   */
/*   2) The allocation system can be reset at any time by calling the        */
/*      function "minit8()".                                                 */
/*                                                                           */
/*   The 8-bit system memory area is declared as a .usect called ".sysm8".   */
/*   The size of the heap is set a link time using the -heap8 option.  No    */
/*   8-bit system memory area is allocated if -heap8 is not used, unless     */
/*   these routines are linked, in which case the size defaults to 0x400.    */
/*                                                                           */
/*  The following items are defined in this module :			     */
/*    minit8()	  : Function to initialize dynamic memory management.        */
/*    malloc8()   : Function to allocate memory from mem mgmt system.	     */
/*    calloc8()   : Allocate an clear memory from mem mgmt system.	     */
/*    realloc8()  : Reallocate a packet.				     */
/*    free8()	  : Function to free allocated memory.			     */
/*									     */
/*    minsert8()  : Insert a packet into free list, sorted by size	     */
/*    mremove8()  : Remove a packet from the free list.                      */
/*									     */
/*    bmalloc8()  : Function to allocate memory from mem mgmt system on a    */
/*		     boundary suitable for circular addressing.		     */
/*									     */
/*    sys_free8   : Pointer to free list 				     */
/*									     */
/*****************************************************************************/
#include <stdlib.h>
#include <string.h>

/*---------------------------------------------------------------------------*/
/* Declare the memory pool as a usect called .sysmem.                        */
/*---------------------------------------------------------------------------*/
#pragma DATA_SECTION(_sys_memory8, ".sysm8")
int _sys_memory8[1]; 

/*---------------------------------------------------------------------------*/
/*  _SYSMEM8_SIZE is declared as an absolute external label.  By taking its  */
/*  "address" here in the C file, we get the actual value assigned to the    */
/*   symbol, which is the size of the system memory area.                    */
/*---------------------------------------------------------------------------*/
extern int _SYSMEM8_SIZE;

#define MEMORY8_SIZE ((int)&_SYSMEM8_SIZE)         /* ASSIGNED BY LINKER */

/*---------------------------------------------------------------------------*/
/* "PACKET" is the template for a data packet.  Packet size contains         */
/* the number of words allocated for the user, excluding the size            */
/* required for management of the packet (4 words).  Packets are always      */
/* allocated memory in words.  A negative size indicates a free packet.      */
/*---------------------------------------------------------------------------*/
typedef struct pack8 
{
  int           packet_size[4];  /* high/low order 8-bits of packet size  */
  unsigned int  size_ptr[4];     /* high/low 0rder 8-bits of size pointer */
} PACKET8;

/*---------------------------------------------------------------------------*/
/* MACROS TO ACCESS PACKET8 VALUES AS 32-BIT VALUES                          */
/*---------------------------------------------------------------------------*/
typedef unsigned int uint;

#define GETPACK8(p,s) do { (s) = ((p)->packet_size[0] << 24) |               \
			         ((p)->packet_size[1] << 16) |               \
			         ((p)->packet_size[2] << 8 ) |               \
                                 ((p)->packet_size[3]      );                \
			 } while(0)

#define PUTPACK8(p,s) do { (p)->packet_size[0] =  (s) >> 24;                 \
			   (p)->packet_size[1] = ((s) << 8 ) >> 24;          \
			   (p)->packet_size[2] = ((s) << 16) >> 24;          \
			   (p)->packet_size[3] = ((s) << 24) >> 24;          \
                         } while(0)

#define GETSIZE8(p,s) do { (s) = (PACKET8 *)(((p)->size_ptr[0] << 24) |      \
					     ((p)->size_ptr[1] << 16) |      \
					     ((p)->size_ptr[2] << 8 ) |      \
					     ((p)->size_ptr[3]      ));      \
			 } while(0)

#define PUTSIZE8(p,s) do { (p)->size_ptr[0] =  (uint)(s) >> 24;              \
			   (p)->size_ptr[1] = ((uint)(s) << 8 ) >> 24;       \
                           (p)->size_ptr[2] = ((uint)(s) << 16) >> 24;       \
			   (p)->size_ptr[3] = ((uint)(s) << 24) >> 24;       \
                         } while(0)

static int init = 0;

static PACKET8 *sys_free8 = (PACKET8 *)_sys_memory8;

static void minsert8(PACKET8 *);
static void mremove8(PACKET8 *);

/*****************************************************************************/
/*									     */
/*  MINSERT8 - Insert a packet into the free list.  This list is sorted by  */
/*	      size in increasing order. 				     */
/*									     */
/*****************************************************************************/
static void minsert8(PACKET8 *ptr)
{
  int      t1,t2;
  PACKET8 *current = (PACKET8 *) sys_free8;
  PACKET8 *last    = NULL;

  /*------------------------------------------------------------------*/
  /* CHECK SPECIAL CASE, EMPTY FREE LIST.	                      */
  /*------------------------------------------------------------------*/
  if (current == NULL)
  {
    sys_free8 = ptr;
    PUTSIZE8(ptr, NULL);
    return;
  }

  /*------------------------------------------------------------------*/
  /* SCAN THROUGH LIST, LOOKING FOR A LARGER PACKET.		      */
  /*------------------------------------------------------------------*/
  GETPACK8(current,t1);
  GETPACK8(ptr,t2);
  while ((current != NULL) && (t1 > t2))
  {
    last = current;
    GETSIZE8(current, current);
    GETPACK8(current, t1);
  }

  /*------------------------------------------------------------------*/
  /* LINK THE NEW PACKET INTO THE LIST. THERE ARE THREE CASES :       */
  /* THE NEW POINTER WILL EITHER BE THE FIRST, THE LAST, OR IN THE    */
  /* MIDDLE SOMEWHERE.					              */
  /*------------------------------------------------------------------*/
  if (current == NULL)         /* PTR WILL BE LAST IN LIST */
  {
    PUTSIZE8(last, ptr);
    PUTSIZE8(ptr, NULL);
  }

  else if (last == NULL)       /* PTR WILL BE FIRST IN THE LIST */
  {
    PUTSIZE8(ptr, sys_free8);
    sys_free8 = ptr;
  }

  else                         /* PTR IS IN THE MIDDLE OF THE LIST */
  {
    PUTSIZE8(ptr, current);
    PUTSIZE8(last, ptr);
  }
}


/*****************************************************************************/
/*									     */
/* MREMOVE8 - REMOVE AN ITEM FROM THE FREE LIST. 			     */
/*									     */
/*****************************************************************************/
static void mremove8(PACKET8 *ptr)
{
  PACKET8 *current = sys_free8;
  PACKET8 *last    = NULL;
  PACKET8 *next    = NULL;

  /*------------------------------------------------------------------*/
  /* SCAN THROUGH LIST, LOOKING FOR PACKET TO REMOVE                  */
  /*------------------------------------------------------------------*/
  while ((current != NULL) && (current != ptr))
  {
    last    = current;
    GETSIZE8(current, current);
  }

  /*------------------------------------------------------------------*/
  /* REMOVE THE PACKET FROM THE LIST.   THERE ARE TWO CASES :         */
  /* THE OLD POINTER WILL EITHER BE THE FIRST, OR NOT THE FIRST.      */
  /*------------------------------------------------------------------*/
  if (current == NULL) 	 /* POINTER NOT FOUND IN LIST		*/
    sys_free8 = NULL;	 /* FATAL ERROR 			*/
  
  else if (last == NULL)
    GETSIZE8(ptr, sys_free8); /* PTR WAS BE FIRST IN THE LIST */

  else			 /* PTR IS IN THE MIDDLE OF THE LIST	*/
  {
    GETSIZE8(ptr, next);
    PUTSIZE8(last, next);
  }
}


/*****************************************************************************/
/*									     */
/*  MINIT8 - This function can be called by the user to completely reset     */
/*	     the memory management system.			       	     */
/*									     */
/*****************************************************************************/
void minit8(void)
{
  /*----------------------------------------------------------------------*/
  /* TO INITIALIZE THE MEMORY SYSTEM, DEALLOCATE ONE PACKET WHICH USES    */
  /* AVAILABLE MEMORY, INITIALIZE THE FREE LIST TO POINT TO IT.	          */
  /*----------------------------------------------------------------------*/
  sys_free8 = (PACKET8 *)_sys_memory8;

  PUTPACK8(sys_free8, -(MEMORY8_SIZE - 4));
  PUTSIZE8(sys_free8, NULL);
}


/*****************************************************************************/
/*									     */
/*  MALLOC8 - Allocate a packet of a given size, and return pointer to it.  */
/*	     This function only allocates in multiples of 8-bit words.	     */
/*									     */
/*****************************************************************************/
void *malloc8(size_t size)
{
  PACKET8  *current = sys_free8;
  PACKET8  *next;
  int       newsize = size;
  int       tmpsize, oldsize;

  if (!init) { minit8(); init = 1; }

  if (newsize == 0) newsize = 4;

  /*---------------------------------------------------------------------*/
  /* SINCE SMALLEST PACKET IS 8 8-BIT WORDS, SMALLEST SIZE IS 4.         */
  /*---------------------------------------------------------------------*/
  if (newsize < 4) newsize = 4;

  /*---------------------------------------------------------------------*/
  /* SCAN THROUGH FREE LIST FOR PACKET LARGE ENOUGH TO CONTAIN PACKET    */
  /* REMEMBER THAT FREE PACKAGE SIZES ARE NEGATIVE, SO NEGATE SIZE.      */
  /*---------------------------------------------------------------------*/
  newsize = -newsize;
  GETPACK8(current, tmpsize);
  while ((current != NULL) && (tmpsize > newsize))
  {
    GETSIZE8(current, current);
    GETPACK8(current, tmpsize);
  }
  
  if (current == NULL) return NULL;

  GETPACK8(current, oldsize);           /* REMEMBER OLD SIZE            */
  mremove8(current);		         /* REMOVE PACKET FROM FREE LIST */

  /*---------------------------------------------------------------------*/
  /* IF PACKET IS LARGER THAN NEEDED, FREE EXTRA SPACE AT END	         */
  /* BY INSERTING REMAINING SPACE INTO FREE LIST.                        */
  /*---------------------------------------------------------------------*/
  if (newsize - oldsize >= 8)
  {
    next = (PACKET8 *) ((char *) current + 4 - newsize);
    PUTPACK8(next, (oldsize - newsize + 4));
    PUTSIZE8(next, NULL);
    minsert8(next);
    PUTPACK8(current, -newsize);
  }
  else PUTPACK8(current, -oldsize);

  return &current->size_ptr;
}


/*****************************************************************************/
/*									     */
/*  CALLOC8 - Allocate a packet of a given size, set the data in the packet */
/*	       to nulls, and return a pointer to it.			     */
/*									     */
/*****************************************************************************/
void *calloc8(size_t num, size_t size)
{
  size_t i       = size * num;
  void  *result  = malloc8(i);

  if (result)
  {
    char *cp   = result;
    if (i) do *cp++ = 0; while (--i);
  }
  return result;
}


/*****************************************************************************/
/*									     */
/*  REALLOC8 - Reallocate a packet to a new size.			     */
/*									     */
/*****************************************************************************/
void *realloc8(void *packet, size_t newsize)
{
  PACKET8 *pptr = (PACKET8 *)((int)packet - 4);  /* PTR TO START OF PACKET */
  int   oldsize;

  /*--------------------------------------------------------------*/
  /* HANDLE SPECIAL CASES                                         */
  /*--------------------------------------------------------------*/
  if (packet == NULL)     return malloc8(newsize);
  if (newsize == 0)     { free8(packet);  return NULL; }
  GETPACK8(pptr, oldsize);
  if (oldsize <= 0)       return NULL;
  if (newsize == oldsize) return packet;

  /*--------------------------------------------------------------*/
  /* IF NEW SIZE IS LESS THAN CURRENT PACKET SIZE,                */
  /* TRUNCATE THE PACKET AND RETURN END TO FREE LIST	          */
  /*--------------------------------------------------------------*/
  if (newsize < oldsize)
  {
    if (oldsize - newsize < 8) return packet;
    PUTPACK8(pptr, newsize);                   /* SET NEW PACKET SIZE   */
    pptr += newsize + 4;                       /* SET PTR TO NEW PACKET */
    PUTPACK8(pptr, (oldsize - newsize - 4));
    free8(pptr + 4);      		       /* FREE TRAILING PACKET  */
    return packet;
  }

  /*--------------------------------------------------------------*/
  /* IF NEW SIZE IS BIGGER THAN CURRENT PACKET,		          */
  /* 1) CHECK NEXT PACKET IN LIST, SEE IF PACKET CAN BE EXPANDED  */
  /* 2) IF NOT, MOVE PACKET TO NEW LOCATION. 		          */
  /*--------------------------------------------------------------*/
  else
  {
    PACKET8 *next = (PACKET8 *)(pptr + oldsize + 4);
    int temp,t1;

    GETPACK8(next, t1);
    if (((int *)next < &_sys_memory8[MEMORY8_SIZE - 8]) &&
	((t1 < 0) && ((temp = oldsize - newsize - t1 + 4) >= 0)))
    {
      mremove8(next);
      if (temp < 8)
      {
	PUTPACK8(pptr, newsize + temp);
	return packet;
      }

      /*-------------------------------------------------------*/
      /* FREE TRAILING PACKET                                  */
      /*-------------------------------------------------------*/
      PUTPACK8(pptr, newsize);
      pptr += newsize + 4;
      PUTPACK8(pptr,-(temp - 4));
      minsert8(pptr);
      return packet;
    }
    else
    {
      /*-------------------------------------------------------*/
      /* ALLOCATE NEW PACKET AND MOVE DATA INTO IT. 	       */
      /*-------------------------------------------------------*/
      char *new = malloc8(newsize);
      if (new == NULL) return NULL;
      memcpy(new, pptr+4, oldsize);
      free8(packet);
      return new;
    }
  }
}


/*****************************************************************************/
/*									     */
/*  FREE8 - Return a packet allocated by malloc to free memory pool.	     */
/*									     */
/*****************************************************************************/
void free8(void *packet)
{
  int       size, t1;
  char    *ptr     = (char *)((int)packet - 4);
  PACKET8 *current = (PACKET8 *)_sys_memory8;
  PACKET8 *next    = NULL;
  PACKET8 *last    = NULL;

  /*-------------------------------------------------------------------*/
  /* SEARCH FOR THE POINTER IN THE PACKET POINTED TO                   */
  /*-------------------------------------------------------------------*/
  if (packet == NULL) return;

  while (current < (PACKET8 *)ptr)
  {
    int tempsize;
    GETPACK8(current, tempsize);
    last = current;
    if (tempsize < 0) tempsize = -tempsize; 
    current = (PACKET8 *)((char *)current + tempsize + 4);
  }

  /*-------------------------------------------------------------------*/
  /* CHECK FOR POINTER OR PACKET ERRORS.			       */
  /*-------------------------------------------------------------------*/
  GETPACK8(current, size);
  if ((current != (PACKET8 *) ptr) || (size < 0))
    return;

  PUTPACK8(current, -size);                     /* MARK PACKET AS FREE */
  GETPACK8(current, size);                      /* RESET SIZE VALUE    */
  /*-------------------------------------------------------------------*/
  /* GET POINTER TO NEXT PACKET IN MEMORY, IF ANY.		       */
  /*-------------------------------------------------------------------*/
  next = (PACKET8 *) ((char *)current - size + 4);
  if (next > (PACKET8 *) &_sys_memory8[MEMORY8_SIZE - 8]) next = NULL;

  /*-------------------------------------------------------------------*/
  /* ATTEMPT TO COALESCE THE THREE PACKETS (PREVIOUS, CURRENT, NEXT)   */
  /*-------------------------------------------------------------------*/
  size = 0;
  if (last != NULL) GETPACK8(last, size);
  if (size < 0)
  {
    t1 = 0;
    if (next != NULL) GETPACK8(next, t1);
    if (t1 < 0)
    {
      mremove8(last);
      mremove8(next);
      size += t1;
      GETPACK8(current, t1);
      size += t1 - 8;
      PUTPACK8(last, size);
      minsert8(last);
      return;
    }
    else
    {
      mremove8(last);
      GETPACK8(last, size);
      GETPACK8(current, t1);
      size += t1 - 4;
      PUTPACK8(last, size);
      minsert8(last);
      return;
    }
  }

  /*-------------------------------------------------------------------*/
  /* ATTEMPT TO COALESCE THE CURRENT WITH NEXT PACKET. (CURRENT, NEXT) */
  /*-------------------------------------------------------------------*/
  else if (next != NULL)
  {
    GETPACK8(next, t1);
    if (t1 < 0)
    {
      mremove8(next);
      GETPACK8(current, size);
      size += t1 - 4;
      PUTPACK8(current, size);
    }
    minsert8(current);
  }

  /*-------------------------------------------------------------------*/
  /* NO COALESCENCE POSSIBLE, JUST INSERT THIS PACKET INTO LIST        */
  /*-------------------------------------------------------------------*/
  else minsert8(current);
  return;
}


/*****************************************************************************/
/*									     */
/*  BMALLOC8 - Allocate a packet of a given size, and return pointer to it.  */
/*	        This function only allocates in multiple of ints. 	     */
/*	        The packet of a given size is aligned on the proper boundary */
/*	        suitable for TMS320C3x and TMS320C4x circular buffers and    */
/*	        bit-reversed addressed buffers. Refer to TMS320C3x U.G.	     */
/*	        (SPRU031B) for information on circular buffers and           */
/*	        bit-reverse addressing.		 			     */
/*									     */
/*****************************************************************************/
void *bmalloc8(size_t size)
{
  PACKET8 *current;
  PACKET8 *cb_ptr = current = sys_free8;   /* ptr to word aligned buffer */
  int      newsize = size;
  int      oldsize;
  int      k;
  int      avail;

  if (!init) { minit(); init = 1; }

  if (newsize == 0) newsize = 4;

  /*--------------------------------------------------------------------*/
  /* k is the next power of 2 that is greater than the packet size      */
  /*--------------------------------------------------------------------*/
  for(k = 1; k <= newsize; k <<= 1);

  newsize = -newsize;

  /*---------------------------------------------------------------------*/
  /* Scan through free list for packet large enough to contain the word  */
  /* aligned packet. Remember that free package sizes are negative, so   */
  /* negate size. In order for a packet to be big enough first find a    */
  /* regular packet, calculate the next word aligned pointer and see if  */
  /* there is enough memory remaining in the packet for the desired	 */
  /* buffer size and that the word aligned address is not 4 away from    */
  /* the current packet since this will leave a packet (starting at	 */
  /* current) that is 0 words in size (NOT GOOD). Recall that the word   */
  /* aligned packet starts one word before the word aligned address.	 */
  /*---------------------------------------------------------------------*/
  /* cp_ptr = next address (maybe current) that is a multiple of k_size  */
  /*---------------------------------------------------------------------*/
  /* avail = available space from cb_ptr to end of current packet	 */
  /*---------------------------------------------------------------------*/
  /* Search forever until end of heap is reached (i.e. current = NULL)   */
  /* or a valid word aligned packet is reached (i.e. enough space	 */
  /* is available and it is not 1 away from current.			 */
  /*---------------------------------------------------------------------*/
  for(;;)
  {
    cb_ptr = (PACKET8 *) ((k*(((int) cb_ptr + 4 + (k-1))/k)) - 4);

    if((((int) cb_ptr - (int) current) <= 4) &&
       (((int) cb_ptr - (int) current) != 0))
      cb_ptr = (PACKET8 *) ((int) cb_ptr + k);

    GETPACK8(current, avail);
    avail = avail - (int) current + (int) cb_ptr;
    if ((current == NULL) || (avail <= newsize)) break;
    GETSIZE8(current, current);
    cb_ptr = current;
  }

  if (current == NULL) return NULL;

  mremove8(current);			 /* remove packet from free list */

  /*---------------------------------------------------------------------*/
  /* If space exists between current and cb_ptr, then return this packet */
  /* to the free list   						 */
  /*---------------------------------------------------------------------*/
  if(cb_ptr != current)
  {
    PUTPACK8(current, ((int) current - (int) cb_ptr + 4));
    minsert8(current);
    current = cb_ptr;
  }

  /*---------------------------------------------------------------------*/
  /* If space exists between the end of the required packet and the end  */
  /* of the current packet, return this packet to the free list	         */
  /*---------------------------------------------------------------------*/
  oldsize = avail;			     /* remember old size        */

  if (newsize - oldsize >= 8)
  {
    PACKET8 *next = (PACKET8 *) ((char *) current + 4 - newsize);
    PUTPACK8(next, (oldsize - newsize + 4));
    minsert8(next);
    PUTPACK8(current, -newsize);
  }
  else PUTPACK8(current, -oldsize);

  return &current->size_ptr;
}

memset.c/       925421688   0     0     0       600       `
/*****************************************************************************/
/* memset.c V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <string.h>

void *memset(void *s, int c, size_t n)
{
   if ( n > 0 )
   {
      char          *mem = s;
      unsigned char ch   = c;

      do *mem++ = ch; while (--n != 0);
   }

   return s;
}
mktime.c/       925421688   0     0     0       4688      `
/*****************************************************************************/
/* mktime.c V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <time.h>
#include <limits.h>

static unsigned int  mon_len[] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
static unsigned int  mon_day[] = { 0,31,59,90,120,151,181,212,243,273,304,334 };

#define JAN11900    1                   
#define DAYS_IN_YR  365     
#define SECS_IN_DAY (60 * 60 * 24)
#define SECS_IN_YR  (DAYS_IN_YR * SECS_IN_DAY)

/* THE FOLLOWING MACRO DETERINES IF ADDING k TO x CAUSES OVERFLOW */

#define OVERFLOW(x,k) (((x) > 0) == ((k) > 0) &&          \
                       ((unsigned)(x)       <= INT_MAX) != \
		       ((unsigned)((x)+(k)) <= INT_MAX))

#define LEAPYEAR(y)   ( ((y + 1900) % 4 == 0) &&      \
                       (((y + 1900) % 100 != 0) || ((y + 1900) % 400 == 0)) )

time_t mktime(register struct tm *tptr)
{
   time_t   result;
   int      daycount;
   int      adjust;
    
   /*-----------------------------------------------------------------*/
   /* HANDLE SECONDS.  IF TOO MANY OR TOO FEW, MODIFY MINUTES.        */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_sec < 0) ? -((unsigned)(-tptr->tm_sec + 59) / 60) 
			       : (tptr->tm_sec / 60);

   if (OVERFLOW(tptr->tm_min, adjust)) return((time_t) -1);
   tptr->tm_min += adjust;
   tptr->tm_sec -= adjust * 60;

   /*-----------------------------------------------------------------*/
   /* HANDLE MINUTES.  IF TOO MANY OR TOO FEW, MODIFY HOURS           */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_min < 0) ? -((unsigned)(-tptr->tm_min + 59) / 60) 
			       : (tptr->tm_min / 60);

   if (OVERFLOW(tptr->tm_hour, adjust)) return((time_t) -1);
   tptr->tm_hour += adjust;
   tptr->tm_min  -= adjust * 60;

   /*-----------------------------------------------------------------*/
   /* HANDLE HOURS.    IF TOO MANY OR TOO FEW, MODIFY DAYS            */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_hour < 0) ? -((unsigned)(-tptr->tm_hour + 23) / 24) 
			        : (tptr->tm_hour / 24);

   if (OVERFLOW(tptr->tm_mday, adjust)) return((time_t) -1);
   tptr->tm_mday += adjust;
   tptr->tm_hour -= adjust * 24;

   for (;;)
   {
      /*-----------------------------------------------------------------*/
      /* HANDLE MONTHS.   IF TOO MANY OR TOO FEW, MODIFY YEARS           */
      /*-----------------------------------------------------------------*/
      adjust = (tptr->tm_mon < 0) ? -((unsigned)(-tptr->tm_mon + 11) / 12) 
				  : (tptr->tm_mon / 12);

      if (OVERFLOW(tptr->tm_year, adjust)) return((time_t) -1);
      tptr->tm_year += adjust;
      tptr->tm_mon  -= adjust * 12;

      /*-----------------------------------------------------------------*/
      /* HANDLE DAYS.     IF TOO MANY OR TOO FEW, MODIFY MONTHS          */
      /*-----------------------------------------------------------------*/
      if (tptr->tm_mday <= 0)
      { 
	   tptr->tm_mon--;  
           tptr->tm_mday += mon_len[tptr->tm_mon < 0 ? 11 : tptr->tm_mon] + 
		        ((tptr->tm_mon == 1) && ((tptr->tm_year % 4) == 0));
	   continue;
      }

      /*-----------------------------------------------------------------*/
      /* CALCULATE NUMBER OF DAYS IN THIS MONTH.                         */
      /*-----------------------------------------------------------------*/
      daycount = mon_len[tptr->tm_mon] + 
		( (tptr->tm_mon == 1) && LEAPYEAR(tptr->tm_year) );

      if (tptr->tm_mday > daycount) 
	{ tptr->tm_mday -= daycount; tptr->tm_mon++; }
      else break;
   }

   /*--------------------------------------------------------------------*/
   /* WE CAN NOW BE SURE THAT ALL FIELDS IN THE TIME STRUCTURE ARE RIGHT */
   /*--------------------------------------------------------------------*/
   tptr->tm_yday = mon_day[tptr->tm_mon]  + tptr->tm_mday - 1 +
                   ( (tptr->tm_mon > 1) && LEAPYEAR(tptr->tm_year) );

   daycount      = tptr->tm_year * DAYS_IN_YR  + 
	           ((tptr->tm_year - 1) / 4)   + tptr->tm_yday;

   result        = daycount      * SECS_IN_DAY + 
	           tptr->tm_hour * (60 * 60)   +
	           tptr->tm_min  * 60          + tptr->tm_sec;

   tptr->tm_wday  = (JAN11900 + daycount) % 7;
   tptr->tm_isdst = 0;

   return result;
}

perror.c/       925421688   0     0     0       2029      `
/*****************************************************************************/
/*  PERROR.C V5.11                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PERROR   -  Report any system errors to stderr                         */
/*****************************************************************************/
#include <stdio.h>
#include <errno.h>


/*****************************************************************************/
/* PERROR   -  Report any system errors to stderr                            */
/*****************************************************************************/
void perror(const char *_s)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char *buf;

   /*------------------------------------------------------------------------*/
   /* If _s is not NULL, prepend it to any error message.                    */
   /*------------------------------------------------------------------------*/
   if (_s && *_s)
   {
      fputs(_s, stderr);
      fputs(": ", stderr);
   }

   switch(errno)
   {
      case 0      :  buf = "No error";                  break;
      case EDOM   :  buf = "Domain error";              break;
      case ERANGE :  buf = "Range error";               break;
      case ENOENT :  buf = "No such file or directory"; break;
      case EFPOS  :  buf = "File positioning error";    break;
      default     :  buf = "Unknown error";             break;
   }

   fputs(buf, stderr);
   fputc('\n', stderr);
}


pow.c/          925421688   0     0     0       4652      `
/*****************************************************************************/
/* pow.c V5.11 for TMS3203x/4x                                              */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/

#include <math.h>
#include <values.h>
#include <errno.h>

double _log(double x);                 /* Like log() with no error checking */

/****************************************************************************/
/*  POW() - Power							    */
/*									    */
/*  z = mantissa x							    */
/*  log2(z) = c1 * z ^ 9 + c2 * z ^ 7 + c3 * z ^ 5 + c4 * z ^ 3 + c5 * z    */
/*  log2(x) = exponent x + log2(z)					    */
/*  a = y * log2(x)							    */
/*  b = mantissa a							    */
/*  2 ^ b =  (((((d1 * b + d2) * b + d3) * b + d4) * b + d5) * b + d6)	    */
/*									    */
/*  result = 2 ^ exponent a * 2 ^ b					    */
/*	   = 2 ^ (y * log2(x))						    */
/****************************************************************************/
double pow(double x, double y)
{
    double x2;
    int n;
    int sign = 0;
    int iy = (int)y;

    /* 0 ^^ n, n < 0 => 1 / 0 ^^ n => 1 / 0 => error */
    if ((x == 0.0) && (y <= 0.0))
    {
	errno = EDOM;
	return 0.0;
    }
    
    /* x ^^ 0 = 1.0 */
    if (y == 0.0) return (1.0);
    
    /* x ^^ 1 = x */
    if (y == 1.0) return (x);
    
    /* 1 ^^ y = 1.0 */
    if (x == 1.0) return(1.0);
    
    /* -1 ^^ y = -1.0 if y is odd integer, return 1.0 if y is even. */
    /* -1 ^^ 0 handled before we get here.                          */
    if ((x == -1.0) && (y == iy)) return (iy & 1) ? -1.0 : 1.0;
    
    /* 0 ^^ n => 0, n > 0 */
    if (x == 0.0)
    {
	return 0.0;
    }
    
    /* 2 ^^ y (times 1.0)*/
    if ((x == 2.0) && (y == iy)) return ldexp(1.0, iy);
    if ((x == -2.0) && (y == iy)) return (iy & 1) ? -ldexp(1.0, iy) 
	: ldexp(1.0, iy);
    
    if (x < 0.0)
    {
	/*****************************************************************/
	/* if y is not an integer, a domain error occurs                 */
	/*****************************************************************/
	if ((y - iy) != 0.0) 
	{ 
	    errno = EDOM; 
	    return 0.0; 
	}
	
	/*****************************************************************/
	/* if x < 0, compute the power of |x|                            */
	/*****************************************************************/
	x = -x;
	
	/*****************************************************************/
	/* for odd exponents, negate the answer                          */
	/*****************************************************************/
	if (iy & 1)
	{
	    sign = 1;
	}
    }
    
    /***************************************************************/
    /* x = mantissa of x, n = exponent of x                        */
    /***************************************************************/
    x = 2.0 * frexp(x, &n);
    --n;
    
    /***************************************************************/
    /* log2(x) is approximately (x - sqrt(2) / x + sqrt(2))        */
    /***************************************************************/
    x  = (x - SQRTWO) / (x + SQRTWO);
    x2 = x * x;
    
    /***************************************************************/
    /* polynomial expansion for log2(x)                            */
    /***************************************************************/
    x = ((((L7 * x2 + L5) * x2 + L3) * x2 + L1) * x + 0.5);
    
    /***************************************************************/
    /* log2(x) = log2(mantissa(x)) + exponent(x)                   */
    /***************************************************************/
    x += n;
    
    /***************************************************************/
    /* x = y * log2(x)                                             */
    /* n = integer part of x                                       */
    /* x = fractional part of x                                    */
    /***************************************************************/
    x *= y;
    n  = x;
    if ((x -= n) < 0) 
    { 
	x += 1.0; 
	n -= 1; 
    }
    
    /***************************************************************/
    /* polynomial expansion for 2 ^ x                              */
    /***************************************************************/
    x = ((((((T6 * x + T5) * x + T4) * x + T3)
	   * x + T2) * x + T1) * x + 1.0);
    
    x = ldexp(x, n);
    return (sign) ? -x : x;
}
printf.c/       925421688   0     0     0       2895      `
/*****************************************************************************/
/*  PRINTF.C V5.11                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PRINTF   -  Print formatted output to stdio                            */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op, 
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);
 
 
 
 
 

/*****************************************************************************/
/* PRINTF   -  Print formatted output to stdio                               */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream stdio.            */
/*                                                                           */
/*****************************************************************************/
int printf(const char *_format, ...)
{
   va_list _ap;
   int rval;
   char *fptr = (char *)_format;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(stdout->fd == -1) return (-1);

   va_start(_ap, _format);
   rval = _printfi(&fptr, _ap, (void *)stdout, _outc, _outs);
   va_end(_ap);
   return (rval);
}
 
 
 



/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }
 
 
 
 
 

/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }


qsort.c/        925421690   0     0     0       1600      `
/*****************************************************************************/
/* qsort.c V5.11 for TMS3203x/4x                                            */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <stdlib.h>

static void swap_item(char *src, char *dest, size_t size);

void qsort(void *base, size_t nmemb, size_t size, int (*compar)())
{
   char    *basep  = base;                  /* POINTER TO ARRAY OF ELEMENTS */
   unsigned i      = 0;                     /* LEFT SCAN INDEX              */
   unsigned j      = nmemb - 1;             /* RIGHT SCAN INDEX             */
   unsigned pivot  = (nmemb / 2);
   char    *pivp   = basep + (pivot * size);

   if (nmemb <= 1) return;

   while (i < j)
   {
      while ((*compar)(basep + (i * size), pivp) < 0) ++i;
      while ((*compar)(basep + (j * size), pivp) > 0) --j;
      if (i < j)
      {
	 swap_item(basep + (i * size), basep + (j * size), size);
	 if      (pivot == i) { pivot = j; pivp = basep + (pivot * size); }
	 else if (pivot == j) { pivot = i; pivp = basep + (pivot * size); } 
	 ++i; --j;
      }
      else if (i == j) { ++i; --j; break; }
   }

   if (j > 0)       qsort(basep, j + 1, size, compar);
   if (i < nmemb-1) qsort(basep + (i * size), nmemb - i, size, compar);
}


static void swap_item(char *src, char *dest, size_t size)
{
    if (size != 0) do 
    {
	int temp = *src;
	*src++   = *dest;
	*dest++  = temp; 
    }
    while (--size);
}

rand.c/         925421690   0     0     0       3373      `
/*****************************************************************************/
/* rand.c V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*                                                                           */
/* NOTE:  This file should be compiled with the -mm (short multiply)         */
/*        switch for best results.                                           */
/*****************************************************************************/
#include <stdlib.h>

static unsigned next = 1;

/****************************************************************************/
/* RAND() - COMPUTE THE NEXT VALUE IN THE RANDOM NUMBER SEQUENCE.           */
/*                                                                          */
/*     The sequence used is x' = (A*x) mod M,  (A = 16807, M = 2^31 - 1).   */
/*     This is the "minimal standard" generator from CACM Oct 1988, p. 1192.*/
/*     The implementation is based on an algorithm using 2 31-bit registers */
/*     to represent the product (A*x), from CACM Jan 1990, p. 87.           */
/*                                                                          */ 
/****************************************************************************/ 
#define A 16807u                        /* MULTIPLIER VALUE    */

int rand()
{
     unsigned x0 = (next << 16) >> 16;  /* 16 LSBs OF SEED     */
     unsigned x1 = next >> 16;          /* 16 MSBs OF SEED     */
     unsigned p, q;                     /* MSW, LSW OF PRODUCT */

     /*---------------------------------------------------------------------*/
     /* COMPUTE THE PRODUCT (A * next) USING CROSS MULTIPLICATION OF        */
     /* 16-BIT HALVES OF THE INPUT VALUES.  THE RESULT IS REPRESENTED AS 2  */
     /* 31-BIT VALUES.  SINCE 'A' FITS IN 15 BITS, ITS UPPER HALF CAN BE    */
     /* DISREGARDED.  USING THE NOTATION val[m::n] TO MEAN "BITS n THROUGH  */
     /* m OF val", THE PRODUCT IS COMPUTED AS:                              */
     /*   q = (A * x)[0::30]  = ((A * x1)[0::14] << 16) + (A * x0)[0::30]   */
     /*   p = (A * x)[31::60] =  (A * x1)[15::30]       + (A * x0)[31]  + C */
     /* WHERE C = q[31] (CARRY BIT FROM q).  NOTE THAT BECAUSE A < 2^15,    */
     /* (A * x0)[31] IS ALWAYS 0.                                           */
     /*---------------------------------------------------------------------*/
     q = ((A * x1) << 17 >> 1) + (A * x0);
     p = ((A * x1) >> 15) + (q >> 31);
     q = q << 1 >> 1;                           /* CLEAR CARRY */

     /*---------------------------------------------------------------------*/
     /* IF (p + q) < 2^31, RESULT IS (p + q).  OTHERWISE, RESULT IS         */
     /* (p + q) - 2^31 + 1.  (SEE REFERENCES).                              */
     /*---------------------------------------------------------------------*/
     p += q;
     return next = ((p + (p >> 31)) << 1) >> 1; /* ADD CARRY, THEN CLEAR IT */
}

/****************************************************************************/
/* SRAND() - SET THE INITIAL SEED FOR RAND().                               */
/****************************************************************************/
void srand(unsigned seed)
{
     next = seed;
}


remove.c/       925421690   0     0     0       1006      `
/*****************************************************************************/
/*  REMOVE.C V5.11                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    REMOVE   -  Erase a file                                               */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"






/*****************************************************************************/
/* REMOVE   -  Erase a file                                                  */
/*****************************************************************************/
int remove(const char *_file) { return (_remove(_file)); }

rewind.c/       925421690   0     0     0       1074      `
/*****************************************************************************/
/*  REWIND.C V5.11                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    REWIND   -  Position a stream's file pointer to the beginning of a     */
/*                file                                                       */
/*****************************************************************************/
#include <stdio.h>






/*****************************************************************************/
/* REWIND   -  Position a stream's file pointer to the beginning of a file   */
/*****************************************************************************/
void  rewind(register FILE *_fp) { fseek(_fp, 0L, SEEK_SET); }


setbuf.c/       925421690   0     0     0       1378      `
/*****************************************************************************/
/*  SETVBUF.C V5.11                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SETBUF   -  Set the default buffering mode for a stream                */
/*****************************************************************************/
#include <stdio.h>
 
 
 
 
 

/*****************************************************************************/
/* SETBUF   -  Set the default buffering mode for a stream                   */
/*                                                                           */
/*    This function calls SETVBUF, and sets the buffering mode to non-       */
/*    buffered if _BUF is NULL, or fully-buffered if _BUF is not NULL.       */
/*                                                                           */
/*****************************************************************************/
void setbuf(register FILE *_fp, char *_buf)
{
   setvbuf(_fp, _buf, _buf ? _IOFBF : _IONBF, BUFSIZ);
   return;
}
 

setvbuf.c/      925421690   0     0     0       4107      `
/*****************************************************************************/
/*  SETVBUF.C  V5.11                                                        */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SETVBUF  -  Set the buffering mode for a stream                        */
/*****************************************************************************/
#include <stdio.h>
#include <stdlib.h>

extern void   _cleanup();
extern void  (*_cleanup_ptr)(void);






/*****************************************************************************/
/* SETVBUF  -  Set the buffering mode for a stream                           */
/*                                                                           */
/*    This function sets the buffering mode for a stream, and allocates a    */
/*    buffer for it if necessary.                                            */
/*                                                                           */
/*****************************************************************************/
int setvbuf(register FILE *_fp, register char *_buf, register int _type, 
            register size_t _size)
{
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1 || _size <= 0) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If a buffer already exists, free it if it was malloc'd, and reset all  */
   /* of the stream's buffer pointers.                                       */
   /*------------------------------------------------------------------------*/
   if(_fp->buf)
   {
      if(_STCHK(_fp, _BUFFALOC)) free((_fp->buf)-1);
      _UNSET(_fp, _BUFFALOC);
      _fp->buf = NULL;
      _fp->pos = NULL;
      _fp->bufend = NULL;
      _fp->buff_stop = NULL;
   }

   /*------------------------------------------------------------------------*/
   /* If NULL was used for the buffering mode, default to fully-buffered.    */
   /*------------------------------------------------------------------------*/
   if(! _type) _type = _IOFBF;

   /*------------------------------------------------------------------------*/
   /* Clear any previous buffering flags, and set the new one.               */
   /*------------------------------------------------------------------------*/
   _UNSET(_fp, (_IOLBF | _IOFBF | _IONBF));
   _SET(_fp, _type);

   /*------------------------------------------------------------------------*/
   /* If a buffer was provided, but its size is only one byte, allocate a    */
   /* different one.  Also, do not allow a buffer size greater than BUFSIZ.  */
   /* The buffer will always have one space at the beginning that is         */
   /* for UNGETC, in the event that an UNGETC is performed on an empty file, */
   /* or when the buffer is full, but unread.                                */
  /*------------------------------------------------------------------------*/
   if(_size == 1) _buf = NULL;
   if(_size > BUFSIZ-1) _size = BUFSIZ -1;
   _size++;

   if (_buf) _fp->pos = _fp->buf = (unsigned char*)_buf+1;
   else
   {
      if (! (_fp->pos = _fp->buf = (unsigned char*)malloc(_size))) return (EOF);
      _fp->pos++;
      _fp->buf++;
      _SET(_fp, _BUFFALOC);
   }

   _fp->bufend = _fp->buf + _size -1;

   /*------------------------------------------------------------------------*/
   /* SETUP _CLEANUP_PTR SO ALL BUFFERS WILL BE FLUSHED AT EXIT.             */
   /*------------------------------------------------------------------------*/
   _cleanup_ptr = _cleanup;

   return (0);
}
   

sin.c/          925421692   0     0     0       2244      `
/*****************************************************************************/
/* sin.c V5.11 for TMS3203x/4x                                              */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/

#include <math.h>
#include <values.h>

/****************************************************************************/
/*  SIN() - sine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 8.              */
/*									    */
/*  N = round(x / PI)							    */
/*  f = x - N * PI							    */
/*  g = f * f								    */
/*  R = polynomial expansion 						    */
/*									    */
/*  result = f + f * R							    */
/*									    */
/*  if x < 0, result = - result 					    */
/*  if N is even, result = - result					    */
/*									    */
/*  This will return the wrong result for x >= MAXINT * PI		    */
/****************************************************************************/
double sin(double x)
{
    double xn, f, g, rg;
    float  sgn = (x < 0) ? -1.0 : 1.0;
    int    n;

    x  = fabs(x);
    n  = (int) ((x * INVSPI) + 0.5);
    xn = (double) n;

    /*************************************************************************/
    /* if n is odd, negate the sign                                          */
    /*************************************************************************/
    if (n % 2) sgn = -sgn;

    /*************************************************************************/
    /* f = x - xn * PI (but mathematically more stable)                      */
    /*************************************************************************/
    f = (x - xn * C1) - xn * C2;

    /*************************************************************************/
    /* determine polynomial expression                                       */
    /*************************************************************************/
    g = f * f;

    rg = (((R4 * g + R3) * g + R2) * g + R1) * g;

    return (sgn * (f + f * rg));
}
sinh.c/         925421692   0     0     0       3722      `
/*****************************************************************************/
/* sinh.c V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/

#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  SINH() - Hyberbolic Sine						    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 12.             */
/*									    */
/*  result = (exp(x) - 1 / exp(x)) / 2					    */
/*  if x < 0, result = - result 					    */
/*  if abs(x) <=1, R = polynomial expansion; result = x + x^3 * R           */
/*  if abs(x) >1, result = (exp(x) - 1/exp(x))/2                            */
/****************************************************************************/
double sinh(double x)
{
    double g, z, q, p, r, a, b;
    float  s = (x < 0) ? -1.0 : 1.0;
    int    n;

    if ((x = fabs(x)) <= 1.0)
    {
      g = x * x;

      /************************************************************************/
      /* determine polynomial expression                                      */
      /************************************************************************/
      p = SHP1 * g + SHP0;
      q = g + SHQ0;

      return ((x + x * g * (p / q)) * s);
    }

    /**************************************************************************/
    /* check to see if overflow would occur                                   */
    /**************************************************************************/
    if (x > MAXH) { errno = ERANGE; return (s == 1.0 ? HUGE_VAL : -HUGE_VAL); }

    if (x < 0) n = (int) (x * INVLOGe2 - 0.5);   /* since (int) -1.5 = -1.0 */
    else       n = (int) (x * INVLOGe2 + 0.5);

    /**************************************************************************/
    /* g = x - n * ln(2) (but more mathematically stable)                     */
    /**************************************************************************/
    g = (x - n * C3) - n * C4;

    /**************************************************************************/
    /* determine polynomial expression                                        */
    /**************************************************************************/
    z = g * g;

    p = (EXP1 * z + EXP0) * g;
    q = EXQ1 * z + EXQ0;

    /**************************************************************************/
    /* calculate exp(g)                                                       */
    /**************************************************************************/
    r = 0.5 + p / (q - p);

    /**************************************************************************/
    /* exp(x)/2 = exp(g) * 2 ^ n                                              */
    /**************************************************************************/
    a = ldexp(r, n);

    /**************************************************************************/
    /* exp(-x)*2 = 1 / (exp(x)/2)                                             */
    /**************************************************************************/
    b = 1.0 / a;

    /**************************************************************************/
    /* sinh(x) = (exp(x)/2 - (exp(-x)*2)/4) * sign(x)                         */
    /**************************************************************************/
    return ((a - b * 0.25) * s);
}
sprintf.c/      925421692   0     0     0       2964      `
/*****************************************************************************/
/*  SPRINTF.C V5.11                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SPRINTF  -  Copy formatted output to a string                          */
/*    _OUTC    -  Put a character in a string                                */
/*    _OUTS    -  Append a string to another string                          */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int   _printfi(char **_format, va_list _ap, void *_op,
		      int (*_outc)(char, void *), int (*_outs)(char *, void *));

static int   _outc(char c, void *_op);
static int   _outs(char *s, void *_op);
static char *out_end;


/*****************************************************************************/
/* SPRINTF  -  Copy formatted output to a string                             */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the string _STRING.          */
/*                                                                           */
/*****************************************************************************/
int sprintf(char *_string, const char *_format, ...)
{
   va_list _ap;
   int rval;
   char *fptr = (char *)_format;

   /*------------------------------------------------------------------------*/
   /* INITIALIZE THE END OF STRING BUFFER POINTER.                           */
   /*------------------------------------------------------------------------*/
   out_end = _string;

   va_start(_ap, _format);
   rval = _printfi(&fptr, _ap, (void *)_string, _outc, _outs);

   *out_end = '\0';

   va_end(_ap);
   return (rval);

}


/*****************************************************************************/
/* _OUTC -  Put a character in a string                                      */
/*****************************************************************************/
static int _outc(char c, void *_op)
{
   return *out_end++ = c;
}


/*****************************************************************************/
/* _OUTS -  Append a string to another string                                */
/*****************************************************************************/
static int _outs(char *s, void *_op)
{
   size_t len = strlen(s);

   memcpy(out_end, s, len);
   out_end += len;
   return len;
}
 
sscanf.c/       925421692   0     0     0       4368      `
/*****************************************************************************/
/*  SSCANF.C V5.11                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SSCANF      -  Read formatted input from a string                      */
/*    _INPCHAR    -  Get a character from the string                         */
/*    _UNINPCHAR  -  Put a character back onto the string                    */
/*    _CHKMBC     -  Check that the characters match the input               */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <ctype.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

static char _inpchar(void **inp);
static void _uninpchar(void **inp, char outchar);
static int _chkmbc(void **inp, char **_format, int *num_read);






/*****************************************************************************/
/* SSCANF   -  Read formatted input from a string                            */
/*                                                                           */
/*    This function returns the number of arguments that were assigned a     */
/*    value.                                                                 */
/*                                                                           */
/*****************************************************************************/
int sscanf(const char *_str, const char *_fmt, ...)
{
   va_list _ap;
   va_start(_ap, _fmt);

   return (_scanfi((void *)_str, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));

}






/*****************************************************************************/
/* _INPCHAR -  Get a character from the string                               */
/*****************************************************************************/
static char _inpchar(void **inp)
{
   char result;
   char *buf = (char *)(*inp);

   result = *(buf++);
   *inp = (void *)buf;  

   return ((result == '\0') ? EOF : result);
}






/*****************************************************************************/
/* _UNINPCHAR  -  Put a character back into the string                       */
/*****************************************************************************/
static void _uninpchar(void **inp, char outchar)
{
   char *buf = (char *)(*inp);
   buf--;
   *inp = (void *)buf;  
   return;
}






/*****************************************************************************/
/* _CHKMBC  -  Check that the characters match the input                     */
/*                                                                           */
/*    Check that all characters in the format string that are not part of a  */
/*    conversion specification match the input, until the next '%' or the    */
/*    end of the format string is reached.  The function returns a 0 upon    */
/*    reaching the end of the format string or a mismatch, or a 1 if a '%'   */
/*    is encountered.                                                        */
/*                                                                           */
/*****************************************************************************/
static int _chkmbc(void **inp, char **_format, int *num_read)
{
   char *buf = (char *)*inp;

   /*------------------------------------------------------------------------*/
   /* If there is a white space character in the format statement, skip to   */
   /* the next non-white space character in the input.                       */
   /*------------------------------------------------------------------------*/
   while(isspace(**_format))
   {
      for(;isspace(*buf); buf++) (*num_read)++;
      (*_format)++;
   }

   for(;(**_format != '%') && (**_format != '\0');)
      if(*((*_format)++) != *(buf++)) return (0);
      else (*num_read)++;

   if(**_format == '%')
   {
      *inp = (void *)buf;
       return 1;
   }
   else return (0);
}

strcat.c/       925421692   0     0     0       629       `
/*****************************************************************************/
/* strcat.c V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <string.h>

char *strcat(char *dest, const char *src)
{
   char *r1 = dest - 1;

   do {} while (*++r1);			     /* FIND END OF STRING   */
   do {} while ((*r1++ = *src++) != 0);	     /* APPEND SECOND STRING */
   return dest;
}

strchr.c/       925421694   0     0     0       609       `
/*****************************************************************************/
/* strchr.c V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <string.h>

char *strchr(const char *string, int ch)
{
   char *str = (char *)string - 1;
   int   tch;

   for (;;)
     if      ( (tch = *++str) == ch ) return str;
     else if ( tch == 0 ) return NULL;
}

strcmp.c/       925421694   0     0     0       626       `
/*****************************************************************************/
/* strcmp.c V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <string.h>

int strcmp(const char *string1, const char *string2)
{
   char *r1 = (char *)string1 - 1;
   char *r2 = (char *)string2 - 1;
   char cp;

   do {} while ( (*++r2 == (cp = *++r1)) && cp );

   return *r1 - *r2;
}
strcoll.c/      925421694   0     0     0       569       `
/*****************************************************************************/
/* strcoll.c V5.11 for TMS3203x/4x                                          */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <string.h>

int strcoll(const char *string1, const char *string2)
{
   char *r1 = (char *)string1 - 1;
   char *r2 = (char *)string2 - 1;
   char cp;

   do {} while ( (*++r2 == (cp = *++r1)) && cp );

   return *r1 - *r2;
}

strcpy.c/       925421694   0     0     0       536       `
/*****************************************************************************/
/* strcpy.c V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <string.h>

char *strcpy(char *dest, const char *src)
{
   char *result = dest;

   while ((*dest++ = *src++) != 0);
   return result;
}
strcspn.c/      925421694   0     0     0       768       `
/*****************************************************************************/
/* strcspn.c V5.11 for TMS3203x/4x                                          */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <string.h>

size_t strcspn(const char *string, const char *chs)
{
    const char *r1 = string - 1;
    char        ch;
    
    while ((ch = *++r1) != 0)        /* FOR EACH CHARACTER IN STRING        */
    {
        const char *check = chs;
	char        tch;
	
        while ((tch = *check++) != 0)/* FOR EACH CHARACTER IN LOOKUP STRING */
	    if (ch == tch) return r1 - string;
    }
    
    return r1 - string;
}
strerror.c/     925421696   0     0     0       408       `
/*****************************************************************************/
/* strerror.c V5.11 for TMS3203x/4x                                         */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <string.h>

char *strerror(int errno)
{
     return "string error";
}
strftime.c/     925421696   0     0     0       3763      `
/*****************************************************************************/
/* strftime.c V5.11 for TMS3203x/4x                                         */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <time.h>
#include <string.h>
#include <stdlib.h>

extern int sprintf(char *_string, const char *_format, ...);

static char *fday[] = { "Sunday",   "Monday", "Tuesday", "Wednesday", 
			"Thursday", "Friday", "Saturday" };
static char *fmon[] = { "January", "February", "March", "April", "May", "June",
			"July", "August", "September", "October", "November",
			"December" };

size_t strftime(char            *out,
	        size_t           maxsize, 
	        const char      *format,
	        const struct tm *time)
{
    struct tm temp  = *time; 
    int       count = 0;
    char      buf[37];

    mktime(&temp);     /* MAKE SURE THIS IS A LEGITIMATE TIME */

    for (;;)
    {
          while ((count < maxsize) && *format && (*format != '%'))
	  {
	      count++;
	      *out++ = *format++;
	  }

	  if (count >= maxsize) return 0;
	  if (*format == '\0')  { *out = 0; return count; }

	  switch (*++format)
	  {
               case '%' : strcpy(buf, "%");                            break;

	       case 'A' : strcpy(buf, fday[temp.tm_wday]);             break;
	       case 'a' : strcpy(buf, fday[temp.tm_wday]); buf[3] = 0; break;
	       case 'B' : strcpy(buf, fmon[temp.tm_mon]);              break;
	       case 'b' : strcpy(buf, fmon[temp.tm_mon]);  buf[3] = 0; break;
	       case 'c' : sprintf(buf, "%s %s%3d %02d:%02d:%02d %d",
				  fday[temp.tm_wday], fmon[temp.tm_mon],
				  temp.tm_mday, temp.tm_hour, temp.tm_min,
				  temp.tm_sec, temp.tm_year + 1900);
		          break;
	       case 'I' : sprintf(buf, "%02d", temp.tm_hour % 12);     break;
	       case 'H' : sprintf(buf, "%02d", temp.tm_hour);          break;
	       case 'M' : sprintf(buf, "%02d", temp.tm_min);           break;
	       case 'S' : sprintf(buf, "%02d", temp.tm_sec);           break;
	       case 'j' : sprintf(buf, "%03d", temp.tm_yday+1);        break;
	       case 'd' : sprintf(buf, "%02d", temp.tm_mday);          break;
	       case 'w' : sprintf(buf, "%1d",  temp.tm_wday);          break;
	       case 'm' : sprintf(buf, "%02d", temp.tm_mon + 1);       break;
	       case 'y' : sprintf(buf, "%02d", temp.tm_year % 100);    break;
	       case 'Y' : sprintf(buf, "%4d", 1900 + temp.tm_year);    break;

	       case 'Z' : strcpy(buf, (temp.tm_isdst > 0) ? 
				      _tz.dstname : _tz.tzname);       break;

	       case 'p' : strcpy(buf, temp.tm_hour >= 12 ? "PM":"AM"); break;

	       case 'W' : sprintf(buf, "%2d", temp.tm_yday / 7
                              + (temp.tm_mday % 7 > temp.tm_wday) 
                              + ( (temp.tm_wday==0) && ((temp.tm_mday % 7)==0) 
                              ? 0: -1) ); break;
	       case 'U' : sprintf(buf, "%2d", temp.tm_yday / 7
                              + (temp.tm_mday % 7 > temp.tm_wday));    break;

	       case 'x' : sprintf(buf, "%3s %d, %d", fmon[temp.tm_mon], 
				temp.tm_mday, temp.tm_year + 1900);    break;
	       case 'X' : sprintf(buf, "%02d:%02d:%02d", temp.tm_hour, 
					   temp.tm_min, temp.tm_sec);  break;
	  }

          /*-------------------------------------------------------------*/
          /* IF THIS STRING WILL FIT IN BUFFER, APPEND IT.               */
          /*-------------------------------------------------------------*/
	  if ((count += strlen(buf)) > maxsize) return 0;
	  strcpy(out, buf);
	  out += strlen(buf);
	  format++;
    }
}

strlen.c/       925421696   0     0     0       531       `
/*****************************************************************************/
/* strlen.c V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <string.h>

size_t strlen(const char *string)
{
   const char *r1 = string - 1;

   do {} while (*++r1);

   return r1 - string;
}

strncat.c/      925421696   0     0     0       736       `
/*****************************************************************************/
/* strncat.c V5.11 for TMS3203x/4x                                          */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <string.h>

char *strncat(char *dest, const char *src, size_t n)
{
     char *r1 = dest - 1;

     while (*++r1);                                 /* FIND END OF STRING   */

     for(;;)
	if      (--n == -1) break;
	else if (!(*r1++ = *src++)) return dest;    /* APPEND SECOND STRING */

     *r1 = 0;                                       /* ADD TERMINATION      */
     return dest;
}

strncmp.c/      925421696   0     0     0       639       `
/*****************************************************************************/
/* strncmp.c V5.11 for TMS3203x/4x                                          */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <string.h>

int strncmp(const char *string1, const char *string2, size_t n)
{
     const char *r1 = string1 - 1;
     const char *r2 = string2 - 1;
     char        cp;

     do
	if      (--n == -1) break;
	else if ((cp = *++r1) != *++r2) return *r1 - *r2;
     while (cp);

     return 0;
}

strncpy.c/      925421698   0     0     0       669       `
/*****************************************************************************/
/* strncpy.c V5.11 for TMS3203x/4x                                          */
/* Copyright (c) 1988, 1992-1999 Texas Instruments Incorporated              */
/*****************************************************************************/
#include <string.h>

char *strncpy(char *dest, const char *src, size_t n)
{
     char *r1;

     if (n == 0) return dest;

     r1 = dest;

     for(;;)
	if      (--n == -1) return dest;
        else if (!(*r1++ = *src++)) break;

     if (n != 0) do *r1++ = '\0'; while (--n);    /* TERMINATION PADDING */

     return dest;
}

strpbrk.c/      925421698   0     0     0       739       `
/*****************************************************************************/
/* strpbrk.c V5.11 for TMS3203x/4x                                          */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <string.h>

char *strpbrk(const char *string, const char *chs)
{
    char *str = (char *)string - 1;
     char  ch;

     while ((ch = *++str) != 0)      /* FOR EACH CHARACTER IN STRING        */
     {
	 const char *check = chs;
	 char        tch;

	 while ((tch = *check++) != 0)/* FOR EACH CHARACTER IN LOOKUP STRING */
	     if (ch == tch) return str;
     }
     
     return NULL;
}

strrchr.c/      925421698   0     0     0       648       `
/*****************************************************************************/
/* strrchr.c V5.11 for TMS3203x/4x                                          */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <string.h>

char *strrchr(const char *string, int c)
{
   char tch, ch = c;
   char *result = (char *)0;

   for (--string;;)
   {
      if ((tch = *++string) == ch) result = (char*)string;
      if (tch == 0) break;
   }

   return result;
}
strspn.c/       925421698   0     0     0       783       `
/*****************************************************************************/
/* strspn.c V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <string.h>

size_t strspn(const char *string, const char *chs)
{
     const char *r1 = string - 1;
     char        ch;

     while ((ch = *++r1) != 0)    /* FOR EACH CHARACTER IN STRING        */
     {
        const char *check = chs;
	char        tch;

        do                        /* FOR EACH CHARACTER IN LOOKUP STRING */
	   if (!(tch = *check++)) return r1 - string;
	while (tch != ch);
     }
     return r1 - string;
}

strstr.c/       925421698   0     0     0       732       `
/*****************************************************************************/
/* strstr.c V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <string.h>

char *strstr(const char *string1, const char *string2)
{
     char cp1, cp2;
     const char *pos = string1;

     while (*string1)         /* FOR EACH STRING IN SOURCE STRING */
     {
         const char *cmp = string2;

         while (((cp1 = *string1++) == (cp2 = *cmp++)) && cp1);
	 if (cp2 == 0) return (char *)pos;
	 string1 = ++pos;
     }
     return NULL;
}

strtod.c/       925421698   0     0     0       3080      `
/*****************************************************************************/
/* strtod.c V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <stdlib.h>
#include <ctype.h>
#include <float.h>
#include <errno.h>
#include <math.h>

static long double powerof10[]  = { 1.e1, 1.e2, 1.e4, 1.e8, 1.e16, 1.e32 };
static long double digits[]     = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

double strtod(const char *st, char **endptr)
{
    long double      result = 0;
    char        cp;
    const char *fst    = st;
    int         exp    = 0;               /* EXPONENT              */
    int         count;                    /* EXPONENT CALCULATION  */
    int         value  = 0;               /* SUCCESSFUL PARSE      */
    int         sign;

    while (isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if ((sign = ((cp = *fst) == '-')) || (cp == '+')) { ++fst; value = 1; }

    /*----------------------------------------------------------------------*/
    /* READ IN FRACTIONAL PART OF NUMBER, UNTIL AN 'E' IS REACHED.          */
    /* COUNT DIGITS AFTER DECIMAL POINT.                                    */
    /*----------------------------------------------------------------------*/
    for (; isdigit(cp = *fst); ++fst) 
    {
       result = result * 10 + digits[cp - '0']; 
       value  = 1;
    }

    if (cp == '.')
       while (isdigit(cp = *++fst)) 
       {
          result = result * 10 + digits[cp - '0']; 
          value  = 1;
	  --exp;
       }

    if (sign) result = -result;  /* IF NEGATIVE NUMBER, REVERSE SIGN */

    /*----------------------------------------------------------------------*/
    /* READ IN EXPLICIT EXPONENT AND CALCULATE REAL EXPONENT.               */
    /*----------------------------------------------------------------------*/
    if (value && toupper(*fst) == 'E')
    {
       if ((sign = ((cp = *++fst) == '-')) || (cp == '+')) cp = *++fst;

       for (count = 0; isdigit(cp); cp = *++fst)
	  { count *= 10; count += cp - '0'; }

       if (sign) exp -= count;
	    else exp += count;
    }

    /*----------------------------------------------------------------------*/
    /* ADJUST NUMBER BY POWERS OF TEN SPECIFIED BY FORMAT AND EXPONENT.     */
    /*----------------------------------------------------------------------*/
    if (result != 0.0)
    {
       if (exp > DBL_MAX_10_EXP) 
	  { errno = ERANGE; result = (result < 0) ? -HUGE_VAL : HUGE_VAL; }
       else if (exp < DBL_MIN_10_EXP) 
	  { errno = ERANGE; result = 0.0; }

       else if (exp < 0)
	  for (count = 0, exp = -exp; exp; count++, exp >>= 1)
	     {  if (exp & 1) result /= powerof10[count]; }
       else
	  for (count = 0; exp; count++, exp >>= 1)
	     {  if (exp & 1) result *= powerof10[count]; }
    }

    if (endptr) *endptr = (char *)(value ? fst : st);
    return result;
}
strtok.c/       925421700   0     0     0       718       `
/*****************************************************************************/
/* strtok.c V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <string.h>

char *strtok(char *str1, const char *str2)
{
     static char *last_end;
     char        *start; 

     if (str1) last_end = str1;

     last_end += strspn(last_end, str2);
     if (*last_end == '\0') return NULL;

     start = last_end;
     last_end += strcspn(last_end, str2);

     if (*last_end != '\0') *last_end++ = '\0'; 

     return start;
}

strtol.c/       925421700   0     0     0       2778      `
/*****************************************************************************/
/* strtol.c V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>

long strtol(const char *st, char **endptr, int base)
{
    long        result = 0;
    char        cp;
    const char *fst    = st;
    int         digits = 0;
    int         sign;

    while (isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */

    if ((sign = ((cp = *fst) == '-')) != 0) cp = *++fst;
    else if (cp == '+') cp = *++fst;

    if (base > 36) base = 0;

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if (cp != '0') base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
                  {
		      if (isxdigit(fst[1])) { base = 16; cp = *++fst; }
		      else                  { base = 10; cp = *--fst; }
                  }
		  else 
		  {
		      base = 8; 
		      if (cp < '0' || cp > '7')  cp = *--fst;
		  }
                  break;

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')))
		      cp = *(fst += 2);
		  if (!isxdigit(cp)) cp = *(fst -= 2);
    }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	long addval;

	if (!((isdigit(cp) && (addval = cp - '0')      < base) ||
	      (isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (char *)st;       
	    return sign ? LONG_MIN : LONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.  NEGATE THE RESULT IF A      */
    /* MINUS SIGN WAS SEEN.                                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (char *)(digits ? fst : st);
    if (sign)
    {
	if (result > LONG_MAX) { errno = ERANGE; return (LONG_MIN); }
        return -result;
    }
    return result;
}

strtoul.c/      925421700   0     0     0       2502      `
/*****************************************************************************/
/* strtoul.c V5.11 for TMS3203x/4x                                          */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>

unsigned long strtoul(const char *st, char **endptr, int base)
{
    unsigned long result = 0;
    char          cp;
    const char   *fst = st;
    int           digits = 0;

    while (isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if (base > 36) base = 0;  

    if ((cp = *fst) == '+') cp = *++fst;

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if      (cp != '0')           base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
		  {
		     if   (isxdigit(fst[1])) { base = 16; cp = *++fst; }
		     else                    { base = 10; cp = *--fst; }
		  }
		  else 
		  {
		     base = 8; 
		     if (cp < '0' || cp > '7')  cp = *--fst;
		  }
                  break;

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')))
		     cp = *(fst += 2);
		  if (!isxdigit(cp)) cp = *(fst -= 2);
    }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	unsigned long addval;

	if (!((isdigit(cp) && (addval = cp - '0')      < base) ||
	      (isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (char *)st;        
	    return ULONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (char *)(digits ? fst : st);

    return result;
}

strxfrm.c/      925421700   0     0     0       679       `
/*****************************************************************************/
/* strxfrm.c V5.11 for TMS3203x/4x                                          */
/* Copyright (c) 1992-1999 Texas Instruments Inc.                            */
/*****************************************************************************/
#include <string.h>
#include <stddef.h>

size_t strxfrm(char *to, const char *from, size_t n)
{
     int count = 0;     
     while (*from++) count++;                     /* GET LENGTH OF STRING */
     from -= count;
     from--;

     if (n != 0) while((*to++ = *from++) && (--n != 0)) ;  /* COPY STRING */

     return ((size_t) count);
}

tan.c/          925421700   0     0     0       2579      `
/*****************************************************************************/
/* tan.c V5.11 for TMS3203x/4x                                              */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/

#include <math.h>
#include <values.h>

/****************************************************************************/
/*  TAN() - Tangent							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 9.              */
/*									    */
/*  N = round(x * 2 / PI) 						    */
/*  f = mantissa x							    */
/*  g = f * f								    */
/*  xnum = f * p1 * g + 1						    */
/*  xden = (q2 * g + q1) * g + 1					    */
/*									    */
/*  if N is even, result = xnum / xden					    */
/*  if N is odd, result = xden / - xnum 				    */
/*									    */
/*  This will return the wrong result for x >= MAXINT * PI		    */
/****************************************************************************/
double tan(double x)
{
    double xn, f, g, xnum, xden;
    int n;

    /*************************************************************************/
    /* n = round(x * 2/PI)                                                   */
    /*************************************************************************/
    if (x < 0.0) n = (int) (x * TWOINVPI - 0.5);  /* since (int) -1.5 = -1.0 */
    else         n = (int) (x * TWOINVPI + 0.5);

    xn = (float) n;

    /*************************************************************************/
    /* f = x - xn * PI / 2 (but more mathematically stable)                  */
    /*************************************************************************/
    f = (x - xn * C5) - xn * C6;

    /*************************************************************************/
    /* determine polynomial expression                                       */
    /*************************************************************************/
    g = f * f;

    xnum = TAP1 * g * f + f;
    xden = (TAQ2 * g + TAQ1) * g + 0.5 + 0.5;

    /*************************************************************************/
    /* if n is odd                                                           */
    /*************************************************************************/
    if (n % 2 == 0) return (xnum / xden);
    else            return (xden / -xnum);	
}

tanh.c/         925421702   0     0     0       2126      `
/*****************************************************************************/
/* tanh.c V5.11 for TMS3203x/4x                                             */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/

#include <math.h>
#include <values.h>

/****************************************************************************/
/*  TANH() - Hyperbolic Tangent						    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 13.             */
/*  This also uses the Cody and Waite algorithm for exp in chapter 6.	    */
/*									    */
/*  f = abs(x)								    */
/*  if f < ln(3) / 2,							    */
/*	g = f * f							    */
/*	R = polynomial expansion					    */
/*	result = f + f * R						    */
/*									    */
/*  if d > XBIG, result = sign(x)                                           */
/*  if f > ln(3) / 2 & f <= XBIG, result = 1 - 2 / (exp(2f) + 1)	    */
/*  if f < ln(3) / 2, R = polynomial expansion; result = f + f * R          */
/*  if x < 0, result = - result 					    */
/****************************************************************************/
double tanh(double x)
{
    double f = x, g, p, q, r;
    float  s = (x < 0) ? -1.0 : 1.0; 

    f = fabs(x);

    if      (f > XBIG)     return (s);
    else if (f > LOGe3by2) return ((1.0 - 2.0 / (exp(2.0 * f) + 1.0)) * s);

    /**********************************************************************/
    /* determine polynomial expression                                    */
    /**********************************************************************/
    g = f * f;

    p = (THP1 * g + THP0) * g;
    q = g + THQ0;

    r = p / q;

    /*****************************************************************/
    /* tanh(x) = sign * result                                       */
    /*****************************************************************/
    return (s * (f + f * r));
}
time.c/         925421702   0     0     0       516       `
/*****************************************************************************/
/*  TIME.C V5.11                                                            */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <time.h> 

extern time_t HOSTtime();

time_t time(time_t *timer) 
{
   time_t result;

   result = (time_t)HOSTtime();
   if(timer) *timer = result;
   return(result);
}

tmpfile.c/      925421702   0     0     0       1365      `
/*****************************************************************************/
/*  TMPFILE.C V5.11                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    TMPFILE  -  Create a temporary file, and return a pointer to the       */
/*                stream                                                     */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <string.h>






/*****************************************************************************/
/* TMPFILE  -  Create a temporary file, and return a pointer to its FILE     */
/*             structure                                                     */
/*****************************************************************************/
FILE *tmpfile(void)
{
   char tfname[L_tmpnam];
   FILE *_fp = (tmpnam(tfname)) ? (fopen(tfname, "wb+")) : NULL;

   if(_fp)
   {
      _SET(_fp, _TMPFILE);
      strcpy(_tmpnams[_fp->fd], tfname);
   }

   return (_fp);
}


tmpnam.c/       925421702   0     0     0       4102      `
/*****************************************************************************/
/*  TMPNAM.C V5.11                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    TMPNAM   -  Generate a unique filename                                 */
/*    _GETNAME -  Generate the character string for the filename             */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <string.h>

static char *_getname(int cnt, char *result);


/*****************************************************************************/
/* TMPNAM   -  Generate a unique filename                                    */
/*                                                                           */
/*    This function generates a unique filename, and can be called up to     */
/*    TMP_MAX times.                                                         */
/*                                                                           */
/*****************************************************************************/
char *tmpnam(char *_s)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   static long   counter           = 0;
   int                    fd;
   static char            tfname[L_tmpnam];
 
   /*------------------------------------------------------------------------*/ 
   /* Get a filename from _GETNAME                                           */
   /*------------------------------------------------------------------------*/ 
   _getname(counter++, tfname);

   /*------------------------------------------------------------------------*/ 
   /* Check to see if the filename exists.  Keep getting filenames until     */
   /* a unique one is found, or this function has reached its limit.         */
   /*------------------------------------------------------------------------*/ 
   while(((fd=open(tfname, O_RDONLY, 0666)) >= 0) && (counter < TMP_MAX))
   {
      close(fd);
      _getname(counter++, tfname);
   }
 
   if(counter >= TMP_MAX) return (NULL);
 
   /*------------------------------------------------------------------------*/ 
   /* If _S is not NULL, store the new filename in it.                       */
   /*------------------------------------------------------------------------*/ 
   if(_s)
   {
      strcpy(_s, tfname);
      return (_s);
   }
 
   return (tfname);
}


/*****************************************************************************/
/* _GETNAME -  Generate the character string for the filename                */
/*                                                                           */
/*    This function takes a number passed to it bu TMPNAM, and generates a   */
/*    filename from it.  It returns a pointer to the filename.               */
/*                                                                           */
/*****************************************************************************/
static char *_getname(int cnt, char *result)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char *end   = result + L_tmpnam -1;
   char *spos;
 
   strcpy(result, P_tmpdir);
   spos = (result + strlen(result));
 
   *(spos++) = 'T';
 
   for(;cnt; cnt /= 10) *(spos++) = ((cnt % 10)+ '0');
 
   for(;spos < end; *(spos++)='0');
   *(end--) = '\0';
 
   return (result);
}

tmzone.c/       925421702   0     0     0       982       `
/*****************************************************************************/
/* tmzone.c V5.11 for TMS3203x/4x                                           */
/* Copyright (c) 1992-1999  Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <time.h>

/****************************************************************************/
/* CUSTOMIZE THE VALUES IN THIS STRUCTURE FOR YOUR TIME ZONE                */
/* DEFAULT VALUES FOR CENTRAL TIME, USA                                     */
/****************************************************************************/
struct tmzone _tz =
{
   0,                       /* True if daylight savings time        */
   6 * 60 * 60,             /* Number of seconds behind GMT         */
   "CST",                   /* Name of timezone, e.g. CST           */
   "CDT",                   /* Name when daylight true, e.g. CDT    */
};

toxxx.c/        925421704   0     0     0       760       `
/*****************************************************************************/
/* toxxx.c V5.11 for TMS3203x/4x                                            */
/* Copyright (c) 1992-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <ctype.h>

int tolower(int ch)
{
   int ch2 = ch + ('a' - 'A');
   return ( (unsigned int)(ch - 'A') <= (unsigned int)('Z' - 'A')) ? ch2 : ch;
}

int toupper(int ch)
{
   int ch2 = ch + ('A' - 'a');
   return ( (unsigned int)(ch - 'a') <= (unsigned int)('z' - 'a')) ? ch2 : ch;
}

int toascii(int c)  { return _toascii(c);  }           /* NON-STANDARD */
trgdrv.c/       925421704   0     0     0       6633      `
/*****************************************************************************/
/*  TRGDRV.C V5.11                                                          */
/*  Copyright (c) 1996-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/****************************************************************************/
/* Functions:                                                               */
/*    HOSTopen()    -    Sends open command with arguments to the host      */
/*    HOSTclose()   -    Sends close command with arguments to the host     */
/*    HOSTread()    -    Sends read command with arguments to the host      */
/*    HOSTwrite()   -    Sends write command with arguments to the host     */
/*    HOSTlseek()   -    Sends lseek command with arguments to the host     */
/*    HOSTunlink()  -    Sends unlink command with arguments to the host    */
/*    HOSTrename()  -    Sends rename command with arguments to the host    */
/*    GETENV()      -    Get the enviroment value for the passed variable   */
/*                        name                                              */
/*    HOSTTIME()    -    Get the time from the host                         */
/*    HOSTCLK()     -    Get the target clock value (CLK register)          */
/****************************************************************************/
#include "stdio.h"
#include "trgcio.h"
#include <string.h>
#include "time.h"

extern int  HOSTopen(const char *path, unsigned flags, int fno),
            HOSTclose(int fno),
            HOSTread(int fno, char *buf, unsigned count),
            HOSTwrite(int fno, const char *buf, unsigned count),
            HOSTunlink(const char *path),
            HOSTrename(const char *old_name, const char *new_name);
extern fpos_t HOSTlseek(int fno, fpos_t offset, int origin);
extern time_t HOSTtime(void);
extern clock_t HOSTclock(void);

extern void readmsg(register unsigned char *parm,
               register char *data);
extern void writemsg(unsigned char  command,
                     register unsigned char *parm,
                     register char *data,
                     unsigned int   length);

unsigned char parmbuf[8];


/****************************************************************************/
/* HOSTOPEN()  -  Pass the open command and its arguments to the host.      */
/****************************************************************************/
int HOSTopen(const char *path,
             unsigned    flags,
             int         fno)
{
   LOADSHORT(parmbuf,fno,0);
   LOADSHORT(parmbuf,flags,2);

   writemsg(_DTOPEN,parmbuf,(char *)path,strlen(path)+1);  /* SEND NULL ACROSS ALSO */
   readmsg(parmbuf,NULL);

   return UNLOADSHORT(parmbuf,0);
}

/****************************************************************************/
/* HOSTCLOSE()  -  Pass the close command and its arguments to the host.    */
/****************************************************************************/
int HOSTclose(int fno)
{
   LOADSHORT(parmbuf,fno,0);

   writemsg(_DTCLOSE,parmbuf,NULL,0);
   readmsg(parmbuf,NULL);

   return UNLOADSHORT(parmbuf,0);
}

/****************************************************************************/
/* HOSTREAD()  -  Pass the read command and its arguments to the host.      */
/****************************************************************************/
int HOSTread(int      fno,
             char    *buf,
             unsigned count)
{
   LOADSHORT(parmbuf,fno,0);
   LOADSHORT(parmbuf,count,2);

   writemsg(_DTREAD,parmbuf,NULL,0);
   readmsg(parmbuf,buf);

   return UNLOADSHORT(parmbuf,0);
}

/****************************************************************************/
/* HOSTWRITE()  -  Pass the write command and its arguments to the host.    */
/****************************************************************************/
int HOSTwrite(int         fno,
              const char *buf,
              unsigned    count)
{
   LOADSHORT(parmbuf,fno,0);
   LOADSHORT(parmbuf,count,2);
   writemsg(_DTWRITE,parmbuf,(char *)buf,count);
   readmsg(parmbuf,NULL);
   return UNLOADSHORT(parmbuf,0);
}

/****************************************************************************/
/* HOSTLSEEK()  -  Pass the lseek command and its arguments to the host.    */
/****************************************************************************/
fpos_t HOSTlseek(int fno,
		 fpos_t offset,
		 int origin)
{
   LOADSHORT(parmbuf,fno,0);
   LOAD32(parmbuf,offset,2);
   LOADSHORT(parmbuf,origin,6);

   writemsg(_DTLSEEK,parmbuf,NULL,0);
   readmsg(parmbuf,NULL);

   return UNLOAD32(parmbuf,0);
}

int HOSTunlink(const char *path)
{
   writemsg(_DTUNLINK,parmbuf,(char *)path,strlen(path) + 1);
   readmsg(parmbuf,NULL);

   return UNLOADSHORT(parmbuf,0);
}

int  HOSTrename(const char *old,
                const char *new)
{
   char combined[100];
   int length;
   strcpy(combined,old);
   length = strlen(old)+1;
   strcpy(combined+length,new);
   length += strlen(new) + 1;

   writemsg(_DTRENAME,parmbuf,combined,length);
                                                 /*SEND NULL ACROSS ALSO*/
   readmsg(parmbuf,NULL);

   return UNLOADSHORT(parmbuf,0);
}


/****************************************************************************/
/* GETENV()  -  Get the enviroment value for the passed variable name       */
/****************************************************************************/
char *getenv(const char *_string)
{
   static char result[200];
   writemsg(_DTGETENV,parmbuf,(char *)_string,strlen(_string) + 1);
   readmsg(parmbuf,result);

   return (UNLOADSHORT(parmbuf,0) == 0) ? NULL : result;
}

/****************************************************************************/
/* HOSTTIME()  -  Get the time from the host                                */
/****************************************************************************/
time_t HOSTtime(void)
{
   writemsg(_DTGETTIME,parmbuf,NULL,0);
   readmsg(parmbuf, NULL);

   return((time_t)(UNLOAD32(parmbuf,0)));
}

/****************************************************************************/
/* HOSTclock()  -  Get the current number of clock ticks                    */
/****************************************************************************/
clock_t HOSTclock(void)
{
   writemsg(_DTGETCLK,parmbuf,NULL,0);
   readmsg(parmbuf, NULL);

   return((clock_t)(UNLOAD32(parmbuf,0)));
}
 

trgmsg.c/       925421704   0     0     0       5256      `
/*****************************************************************************/
/*  TRGMSG.C V5.11                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Bottom level data transfer routines for host communication with the       */
/* target.                                                                   */
/*                                                                           */
/* Functions:                                                                */
/*  writemsg()  -  Sends the passed data and parameters on to the host.      */
/*  readmsg()   -  Reads the data and parameters passed from the host.       */
/*****************************************************************************/
#include "stdio.h"
#include "trgcio.h"


#if BSSCIOBUF
#define DEFCIO(size) unsigned char _CIOBUF_[size]

#elif defined(_MVP_PP) || defined(_MVP_MP)
#pragma SHARED   (_CIOBUF_);
#pragma DATA_SECTION (_CIOBUF_, ".cio");
#pragma DATA_ALIGN   (_CIOBUF_, 4);
#define DEFCIO(size) unsigned char _CIOBUF_[size]

#elif defined(_TMS370C8)
#define STR(x) #x
#define DEFCIO(size) asm("__CIOBUF_: .usect  .cio," STR(size)); \
		     extern far unsigned char _CIOBUF_[size]

#elif defined(_TMS320C30) || defined(_TMS320C40)
#define STR(x) #x
#define DEFCIO(size) asm("__CIOBUF_: .usect  .cio," STR(size)); \
                    extern unsigned char _CIOBUF_[size]
#else
#define STR(x) #x
#define DEFCIO(size) asm("__CIOBUF_: .usect  .cio," STR(size) ",4"); \
		     extern unsigned char _CIOBUF_[size]
#endif

DEFCIO(CIOBUFSIZ);


/***************************************************************************/
/*                                                                         */
/*  WRITEMSG()  -  Sends the passed data and parameters on to the host.    */
/*                                                                         */
/***************************************************************************/
void writemsg(unsigned char           command,
              register unsigned char *parm,
              register char          *data,
              unsigned int            length)
{
    register unsigned char * volatile p = (unsigned char *) _CIOBUF_;

    register unsigned int i;

    /***********************************************************************/
    /* THE LENGTH IS WRITTEN AS A TARGET INT                               */
    /***********************************************************************/ 
    *(unsigned int *)p = length; 
    p += sizeof(unsigned int);

    /***********************************************************************/ 
    /* THE COMMAND IS WRITTEN AS A TARGET BYTE                             */
    /***********************************************************************/ 
    *p++ = command;

    /***********************************************************************/ 
    /* PACK THE PARAMETERS AND DATA SO THE HOST READS IT AS BYTE STREAM    */
    /***********************************************************************/ 
    for (i = 0; i < 8; i++)      PACKCHAR(*parm++, p, i);
    for (i = 0; i < length; i++) PACKCHAR(*data++, p, i+8);


    /***********************************************************************/
    /* THE BREAKPOINT THAT SIGNALS THE HOST TO DO DATA TRANSFER            */
    /***********************************************************************/
    asm("	.global	C$$IO$$");

    asm("	nop");
    asm("C$$IO$$:nop");
}

extern void writemsg(unsigned char command, unsigned char *parm,
                    char *data, unsigned int length);
extern void readmsg(unsigned char *parm, char *data);


/***************************************************************************/
/*                                                                         */
/*  READMSG()   -  Reads the data and parameters passed from the host.     */
/*                                                                         */
/***************************************************************************/
void readmsg(register unsigned char *parm,
             register char          *data)
{
    register unsigned char * volatile p = (unsigned char *) _CIOBUF_;

    register unsigned int i;
    unsigned int length;

    /***********************************************************************/
    /* THE LENGTH IS READ AS A TARGET INT                                  */
    /***********************************************************************/
    length = *(unsigned int *)p;
    p += sizeof(unsigned int);
    
    /***********************************************************************/
    /* UNPACK THE PARAMETERS AND DATA                                      */
    /***********************************************************************/
    for (i = 0; i < 8; i++) *parm++ = UNPACKCHAR(p, i);
    if (data != NULL) 
       for (i = 0; i < length; i++) *data++ = UNPACKCHAR(p, i+8);
}
ungetc.c/       925421704   0     0     0       3497      `
/*****************************************************************************/
/*  UNGETC.C V5.11                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    UNGETC   -  Push a character back onto a stream                        */
/*****************************************************************************/
#include <stdio.h>






/*****************************************************************************/
/* UNGETC   -  Push a character back onto a stream                           */
/*                                                                           */
/*    This function returns the character pushed back upon success, or an    */
/*    EOF upon failure.                                                      */
/*                                                                           */
/*****************************************************************************/
int ungetc(int _c, register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the character is an EOF, or if an UNGETC has already been performed */
   /* and there is no room left in the buffer, return an EOF.                */
   /*------------------------------------------------------------------------*/
   if(_c == EOF || (_fp->pos < _fp->buf)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the file is in update mode, and is currently writing, change it to  */
   /* read mode.                                                             */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODERW))
   {
      _UNSET(_fp, _MODEW);
      _SET(_fp, _MODER);
   }
 
   /*------------------------------------------------------------------------*/
   /* Set up a buffer if one is needed, and none exists.                     */
   /*------------------------------------------------------------------------*/
   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))
      if(setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ) == EOF) return (EOF);
 
   /*------------------------------------------------------------------------*/
   /* Put the character in the buffer, set the _UNGETC flag in the stream,   */
   /* and clear the EOF flag in the stream.                                  */
   /*------------------------------------------------------------------------*/
   *(--_fp->pos) = (unsigned char)_c;
   _SET(_fp, _UNGETC);
   _UNSET(_fp, _STATEOF);

   /*------------------------------------------------------------------------*/
   /* If this is an UNGETC on an empty file, make the end of the read buffer.*/
   /*------------------------------------------------------------------------*/
   if(!_fp->buff_stop) _fp->buff_stop = _fp->buf;

   return ((unsigned char)_c);
}


vfprintf.c/     925421704   0     0     0       2819      `
/*****************************************************************************/
/*  VFRINTF.C V5.11                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    VFPRINTF -  Print formatted output to a stream                         */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include "format.h"
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op, 
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);
 
 
 
 
 

/*****************************************************************************/
/* VFPRINTF -  Print formatted output to a stream                            */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream _FP.              */
/*                                                                           */
/*****************************************************************************/
int vfprintf(FILE *_fp, const char *_format, va_list _ap)
{
   char *fptr = (char *)_format;

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (-1);

   return (_printfi(&fptr, _ap, (void *)_fp, _outc, _outs));
 
}
 
 

 


/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }
 
 
 
 
 

/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }


vprintf.c/      925421706   0     0     0       2817      `
/*****************************************************************************/
/*  VPRINTF.C V5.11                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    VPRINTF  -  Print formatted output to stdio                            */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op,
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);
 
 
 
 
 

/*****************************************************************************/
/* VPRINTF  -  Print formatted output to a stdio                             */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream stdio.            */
/*                                                                           */
/*****************************************************************************/
int vprintf(const char *_format, va_list _ap)
{
   char *fptr = (char *)_format;

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(stdout->fd == -1) return (EOF);

   return (_printfi(&fptr, _ap, (void *)stdout, _outc, _outs));
 
}
 
 
 
 
 


/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }
 
 
 
 
 

/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }


vsprintf.c/     925421706   0     0     0       2600      `
/*****************************************************************************/
/*  VSPRINTF.C V5.11                                                        */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    VSPRINTF -  Copy formatted output to a string                          */
/*    _OUTC    -  Put a character in a string                                */
/*    _OUTS    -  Append a string to another string                          */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op,
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);






/*****************************************************************************/
/* VSPRINTF -  Copy formatted output to a string                             */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the string _STRING.          */
/*                                                                           */
/*****************************************************************************/
int vsprintf(char *_string, const char *_format, va_list _ap)
{
   char *fptr = (char *)_format;
   *_string = '\0';
   return (_printfi(&fptr, _ap, (void *)_string, _outc, _outs));

}
 
 
 
 


/*****************************************************************************/
/* _OUTC -  Put a character in a string                                      */
/*****************************************************************************/
static int _outc(char c, void *_op)
{
   strncat((char *)_op, &c, 1);
   return(c);
}
 
 
 
 
 

/*****************************************************************************/
/* _OUTS -  Append a string to another string                                */
/*****************************************************************************/
static int _outs(char *s, void *_op)
{
   strcat((char *)_op, s);
   return(strlen(s));
}
 
